use super::machine::inst::MachineInstId;
use crate::ir::types::*;
use id_arena::{Arena, Id};
use rustc_hash::{FxHashMap, FxHashSet};
use std::{
    cell::{Ref, RefCell, RefMut},
    fmt,
    ops::{BitAnd, BitOr},
    ops::{Index, IndexMut},
    rc::Rc,
};

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysReg(pub usize);

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct VirtReg(pub usize);

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct RegisterId {
    pub id: Id<RegisterInfo>,
    pub kind: VirtOrPhys,
}

#[derive(Clone, Debug)]
pub struct RegisterInfo {
    pub virt_reg: VirtReg,
    pub phys_reg: Option<PhysReg>,
    pub reg_class: RegisterClassKind,
    pub tied: Option<RegisterId>,
    pub uses: FxHashSet<MachineInstId>,
    pub defs: FxHashSet<MachineInstId>,
}

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub enum VirtOrPhys {
    Virt(VirtReg),
    Phys(PhysReg),
}

#[derive(Clone)]
pub struct RegistersInfo {
    cur_virt_reg: RefCell<usize>,
    arena: RefCell<RegisterArena>,
    phys_regs_list: Vec<RegisterId>,
}

#[derive(Clone)]
pub struct RegisterArena(pub Arena<RegisterInfo>);

#[derive(Debug, Clone)]
pub struct VirtRegGen {
    id: Rc<RefCell<usize>>,
}

// TODO: THE CODE IN THIS FILE WILL BE AUTO-GENERATED BY MACRO IN THE FUTURE

const GPR_NUM: isize = 32;
pub const PHYS_REGISTERS_NUM: usize = (GPR_NUM) as usize;

// Remember to fix PhysReg::reg_class() when appending a variant
#[derive(Debug, Clone, Copy, Hash, PartialEq)]
pub enum RegisterClassKind {
    GPR = 0,
}

// TODO: TEMPORARY FUNCTIONS. WILL BE REMOVED.
pub fn ty2rc(ty: &Type) -> Option<RegisterClassKind> {
    match ty {
        Type::Void => None,
        Type::Int32 => Some(RegisterClassKind::GPR),
        Type::Int64 => Some(RegisterClassKind::GPR),
        Type::F64 => None,
        Type::Pointer(_) => Some(RegisterClassKind::GPR),
        Type::Array(_) => None,
        e => unimplemented!("{:?}", e),
    }
}

pub fn rc2ty(rc: RegisterClassKind) -> Type {
    match rc {
        RegisterClassKind::GPR => Type::Int64,
        // RegisterClassKind::GR64 => Type::Int64,
        // RegisterClassKind::XMM => Type::F64,
    }
}

impl PhysReg {
    pub fn reg_class(&self) -> RegisterClassKind {
        // TODO
        RegisterClassKind::GPR
        // let n = self.retrieve();
        // if RegisterClassKind::GR32 as usize <= n && n < RegisterClassKind::GR64 as usize {
        //     return RegisterClassKind::GR32;
        // } else if RegisterClassKind::GR64 as usize <= n && n < RegisterClassKind::XMM as usize {
        //     return RegisterClassKind::GR64;
        // }
        // RegisterClassKind::XMM
    }
}

macro_rules! to_phys {
    ($($r:path),*) => {
        vec![$(($r.as_phys_reg())),*]
    };
}

impl RegisterClassKind {
    pub fn get_reg_order(&self) -> RegisterOrder {
        RegisterOrder::general_purpose(*self)
    }

    pub fn get_arg_reg_order(&self) -> RegisterOrder {
        RegisterOrder::arguments(*self)
    }

    pub fn get_nth_arg_reg(&self, nth: usize) -> Option<PhysReg> {
        self.get_arg_reg_order_vec().get(nth).map(|r| *r)
    }

    pub fn size_in_bits(&self) -> usize {
        match self {
            Self::GPR => 64,
        }
    }

    pub fn size_in_byte(&self) -> usize {
        self.size_in_bits() / 8
    }

    pub fn shares_same_register_file(&self, rc: RegisterClassKind) -> bool {
        self.register_file_base_class() == rc.register_file_base_class()
    }

    pub fn register_file_base_class(&self) -> RegisterClassKind {
        match self {
            Self::GPR => RegisterClassKind::GPR,
        }
    }

    // Returns normal order of registers used to pass arguments
    // TODO: This is System V AMD64 ABI.
    // https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI
    pub fn get_arg_reg_order_vec(&self) -> Vec<PhysReg> {
        match self {
            RegisterClassKind::GPR => to_phys!(
                GPR::A0,
                GPR::A1,
                GPR::A2,
                GPR::A3,
                GPR::A4,
                GPR::A5,
                GPR::A6,
                GPR::A7
            ),
        }
    }

    // Returns normal order of general-purpose registers
    pub fn get_gp_reg_order_vec(&self) -> Vec<PhysReg> {
        // commented-out registers are callee-saved registers
        match self {
            RegisterClassKind::GPR => to_phys!(
                GPR::T0,
                GPR::T1,
                GPR::T2,
                GPR::A0,
                GPR::A1,
                GPR::A2,
                GPR::A3,
                GPR::A4,
                GPR::A5,
                GPR::A6,
                GPR::A7,
                GPR::T3,
                GPR::T4,
                GPR::T5,
                GPR::T6
            ),
        }
    }

    pub fn return_value_register(&self) -> PhysReg {
        match self {
            Self::GPR => GPR::A0.as_phys_reg(),
        }
    }
}

// TODO: The definition of GR32 is now hard coded in ROOT/defs/src/register.rs
// use defs::define_registers;
// define_registers!(
//     RegisterClass GR32 (i32) {
//     }
// );

#[derive(Debug, Clone, Copy, Hash, PartialEq)]
pub enum GPR {
    ZERO, // MYRISCVXGPRReg<0,  "zero", ["zero"]>,  DwarfRegNum<[0]>;

    RA, // MYRISCVXGPRReg<1,  "x1", ["ra"]>,    DwarfRegNum<[1]>;
    SP, // MYRISCVXGPRReg<2,  "x2", ["sp"]>,    DwarfRegNum<[2]>;
    GP, // MYRISCVXGPRReg<3,  "x3", ["gp"]>,    DwarfRegNum<[3]>;
    TP, // MYRISCVXGPRReg<4,  "x4", ["tp"]>,    DwarfRegNum<[4]>;
    T0, // MYRISCVXGPRReg<5,  "x5", ["t0"]>,    DwarfRegNum<[5]>;
    T1, // MYRISCVXGPRReg<6,  "x6", ["t1"]>,    DwarfRegNum<[6]>;
    T2, // MYRISCVXGPRReg<7,  "x7", ["t2"]>,    DwarfRegNum<[7]>;
    S0, // MYRISCVXGPRReg<8,  "x8", ["s0", "fp"]>, DwarfRegNum<[8]>;  // used as FP
    S1, // MYRISCVXGPRReg<9,  "x9", ["s1"]>,    DwarfRegNum<[9]>;

    A0, // MYRISCVXGPRReg<10, "x10", ["a0"]>,   DwarfRegNum<[10]>;
    A1, // MYRISCVXGPRReg<11, "x11", ["a1"]>,   DwarfRegNum<[11]>;
    A2, // MYRISCVXGPRReg<12, "x12", ["a2"]>,   DwarfRegNum<[12]>;
    A3, // MYRISCVXGPRReg<13, "x13", ["a3"]>,   DwarfRegNum<[13]>;
    A4, // MYRISCVXGPRReg<14, "x14", ["a4"]>,   DwarfRegNum<[10]>;
    A5, // MYRISCVXGPRReg<15, "x15", ["a5"]>,   DwarfRegNum<[11]>;
    A6, // MYRISCVXGPRReg<16, "x16", ["a6"]>,   DwarfRegNum<[12]>;
    A7, // MYRISCVXGPRReg<17, "x17", ["a7"]>,   DwarfRegNum<[13]>;

    S2,  // MYRISCVXGPRReg<18, "x18", ["s2"]>,   DwarfRegNum<[18]>;
    S3,  // MYRISCVXGPRReg<19, "x19", ["s3"]>,   DwarfRegNum<[19]>;
    S4,  // MYRISCVXGPRReg<20, "x20", ["s4"]>,   DwarfRegNum<[20]>;
    S5,  // MYRISCVXGPRReg<21, "x21", ["s5"]>,   DwarfRegNum<[21]>;
    S6,  // MYRISCVXGPRReg<22, "x22", ["s6"]>,   DwarfRegNum<[22]>;
    S7,  // MYRISCVXGPRReg<23, "x23", ["s7"]>,   DwarfRegNum<[23]>;
    S8,  // MYRISCVXGPRReg<24, "x24", ["s8"]>,   DwarfRegNum<[24]>;
    S9,  // MYRISCVXGPRReg<25, "x25", ["s9"]>,   DwarfRegNum<[25]>;
    S10, // MYRISCVXGPRReg<26, "x26", ["s10"]>,   DwarfRegNum<[26]>;
    S11, // MYRISCVXGPRReg<27, "x27", ["s11"]>,   DwarfRegNum<[27]>;

    T3, // MYRISCVXGPRReg<28, "x28", ["t3"]>,   DwarfRegNum<[28]>;
    T4, // MYRISCVXGPRReg<29, "x29", ["t4"]>,   DwarfRegNum<[29]>;
    T5, // MYRISCVXGPRReg<30, "x30", ["t5"]>,   DwarfRegNum<[30]>;
    T6, // MYRISCVXGPRReg<31, "x31", ["t6"]>,   DwarfRegNum<[31]>;
}

pub trait TargetRegisterTrait: Copy + Clone {
    fn as_phys_reg(&self) -> PhysReg;
    fn sub_reg(&self) -> Option<PhysReg>;
    fn super_reg(&self) -> Option<PhysReg>;
    fn regs_sharing_same_register_file(&self) -> PhysRegSet;
}

impl TargetRegisterTrait for PhysReg {
    fn as_phys_reg(&self) -> PhysReg {
        *self
    }

    fn sub_reg(&self) -> Option<PhysReg> {
        let r = self.as_phys_reg().retrieve();
        let subs: [Option<PhysReg>; PHYS_REGISTERS_NUM] = [
            GPR::ZERO.sub_reg(),
            GPR::RA.sub_reg(),
            GPR::SP.sub_reg(),
            GPR::GP.sub_reg(),
            GPR::TP.sub_reg(),
            GPR::T0.sub_reg(),
            GPR::T1.sub_reg(),
            GPR::T2.sub_reg(),
            GPR::S0.sub_reg(),
            GPR::S1.sub_reg(),
            GPR::A0.sub_reg(),
            GPR::A1.sub_reg(),
            GPR::A2.sub_reg(),
            GPR::A3.sub_reg(),
            GPR::A4.sub_reg(),
            GPR::A5.sub_reg(),
            GPR::A6.sub_reg(),
            GPR::A7.sub_reg(),
            GPR::S2.sub_reg(),
            GPR::S3.sub_reg(),
            GPR::S4.sub_reg(),
            GPR::S5.sub_reg(),
            GPR::S6.sub_reg(),
            GPR::S7.sub_reg(),
            GPR::S8.sub_reg(),
            GPR::S9.sub_reg(),
            GPR::S10.sub_reg(),
            GPR::S11.sub_reg(),
            GPR::T3.sub_reg(),
            GPR::T4.sub_reg(),
            GPR::T5.sub_reg(),
            GPR::T6.sub_reg(),
        ];
        subs[r]
    }

    fn super_reg(&self) -> Option<PhysReg> {
        let r = self.as_phys_reg().retrieve();
        let supers: [Option<PhysReg>; PHYS_REGISTERS_NUM] = [
            GPR::ZERO.super_reg(),
            GPR::RA.super_reg(),
            GPR::SP.super_reg(),
            GPR::GP.super_reg(),
            GPR::TP.super_reg(),
            GPR::T0.super_reg(),
            GPR::T1.super_reg(),
            GPR::T2.super_reg(),
            GPR::S0.super_reg(),
            GPR::S1.super_reg(),
            GPR::A0.super_reg(),
            GPR::A1.super_reg(),
            GPR::A2.super_reg(),
            GPR::A3.super_reg(),
            GPR::A4.super_reg(),
            GPR::A5.super_reg(),
            GPR::A6.super_reg(),
            GPR::A7.super_reg(),
            GPR::S2.super_reg(),
            GPR::S3.super_reg(),
            GPR::S4.super_reg(),
            GPR::S5.super_reg(),
            GPR::S6.super_reg(),
            GPR::S7.super_reg(),
            GPR::S8.super_reg(),
            GPR::S9.super_reg(),
            GPR::S10.super_reg(),
            GPR::S11.super_reg(),
            GPR::T3.super_reg(),
            GPR::T4.super_reg(),
            GPR::T5.super_reg(),
            GPR::T6.super_reg(),
        ];
        supers[r]
    }

    fn regs_sharing_same_register_file(&self) -> PhysRegSet {
        if let Some(set) = REG_FILE.with(|f| f.borrow().get(self).map(|s| s.clone())) {
            return set;
        }
        let mut set = PhysRegSet::new();
        let mut cur = *self;
        set.set(*self);
        while let Some(r) = cur.sub_reg() {
            set.set(r);
            cur = r;
        }
        while let Some(r) = cur.super_reg() {
            set.set(r);
            cur = r;
        }
        REG_FILE.with(|f| f.borrow_mut().insert(*self, set.clone()));
        set
    }
}

// register nubmering: https://corsix.github.io/dynasm-doc/instructions.html#registers

impl TargetRegisterTrait for GPR {
    fn as_phys_reg(&self) -> PhysReg {
        PhysReg(*self as usize + RegisterClassKind::GPR as usize)
    }

    fn sub_reg(&self) -> Option<PhysReg> {
        None
    }

    fn super_reg(&self) -> Option<PhysReg> {
        None
    }

    fn regs_sharing_same_register_file(&self) -> PhysRegSet {
        self.as_phys_reg().regs_sharing_same_register_file()
    }
}

thread_local! {
    pub static CALLEE_SAVED_REGS: PhysRegSet = {
        let mut bits = PhysRegSet::new();
        let regs = to_phys![
            GPR::SP,
            GPR::S0,
            GPR::S1,
            GPR::S2,
            GPR::S3,
            GPR::S4,
            GPR::S5,
            GPR::S6,
            GPR::S7,
            GPR::S8,
            GPR::S9,
            GPR::S10,
            GPR::S11
        ];
        for reg in regs {
            bits.set(reg)
        }
        bits
    };

    pub static REG_FILE: RefCell<FxHashMap<PhysReg, PhysRegSet>> = {
        RefCell::new(FxHashMap::default())
    }
}

#[derive(Debug, Clone)]
pub struct PhysRegSet(pub [u64; 1]); // 8*8*1 > PHYS_REGISTERS_NUM

impl PhysRegSet {
    pub fn new() -> Self {
        Self([0; 1])
    }

    pub fn set<T: TargetRegisterTrait>(&mut self, r: T) {
        self.0[0] |= 1 << r.as_phys_reg().retrieve();
    }

    pub fn has<T: TargetRegisterTrait>(&self, r: T) -> bool {
        (self.0[0] & (1 << r.as_phys_reg().retrieve())) != 0
    }

    pub fn to_phys_set(&self) -> FxHashSet<PhysReg> {
        let mut set = FxHashSet::default();
        for i in 0..PHYS_REGISTERS_NUM {
            if (self.0[0] & (1 << i)) != 0 {
                set.insert(PhysReg(i));
            }
        }
        set
    }

    pub fn unite(&mut self, rhs: &Self) {
        self.0[0] |= rhs.0[0];
    }
}

impl BitOr for PhysRegSet {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self {
        Self([self.0[0] & rhs.0[0]])
    }
}

impl BitAnd for PhysRegSet {
    type Output = Self;

    fn bitand(self, rhs: Self) -> Self {
        Self([self.0[0] & rhs.0[0]])
    }
}

#[derive(Debug, Clone)]
pub struct RegisterOrder {
    order: Vec<PhysReg>,
    nth: usize,
    reg_class: RegisterClassKind,
}

impl RegisterOrder {
    pub fn general_purpose(reg_class: RegisterClassKind) -> Self {
        Self {
            reg_class,
            order: reg_class.get_gp_reg_order_vec(),
            nth: 0,
        }
    }

    pub fn arguments(reg_class: RegisterClassKind) -> Self {
        Self {
            reg_class,
            order: reg_class.get_arg_reg_order_vec(),
            nth: 0,
        }
    }

    pub fn add_preferred_reg(&mut self, r: PhysReg) {
        self.order.insert(0, r);
    }
}

impl Iterator for RegisterOrder {
    type Item = PhysReg;

    fn next(&mut self) -> Option<Self::Item> {
        self.nth += 1;
        self.order.get(self.nth - 1).and_then(|item| Some(*item))
    }
}

impl VirtRegGen {
    pub fn new() -> Self {
        Self {
            id: Rc::new(RefCell::new(0)),
        }
    }

    // pub fn gen_vreg(&self, rc: RegisterClassKind) -> RegisterBase {
    //     let mut reg = RegisterBase::new(rc);
    //     reg.set_vreg(VirtReg(self.next_id()));
    //     reg
    // }

    fn next_id(&self) -> usize {
        let mut id = self.id.borrow_mut();
        *id += 1;
        *id
    }

    pub fn next_vreg(&self) -> VirtReg {
        VirtReg(self.next_id())
    }
}

impl PhysReg {
    pub fn retrieve(&self) -> usize {
        self.0
    }

    pub fn name(&self) -> &str {
        let reg_names = [
            "zero", "ra", "sp", "gp", "tp", "t0", "t1", "t2", "s0", "s1", "a0", "a1", "a2", "a3",
            "a4", "a5", "a6", "a7", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11",
            "t3", "t4", "t5", "t6",
        ];
        reg_names[self.retrieve()]
    }
}

impl VirtReg {
    pub fn retrieve(&self) -> usize {
        self.0
    }
}

impl RegisterId {
    pub fn is_virt_reg(&self) -> bool {
        matches!(self.kind, VirtOrPhys::Virt(_))
    }

    pub fn is_phys_reg(&self) -> bool {
        matches!(self.kind, VirtOrPhys::Phys(_))
    }

    pub fn as_phys_reg(&self) -> PhysReg {
        match self.kind {
            VirtOrPhys::Phys(p) => p,
            VirtOrPhys::Virt(_) => panic!(),
        }
    }

    pub fn as_virt_reg(&self) -> VirtReg {
        match self.kind {
            VirtOrPhys::Virt(v) => v,
            VirtOrPhys::Phys(_) => panic!(),
        }
    }
}

impl RegisterInfo {
    pub fn new_phys_reg<T: TargetRegisterTrait>(r: T) -> Self {
        RegisterInfo {
            virt_reg: VirtReg(0),
            phys_reg: Some(r.as_phys_reg()),
            reg_class: r.as_phys_reg().reg_class(),
            tied: None,
            uses: FxHashSet::default(),
            defs: FxHashSet::default(),
        }
    }

    pub fn add_def(&mut self, id: MachineInstId) {
        self.defs.insert(id);
    }

    pub fn remove_def(&mut self, id: MachineInstId) {
        self.defs.remove(&id);
    }

    pub fn add_use(&mut self, id: MachineInstId) {
        self.uses.insert(id);
    }

    pub fn remove_use(&mut self, id: MachineInstId) {
        self.uses.remove(&id);
    }
}

impl RegistersInfo {
    pub fn new() -> Self {
        let mut arena = Arena::new();
        let mut phys_regs_list = vec![];

        fn f<T: TargetRegisterTrait>(arena: &mut Arena<RegisterInfo>, r: T) -> RegisterId {
            let id = arena.alloc(RegisterInfo::new_phys_reg(r));
            RegisterId {
                id,
                kind: VirtOrPhys::Phys(r.as_phys_reg()),
            }
        }
        phys_regs_list.push(f(&mut arena, GPR::ZERO));
        phys_regs_list.push(f(&mut arena, GPR::RA));
        phys_regs_list.push(f(&mut arena, GPR::SP));
        phys_regs_list.push(f(&mut arena, GPR::GP));
        phys_regs_list.push(f(&mut arena, GPR::TP));
        phys_regs_list.push(f(&mut arena, GPR::T0));
        phys_regs_list.push(f(&mut arena, GPR::T1));
        phys_regs_list.push(f(&mut arena, GPR::T2));
        phys_regs_list.push(f(&mut arena, GPR::S0));
        phys_regs_list.push(f(&mut arena, GPR::S1));
        phys_regs_list.push(f(&mut arena, GPR::A0));
        phys_regs_list.push(f(&mut arena, GPR::A1));
        phys_regs_list.push(f(&mut arena, GPR::A2));
        phys_regs_list.push(f(&mut arena, GPR::A3));
        phys_regs_list.push(f(&mut arena, GPR::A4));
        phys_regs_list.push(f(&mut arena, GPR::A5));
        phys_regs_list.push(f(&mut arena, GPR::A6));
        phys_regs_list.push(f(&mut arena, GPR::A7));
        phys_regs_list.push(f(&mut arena, GPR::S2));
        phys_regs_list.push(f(&mut arena, GPR::S3));
        phys_regs_list.push(f(&mut arena, GPR::S4));
        phys_regs_list.push(f(&mut arena, GPR::S5));
        phys_regs_list.push(f(&mut arena, GPR::S6));
        phys_regs_list.push(f(&mut arena, GPR::S7));
        phys_regs_list.push(f(&mut arena, GPR::S8));
        phys_regs_list.push(f(&mut arena, GPR::S9));
        phys_regs_list.push(f(&mut arena, GPR::S10));
        phys_regs_list.push(f(&mut arena, GPR::S11));
        phys_regs_list.push(f(&mut arena, GPR::T3));
        phys_regs_list.push(f(&mut arena, GPR::T4));
        phys_regs_list.push(f(&mut arena, GPR::T5));
        phys_regs_list.push(f(&mut arena, GPR::T6));

        Self {
            arena: RefCell::new(RegisterArena(arena)),
            cur_virt_reg: RefCell::new(0),
            phys_regs_list,
        }
    }

    pub fn new_virt_reg(&self, reg_class: RegisterClassKind) -> RegisterId {
        let virt_reg = self.gen_virt_reg();
        let id = self.arena.borrow_mut().0.alloc(RegisterInfo {
            virt_reg,
            phys_reg: None,
            reg_class,
            tied: None,
            uses: FxHashSet::default(),
            defs: FxHashSet::default(),
        });
        RegisterId {
            id,
            kind: VirtOrPhys::Virt(virt_reg),
        }
    }

    pub fn get_phys_reg<T: TargetRegisterTrait>(&self, r: T) -> RegisterId {
        let i = r.as_phys_reg().retrieve();
        self.phys_regs_list[i]
    }

    pub fn arena_ref_mut(&self) -> RefMut<RegisterArena> {
        self.arena.borrow_mut()
    }

    pub fn arena_ref(&self) -> Ref<RegisterArena> {
        self.arena.borrow()
    }

    fn gen_virt_reg(&self) -> VirtReg {
        let n = *self.cur_virt_reg.borrow();
        *self.cur_virt_reg.borrow_mut() += 1;
        VirtReg(n)
    }
}

impl Index<RegisterId> for RegisterArena {
    type Output = RegisterInfo;

    fn index(&self, id: RegisterId) -> &Self::Output {
        &self.0[id.id]
    }
}

impl IndexMut<RegisterId> for RegisterArena {
    fn index_mut(&mut self, id: RegisterId) -> &mut Self::Output {
        &mut self.0[id.id]
    }
}

pub fn str2reg(s: &str) -> Option<PhysReg> {
    Some(match s.to_ascii_lowercase().as_str() {
        "zero" => GPR::ZERO.as_phys_reg(),
        "ra" => GPR::RA.as_phys_reg(),
        "sp" => GPR::SP.as_phys_reg(),
        "gp" => GPR::GP.as_phys_reg(),
        "tp" => GPR::TP.as_phys_reg(),
        "t0" => GPR::T0.as_phys_reg(),
        "t1" => GPR::T1.as_phys_reg(),
        "t2" => GPR::T2.as_phys_reg(),
        "s0" => GPR::S0.as_phys_reg(),
        "s1" => GPR::S1.as_phys_reg(),
        "a0" => GPR::A0.as_phys_reg(),
        "a1" => GPR::A1.as_phys_reg(),
        "a2" => GPR::A2.as_phys_reg(),
        "a3" => GPR::A3.as_phys_reg(),
        "a4" => GPR::A4.as_phys_reg(),
        "a5" => GPR::A5.as_phys_reg(),
        "a6" => GPR::A6.as_phys_reg(),
        "a7" => GPR::A7.as_phys_reg(),
        "s2" => GPR::S2.as_phys_reg(),
        "s3" => GPR::S3.as_phys_reg(),
        "s4" => GPR::S4.as_phys_reg(),
        "s5" => GPR::S5.as_phys_reg(),
        "s6" => GPR::S6.as_phys_reg(),
        "s7" => GPR::S7.as_phys_reg(),
        "s8" => GPR::S8.as_phys_reg(),
        "s9" => GPR::S9.as_phys_reg(),
        "s10" => GPR::S10.as_phys_reg(),
        "s11" => GPR::S11.as_phys_reg(),
        "t3" => GPR::T3.as_phys_reg(),
        "t4" => GPR::T4.as_phys_reg(),
        "t5" => GPR::T5.as_phys_reg(),
        "t6" => GPR::T6.as_phys_reg(),
        _ => return None,
    })
}

impl fmt::Debug for PhysReg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "%{}", self.name())
    }
}

impl fmt::Debug for VirtReg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "%vreg{}", self.retrieve())
    }
}

impl fmt::Debug for VirtOrPhys {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Phys(p) => p.fmt(f),
            Self::Virt(v) => v.fmt(f),
        }
    }
}

impl fmt::Debug for RegisterId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.kind {
            VirtOrPhys::Phys(p) => p.fmt(f)?,
            VirtOrPhys::Virt(v) => v.fmt(f)?,
        }
        write!(f, ":{}", self.id.index())
    }
}
