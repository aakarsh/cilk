use super::machine::instr::*;
use crate::ir::types::*;
use std::fmt;
use std::{cell::RefCell, rc::Rc};

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct PhysReg(pub usize);

#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct VirtReg(pub usize);

#[derive(Debug, Clone)]
pub struct VirtRegGen {
    id: Rc<RefCell<usize>>,
}

#[derive(Debug, Clone, Copy, Hash, PartialEq)]
pub enum RegisterClassKind {
    GR32,
    GR64,
}

#[derive(Debug, Clone)]
pub struct RegisterOrder {
    order: Vec<PhysReg>,
    nth: usize,
    reg_class: RegisterClassKind,
}

impl RegisterClassKind {
    pub fn get_reg_order(&self) -> RegisterOrder {
        RegisterOrder::new(*self)
    }

    // Returns normal order of general-purpose registers
    pub fn get_general_reg_order_vec(&self) -> Vec<PhysReg> {
        match self {
            RegisterClassKind::GR32 => vec![
                GR32::EAX,
                GR32::ECX,
                GR32::EDX,
                GR32::ESI,
                GR32::EDI,
                GR32::R8D,
                GR32::R9D,
                GR32::R10D,
                GR32::R11D,
                GR32::R12D,
                GR32::R13D,
                GR32::R14D,
                GR32::R15D,
            ]
            .iter()
            .map(|r| r.as_phys_reg())
            .collect(),
            RegisterClassKind::GR64 => vec![
                GR64::RAX,
                GR64::RCX,
                GR64::RDX,
                GR64::RSI,
                GR64::RDI,
                GR64::R8,
                GR64::R9,
                GR64::R10,
                GR64::R11,
                GR64::R12,
                GR64::R13,
                GR64::R14,
                GR64::R15,
            ]
            .iter()
            .map(|r| r.as_phys_reg())
            .collect(),
        }
    }
}

impl RegisterOrder {
    pub fn new(reg_class: RegisterClassKind) -> Self {
        Self {
            reg_class,
            order: reg_class.get_general_reg_order_vec(),
            nth: 0,
        }
    }
}

impl Iterator for RegisterOrder {
    type Item = PhysReg;

    fn next(&mut self) -> Option<Self::Item> {
        self.nth += 1;
        self.order.get(self.nth - 1).and_then(|item| Some(*item))
    }
}

// START: x64 dependent code
// TODO: THIS CODE WILL BE AUTO-GENERATED BY MACRO IN THE FUTURE

#[derive(Debug, Clone, Copy, Hash, PartialEq)]
pub enum GR32 {
    EAX,
    EBX,
    ECX,
    EDX,
    ESI,
    EDI,
    EBP,
    ESP,
    R8D,
    R9D,
    R10D,
    R11D,
    R12D,
    R13D,
    R14D,
    R15D,
}

#[derive(Debug, Clone, Copy, Hash, PartialEq)]
pub enum GR64 {
    RAX,
    RBX,
    RCX,
    RDX,
    RDI,
    RSI,
    RBP,
    RSP,
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15,
}

// const GR64_PHYS_SPACING: usize = 8;

pub trait X64RegisterTrait {
    fn as_phys_reg(&self) -> PhysReg;
}

impl X64RegisterTrait for GR32 {
    fn as_phys_reg(&self) -> PhysReg {
        let n = match self {
            GR32::EAX => 0,
            GR32::ECX => 1,
            GR32::EDX => 2,
            GR32::EBX => 3,
            GR32::ESP => 4,
            GR32::EBP => 5,
            GR32::ESI => 6,
            GR32::EDI => 7,
            GR32::R8D => 8,
            GR32::R9D => 9,
            GR32::R10D => 10,
            GR32::R11D => 11,
            GR32::R12D => 12,
            GR32::R13D => 13,
            GR32::R14D => 14,
            GR32::R15D => 15,
        };
        PhysReg(n)
    }
}

impl X64RegisterTrait for GR64 {
    fn as_phys_reg(&self) -> PhysReg {
        let n = match self {
            GR64::RAX => 0,
            GR64::RCX => 1,
            GR64::RDX => 2,
            GR64::RBX => 3,
            GR64::RSP => 4,
            GR64::RBP => 5,
            GR64::RSI => 6,
            GR64::RDI => 7,
            GR64::R8 => 8,
            GR64::R9 => 9,
            GR64::R10 => 10,
            GR64::R11 => 11,
            GR64::R12 => 12,
            GR64::R13 => 13,
            GR64::R14 => 14,
            GR64::R15 => 15,
        };
        PhysReg(n /*+ GR64_PHYS_SPACING*/)
    }
}

// END: x64 dependent code

impl VirtRegGen {
    pub fn new() -> Self {
        Self {
            id: Rc::new(RefCell::new(0)),
        }
    }

    pub fn gen_vreg(&self, ty: Type) -> RegisterInfo {
        let mut reg = RegisterInfo::new(ty);
        reg.set_vreg(VirtReg(self.next_id()));
        reg
    }

    fn next_id(&self) -> usize {
        let mut id = self.id.borrow_mut();
        *id += 1;
        *id
    }

    pub fn next_vreg(&self) -> VirtReg {
        VirtReg(self.next_id())
    }
}

// register nubmering: https://corsix.github.io/dynasm-doc/instructions.html#registers

pub fn get_general_reg(n: usize) -> Option<PhysReg> {
    match n {
        0 => Some(PhysReg(0)),
        1 => Some(PhysReg(1)),
        2 => Some(PhysReg(2)),
        3 => Some(PhysReg(6)),
        4 => Some(PhysReg(7)),
        5 => Some(PhysReg(8)),
        6 => Some(PhysReg(9)),
        7 => Some(PhysReg(10)),
        8 => Some(PhysReg(11)),
        _ => None,
    }
}

pub fn get_arg_reg(n: usize) -> Option<PhysReg> {
    let regs = [7, 6, 2, 1, 8, 9]; // rdi, rsi, rdx, rcx, r8, r9
    regs.get(n).map(|x| PhysReg(*x))
}

impl PhysReg {
    pub fn get(&self) -> usize {
        self.0
    }
}

impl VirtReg {
    pub fn get(&self) -> usize {
        self.0
    }
}

impl fmt::Debug for PhysReg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let reg_names = [
            "RAX", "RCX", "RDX", "RBX", "RSP", "RBP", "RSI", "RDI", "R8", "R9", "R10", "R11",
            "R12", "R13", "R14", "R15",
        ];
        write!(f, "%{}", reg_names[self.0])
        // write!(f, "%R{}", self.0)
    }
}

impl fmt::Debug for VirtReg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "%vreg{}", self.0)
    }
}
