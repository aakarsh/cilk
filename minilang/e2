input:

struct Vec {
  x: f64,
  y: f64,
  z: f64
}

struct Isect {
  hit: i32,
  hit_point: * struct Vec,
  normal: * struct Vec,
  color: * struct Vec,
  distance: f64,
  ray_dir: * struct Vec
}

struct Ray {
  origin: * struct Vec,
  dir: * struct Vec
}

struct Sphere {
  radius: f64,
  position: * struct Vec,
  color: * struct Vec
}

struct Plane {
  position: * struct Vec,
  normal  : * struct Vec,
  color   : * struct Vec
}

struct Env {
  light     : *struct Vec,
  sphere1: *struct Sphere,
  sphere2: *struct Sphere,
  sphere3: *struct Sphere,
  plane   : *struct Plane
}

function clamp(t: f64, min: f64, max: f64): f64 {
  if t < min { return min; }
  if max < t { return max; }
  return t;
}

function Vec_new(x: f64, y: f64, z: f64): *struct Vec {
  var vec: * struct Vec;
  vec = malloc(128);
  (*vec).x = x;
  (*vec).y = y;
  (*vec).z = z;
  return vec;
}

function Vec_add(a: *struct Vec, b: *struct Vec): *struct Vec {
  return Vec_new((*a).x + (*b).x, (*a).y + (*b).y, (*a).z + (*b).z);
}

function Vec_sub(a: *struct Vec, b: *struct Vec): *struct Vec {
  return Vec_new((*a).x - (*b).x, (*a).y - (*b).y, (*a).z - (*b).z);
}

function Vec_mul(a: *struct Vec, t: f64): *struct Vec {
  return Vec_new((*a).x * t, (*a).y * t, (*a).z * t);
}

function Vec_multi(a: *struct Vec, b: *struct Vec): *struct Vec {
  return Vec_new((*a).x + (*b).x, (*a).y + (*b).y, (*a).z + (*b).z);
}

function Vec_dot(a: *struct Vec, b: *struct Vec): f64 {
  println_f64((*a).x);
  return (*a).x * (*b).x + (*a).y * (*b).y + (*a).z * (*b).z;
}

function Vec_reflect(self: *struct Vec, normal: *struct Vec): *struct Vec {
  return Vec_add(self, Vec_mul(normal, (0.0-2.0)*Vec_dot(normal, self)));
}

function Vec_length(v: *struct Vec): f64 {
  return sqrt((*v).x*(*v).x + (*v).y*(*v).y + (*v).z*(*v).z);
}

function Vec_normalize(v: *struct Vec): *struct Vec {
  var len: f64;
  var r_len: f64;
  len = Vec_length(v);
  if 0.00000001 < len {
    r_len = 1.0 / len;
    (*v).x = (*v).x * r_len;
    (*v).y = (*v).y * r_len;
    (*v).z = (*v).z * r_len;
  }
  return v;
}

function Ray_new(origin: *struct Vec, dir: *struct Vec): *struct Ray {
  var ray: *struct Ray;
  ray = malloc(128);
  (*ray).origin = origin;
  (*ray).dir = dir;
  return ray;
}

function Isect_new(
  hit: i32,
  hit_point: *struct Vec,
  normal: *struct Vec,
  color: *struct Vec,
  distance: f64,
  ray_dir: *struct Vec): *struct Isect {
  var i: *struct Isect;
  i = malloc(128);
  (*i).hit       = hit      ;
  (*i).hit_point = hit_point;
  (*i).normal    = normal   ;
  (*i).color     = color    ;
  (*i).distance  = distance ;
  (*i).ray_dir   = ray_dir ;
  return i;
}

function Sphere_new(radius: f64, position: *struct Vec, color: *struct Vec): *struct Sphere {
  var s: *struct Sphere;
  s = malloc(128);
  (*s).radius   = radius;
  (*s).position = position;
  (*s).color    = color;
  return s;
}

function Sphere_intersect(s: *struct Sphere, light: *struct Vec, ray: *struct Ray, isect: *struct Isect): i32 {
  var rs: *struct Vec;
  var b: f64; var c: f64; var d: f64; var t: f64;
  rs = Vec_sub((*ray).origin, (*s).position);
  b = Vec_dot(rs, (*ray).dir);
  c = Vec_dot(rs, rs) - (*s).radius * (*s).radius;
  d = b * b - c;
  t = 0.0 - b - sqrt(d);
  if d <= 0.0 { return 0; }
  if t <= 0.0001 { return 0; }
  if (*isect).distance <= t { return 0; }
  (*isect).hit_point = Vec_add((*ray).origin, Vec_mul((*ray).dir, t));
  (*isect).normal = Vec_normalize(Vec_sub((*isect).hit_point, (*s).position));
  (*isect).color = Vec_mul((*s).color, clamp(Vec_dot(light, (*isect).normal), 0.1, 1.0));
  (*isect).distance = t;
  (*isect).hit = (*isect).hit + 1;
  (*isect).ray_dir = (*ray).dir;
  return 0;
}

function Plane_new(position: *struct Vec, normal: *struct Vec, color: *struct Vec): *struct Plane {
  var p: *struct Plane;
  p = malloc(128);
  (*p).position = position;
  (*p).normal = normal;
  (*p).color = color;
  return p;
}

function Plane_intersect(p: *struct Plane, light: *struct Vec, ray: *struct Ray, isect: *struct Isect): i32 {
  var d: f64;
  var v: f64;
  var t: f64;
  var d2: f64;
  var m: f64;
  var n: f64;
  var d3: f64;
  var abs_: f64;
  var f: f64;
  d = 0.0 - Vec_dot((*p).position, (*p).normal);
  v = Vec_dot((*ray).dir, (*p).normal);
  t = 0.0 - ((Vec_dot((*ray).origin, (*p).normal) + d) / v);
  if t <= 0.0001 { return 0; }
  if (*isect).distance <= t { return 0; }
  (*isect).hit_point = Vec_add((*ray).origin, Vec_mul((*ray).dir, t));
  (*isect).normal = (*p).normal;
  d2 = clamp(Vec_dot(light, (*isect).normal), 0.1, 1.0);
  m = (*(*isect).hit_point).x - 2.0*floor((*(*isect).hit_point).x/2.0);
  n = (*(*isect).hit_point).z - 2.0*floor((*(*isect).hit_point).z/2.0);
  d3 = d2;
  if 1.0 < m { if 1.0 < n { d3 = d3 * 0.5; } }
  else { if m < 1.0 { if n < 1.0 { d3 = d3 * 0.5; } } }
  abs_ = fabs((*(*isect).hit_point).z);
  f = 0.0;
  if abs_ < 25.0 { f = 1.0 - abs_*0.04; }
  (*isect).color = Vec_mul((*p).color, d3 * f);
  (*isect).distance = t;
  (*isect).hit = (*isect).hit + 1;
  (*isect).ray_dir = (*ray).dir;
  return 0;
}

function Env_intersect(env: *struct Env, ray: *struct Ray, i: *struct Isect): i32 {
  Sphere_intersect((*env).sphere1, (*env).light, ray, i);
  Sphere_intersect((*env).sphere2, (*env).light, ray, i);
  Sphere_intersect((*env).sphere3, (*env).light, ray, i);
  Plane_intersect ((*env).plane,   (*env).light, ray, i);
  return 0;
}

function Env_new(): *struct Env {
  var env: *struct Env;
  env = malloc(128);
  (*env).light = Vec_new(0.577, 0.577, 0.577);
  (*env).sphere1 = Sphere_new(0.5, Vec_new( 0.0, 0.0-0.5, sin(0.0)), Vec_new(1.0, 0.0, 0.0));
  (*env).sphere2 = Sphere_new(1.0, Vec_new( 2.0,  0.0, cos(10.0 * 0.666)), Vec_new(0.0, 1.0, 0.0));
  (*env).sphere3 = Sphere_new(1.5, Vec_new(0.0-2.0,  0.5, cos(10.0 * 0.333)), Vec_new(0.0, 0.0, 1.0));
  (*env).plane = Plane_new(Vec_new(0.0, 0.0-1.0, 0.0), Vec_new(0.0, 1.0, 0.0), Vec_new(1.0, 1.0, 1.0));
  return env;
}

function color_of(t: f64): i32 {
  var ret: i32;
  ret = f64_to_i32((i32_to_f64(256) * clamp(t, 0.0, 1.0)));
  if ret == 256 { return 256 - 1; }
  return ret;
}

function print_col(c: *struct Vec): i32 {
  return 0;
}

function main(): i32 {
  var env: *struct Env;
  var row: i32; var col: i32;
  var x: f64; var y: f64;
  var ray: *struct Ray;
  var i: *struct Isect;
  var dest_col: *struct Vec;
  var temp_col: *struct Vec;
  var j: i32;
  var q: *struct Ray;

  env = Env_new();

  row = 0; while row < 12 {
    col = 0; while col < 12 {
      x = i32_to_f64(col) / 12.0 / 20.0 - 1.0;
      y = i32_to_f64(12 - row) / 12.0 / 2.0 - 1.0;

      ray = Ray_new( Vec_new(0.0, 2.0, 6.0), Vec_normalize(Vec_new(x, y, 0.0 - 1.0)) );
      i = Isect_new(0, Vec_new(0.0, 0.0, 0.0), Vec_new(0.0, 0.0, 0.0), Vec_new(0.0, 0.0, 0.0),
                    10000000.0, Vec_new(0.0, 0.0, 0.0));
      Env_intersect(env, ray, i);

      if 0 < (*i).hit {
        dest_col = (*i).color;
        temp_col = Vec_multi(Vec_new(1.0, 1.0, 1.0), (*i).color);
        j = 1; while j < 4 {
          q = Ray_new(Vec_add((*i).hit_point, Vec_mul((*i).normal, 0.0001)),
                                  Vec_reflect((*i).ray_dir, (*i).normal));
          Env_intersect(env, q, i);
          if j < (*i).hit {
            dest_col = Vec_add(dest_col, Vec_multi(temp_col, (*i).color));
            temp_col = Vec_multi(temp_col, (*i).color); 
          }

          j = j + 1;
        }
        print_col(dest_col);
      } else {
        print_col(Vec_new((*(*ray).dir).y, (*(*ray).dir).y, (*(*ray).dir).y));
      }
      col = col + 1;
    }
    row = row + 1;
  }

  return 0;
}
                
Parsed: Module { functions: [Function { name: "clamp", params: [("t", F64), ("min", F64), ("max", F64)], ret_ty: F64, body: [IfElse(Lt(Load(Identifier("t")), Load(Identifier("min"))), [Return(Load(Identifier("min")))], None), IfElse(Lt(Load(Identifier("max")), Load(Identifier("t"))), [Return(Load(Identifier("max")))], None), Return(Load(Identifier("t")))] }, Function { name: "Vec_new", params: [("x", F64), ("y", F64), ("z", F64)], ret_ty: Pointer(Struct("Vec")), body: [VarDecl("vec", Pointer(Struct("Vec"))), Assign(Identifier("vec"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("vec")), Identifier("x")), Load(Identifier("x"))), Assign(Dot(Load(Identifier("vec")), Identifier("y")), Load(Identifier("y"))), Assign(Dot(Load(Identifier("vec")), Identifier("z")), Load(Identifier("z"))), Return(Load(Identifier("vec")))] }, Function { name: "Vec_add", params: [("a", Pointer(Struct("Vec"))), ("b", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Vec")), body: [Return(Call("Vec_new", [Add(Load(Dot(Load(Identifier("a")), Identifier("x"))), Load(Dot(Load(Identifier("b")), Identifier("x")))), Add(Load(Dot(Load(Identifier("a")), Identifier("y"))), Load(Dot(Load(Identifier("b")), Identifier("y")))), Add(Load(Dot(Load(Identifier("a")), Identifier("z"))), Load(Dot(Load(Identifier("b")), Identifier("z"))))]))] }, Function { name: "Vec_sub", params: [("a", Pointer(Struct("Vec"))), ("b", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Vec")), body: [Return(Call("Vec_new", [Sub(Load(Dot(Load(Identifier("a")), Identifier("x"))), Load(Dot(Load(Identifier("b")), Identifier("x")))), Sub(Load(Dot(Load(Identifier("a")), Identifier("y"))), Load(Dot(Load(Identifier("b")), Identifier("y")))), Sub(Load(Dot(Load(Identifier("a")), Identifier("z"))), Load(Dot(Load(Identifier("b")), Identifier("z"))))]))] }, Function { name: "Vec_mul", params: [("a", Pointer(Struct("Vec"))), ("t", F64)], ret_ty: Pointer(Struct("Vec")), body: [Return(Call("Vec_new", [Mul(Load(Dot(Load(Identifier("a")), Identifier("x"))), Load(Identifier("t"))), Mul(Load(Dot(Load(Identifier("a")), Identifier("y"))), Load(Identifier("t"))), Mul(Load(Dot(Load(Identifier("a")), Identifier("z"))), Load(Identifier("t")))]))] }, Function { name: "Vec_multi", params: [("a", Pointer(Struct("Vec"))), ("b", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Vec")), body: [Return(Call("Vec_new", [Add(Load(Dot(Load(Identifier("a")), Identifier("x"))), Load(Dot(Load(Identifier("b")), Identifier("x")))), Add(Load(Dot(Load(Identifier("a")), Identifier("y"))), Load(Dot(Load(Identifier("b")), Identifier("y")))), Add(Load(Dot(Load(Identifier("a")), Identifier("z"))), Load(Dot(Load(Identifier("b")), Identifier("z"))))]))] }, Function { name: "Vec_dot", params: [("a", Pointer(Struct("Vec"))), ("b", Pointer(Struct("Vec")))], ret_ty: F64, body: [Call("println_f64", [Load(Dot(Load(Identifier("a")), Identifier("x")))]), Return(Add(Add(Mul(Load(Dot(Load(Identifier("a")), Identifier("x"))), Load(Dot(Load(Identifier("b")), Identifier("x")))), Mul(Load(Dot(Load(Identifier("a")), Identifier("y"))), Load(Dot(Load(Identifier("b")), Identifier("y"))))), Mul(Load(Dot(Load(Identifier("a")), Identifier("z"))), Load(Dot(Load(Identifier("b")), Identifier("z"))))))] }, Function { name: "Vec_reflect", params: [("self", Pointer(Struct("Vec"))), ("normal", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Vec")), body: [Return(Call("Vec_add", [Load(Identifier("self")), Call("Vec_mul", [Load(Identifier("normal")), Mul(Sub(FPNumber(0.0), FPNumber(2.0)), Call("Vec_dot", [Load(Identifier("normal")), Load(Identifier("self"))]))])]))] }, Function { name: "Vec_length", params: [("v", Pointer(Struct("Vec")))], ret_ty: F64, body: [Return(Call("sqrt", [Add(Add(Mul(Load(Dot(Load(Identifier("v")), Identifier("x"))), Load(Dot(Load(Identifier("v")), Identifier("x")))), Mul(Load(Dot(Load(Identifier("v")), Identifier("y"))), Load(Dot(Load(Identifier("v")), Identifier("y"))))), Mul(Load(Dot(Load(Identifier("v")), Identifier("z"))), Load(Dot(Load(Identifier("v")), Identifier("z")))))]))] }, Function { name: "Vec_normalize", params: [("v", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Vec")), body: [VarDecl("len", F64), VarDecl("r_len", F64), Assign(Identifier("len"), Call("Vec_length", [Load(Identifier("v"))])), IfElse(Lt(FPNumber(0.00000001), Load(Identifier("len"))), [Assign(Identifier("r_len"), Div(FPNumber(1.0), Load(Identifier("len")))), Assign(Dot(Load(Identifier("v")), Identifier("x")), Mul(Load(Dot(Load(Identifier("v")), Identifier("x"))), Load(Identifier("r_len")))), Assign(Dot(Load(Identifier("v")), Identifier("y")), Mul(Load(Dot(Load(Identifier("v")), Identifier("y"))), Load(Identifier("r_len")))), Assign(Dot(Load(Identifier("v")), Identifier("z")), Mul(Load(Dot(Load(Identifier("v")), Identifier("z"))), Load(Identifier("r_len"))))], None), Return(Load(Identifier("v")))] }, Function { name: "Ray_new", params: [("origin", Pointer(Struct("Vec"))), ("dir", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Ray")), body: [VarDecl("ray", Pointer(Struct("Ray"))), Assign(Identifier("ray"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("ray")), Identifier("origin")), Load(Identifier("origin"))), Assign(Dot(Load(Identifier("ray")), Identifier("dir")), Load(Identifier("dir"))), Return(Load(Identifier("ray")))] }, Function { name: "Isect_new", params: [("hit", Int32), ("hit_point", Pointer(Struct("Vec"))), ("normal", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec"))), ("distance", F64), ("ray_dir", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Isect")), body: [VarDecl("i", Pointer(Struct("Isect"))), Assign(Identifier("i"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("i")), Identifier("hit")), Load(Identifier("hit"))), Assign(Dot(Load(Identifier("i")), Identifier("hit_point")), Load(Identifier("hit_point"))), Assign(Dot(Load(Identifier("i")), Identifier("normal")), Load(Identifier("normal"))), Assign(Dot(Load(Identifier("i")), Identifier("color")), Load(Identifier("color"))), Assign(Dot(Load(Identifier("i")), Identifier("distance")), Load(Identifier("distance"))), Assign(Dot(Load(Identifier("i")), Identifier("ray_dir")), Load(Identifier("ray_dir"))), Return(Load(Identifier("i")))] }, Function { name: "Sphere_new", params: [("radius", F64), ("position", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Sphere")), body: [VarDecl("s", Pointer(Struct("Sphere"))), Assign(Identifier("s"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("s")), Identifier("radius")), Load(Identifier("radius"))), Assign(Dot(Load(Identifier("s")), Identifier("position")), Load(Identifier("position"))), Assign(Dot(Load(Identifier("s")), Identifier("color")), Load(Identifier("color"))), Return(Load(Identifier("s")))] }, Function { name: "Sphere_intersect", params: [("s", Pointer(Struct("Sphere"))), ("light", Pointer(Struct("Vec"))), ("ray", Pointer(Struct("Ray"))), ("isect", Pointer(Struct("Isect")))], ret_ty: Int32, body: [VarDecl("rs", Pointer(Struct("Vec"))), VarDecl("b", F64), VarDecl("c", F64), VarDecl("d", F64), VarDecl("t", F64), Assign(Identifier("rs"), Call("Vec_sub", [Load(Dot(Load(Identifier("ray")), Identifier("origin"))), Load(Dot(Load(Identifier("s")), Identifier("position")))])), Assign(Identifier("b"), Call("Vec_dot", [Load(Identifier("rs")), Load(Dot(Load(Identifier("ray")), Identifier("dir")))])), Assign(Identifier("c"), Sub(Call("Vec_dot", [Load(Identifier("rs")), Load(Identifier("rs"))]), Mul(Load(Dot(Load(Identifier("s")), Identifier("radius"))), Load(Dot(Load(Identifier("s")), Identifier("radius")))))), Assign(Identifier("d"), Sub(Mul(Load(Identifier("b")), Load(Identifier("b"))), Load(Identifier("c")))), Assign(Identifier("t"), Sub(Sub(FPNumber(0.0), Load(Identifier("b"))), Call("sqrt", [Load(Identifier("d"))]))), IfElse(Le(Load(Identifier("d")), FPNumber(0.0)), [Return(Number(0))], None), IfElse(Le(Load(Identifier("t")), FPNumber(0.0001)), [Return(Number(0))], None), IfElse(Le(Load(Dot(Load(Identifier("isect")), Identifier("distance"))), Load(Identifier("t"))), [Return(Number(0))], None), Assign(Dot(Load(Identifier("isect")), Identifier("hit_point")), Call("Vec_add", [Load(Dot(Load(Identifier("ray")), Identifier("origin"))), Call("Vec_mul", [Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Load(Identifier("t"))])])), Assign(Dot(Load(Identifier("isect")), Identifier("normal")), Call("Vec_normalize", [Call("Vec_sub", [Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Load(Dot(Load(Identifier("s")), Identifier("position")))])])), Assign(Dot(Load(Identifier("isect")), Identifier("color")), Call("Vec_mul", [Load(Dot(Load(Identifier("s")), Identifier("color"))), Call("clamp", [Call("Vec_dot", [Load(Identifier("light")), Load(Dot(Load(Identifier("isect")), Identifier("normal")))]), FPNumber(0.1), FPNumber(1.0)])])), Assign(Dot(Load(Identifier("isect")), Identifier("distance")), Load(Identifier("t"))), Assign(Dot(Load(Identifier("isect")), Identifier("hit")), Add(Load(Dot(Load(Identifier("isect")), Identifier("hit"))), Number(1))), Assign(Dot(Load(Identifier("isect")), Identifier("ray_dir")), Load(Dot(Load(Identifier("ray")), Identifier("dir")))), Return(Number(0))] }, Function { name: "Plane_new", params: [("position", Pointer(Struct("Vec"))), ("normal", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec")))], ret_ty: Pointer(Struct("Plane")), body: [VarDecl("p", Pointer(Struct("Plane"))), Assign(Identifier("p"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("p")), Identifier("position")), Load(Identifier("position"))), Assign(Dot(Load(Identifier("p")), Identifier("normal")), Load(Identifier("normal"))), Assign(Dot(Load(Identifier("p")), Identifier("color")), Load(Identifier("color"))), Return(Load(Identifier("p")))] }, Function { name: "Plane_intersect", params: [("p", Pointer(Struct("Plane"))), ("light", Pointer(Struct("Vec"))), ("ray", Pointer(Struct("Ray"))), ("isect", Pointer(Struct("Isect")))], ret_ty: Int32, body: [VarDecl("d", F64), VarDecl("v", F64), VarDecl("t", F64), VarDecl("d2", F64), VarDecl("m", F64), VarDecl("n", F64), VarDecl("d3", F64), VarDecl("abs_", F64), VarDecl("f", F64), Assign(Identifier("d"), Sub(FPNumber(0.0), Call("Vec_dot", [Load(Dot(Load(Identifier("p")), Identifier("position"))), Load(Dot(Load(Identifier("p")), Identifier("normal")))]))), Assign(Identifier("v"), Call("Vec_dot", [Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Load(Dot(Load(Identifier("p")), Identifier("normal")))])), Assign(Identifier("t"), Sub(FPNumber(0.0), Div(Add(Call("Vec_dot", [Load(Dot(Load(Identifier("ray")), Identifier("origin"))), Load(Dot(Load(Identifier("p")), Identifier("normal")))]), Load(Identifier("d"))), Load(Identifier("v"))))), IfElse(Le(Load(Identifier("t")), FPNumber(0.0001)), [Return(Number(0))], None), IfElse(Le(Load(Dot(Load(Identifier("isect")), Identifier("distance"))), Load(Identifier("t"))), [Return(Number(0))], None), Assign(Dot(Load(Identifier("isect")), Identifier("hit_point")), Call("Vec_add", [Load(Dot(Load(Identifier("ray")), Identifier("origin"))), Call("Vec_mul", [Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Load(Identifier("t"))])])), Assign(Dot(Load(Identifier("isect")), Identifier("normal")), Load(Dot(Load(Identifier("p")), Identifier("normal")))), Assign(Identifier("d2"), Call("clamp", [Call("Vec_dot", [Load(Identifier("light")), Load(Dot(Load(Identifier("isect")), Identifier("normal")))]), FPNumber(0.1), FPNumber(1.0)])), Assign(Identifier("m"), Sub(Load(Dot(Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Identifier("x"))), Mul(FPNumber(2.0), Call("floor", [Div(Load(Dot(Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Identifier("x"))), FPNumber(2.0))])))), Assign(Identifier("n"), Sub(Load(Dot(Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Identifier("z"))), Mul(FPNumber(2.0), Call("floor", [Div(Load(Dot(Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Identifier("z"))), FPNumber(2.0))])))), Assign(Identifier("d3"), Load(Identifier("d2"))), IfElse(Lt(FPNumber(1.0), Load(Identifier("m"))), [IfElse(Lt(FPNumber(1.0), Load(Identifier("n"))), [Assign(Identifier("d3"), Mul(Load(Identifier("d3")), FPNumber(0.5)))], None)], Some([IfElse(Lt(Load(Identifier("m")), FPNumber(1.0)), [IfElse(Lt(Load(Identifier("n")), FPNumber(1.0)), [Assign(Identifier("d3"), Mul(Load(Identifier("d3")), FPNumber(0.5)))], None)], None)])), Assign(Identifier("abs_"), Call("fabs", [Load(Dot(Load(Dot(Load(Identifier("isect")), Identifier("hit_point"))), Identifier("z")))])), Assign(Identifier("f"), FPNumber(0.0)), IfElse(Lt(Load(Identifier("abs_")), FPNumber(25.0)), [Assign(Identifier("f"), Sub(FPNumber(1.0), Mul(Load(Identifier("abs_")), FPNumber(0.04))))], None), Assign(Dot(Load(Identifier("isect")), Identifier("color")), Call("Vec_mul", [Load(Dot(Load(Identifier("p")), Identifier("color"))), Mul(Load(Identifier("d3")), Load(Identifier("f")))])), Assign(Dot(Load(Identifier("isect")), Identifier("distance")), Load(Identifier("t"))), Assign(Dot(Load(Identifier("isect")), Identifier("hit")), Add(Load(Dot(Load(Identifier("isect")), Identifier("hit"))), Number(1))), Assign(Dot(Load(Identifier("isect")), Identifier("ray_dir")), Load(Dot(Load(Identifier("ray")), Identifier("dir")))), Return(Number(0))] }, Function { name: "Env_intersect", params: [("env", Pointer(Struct("Env"))), ("ray", Pointer(Struct("Ray"))), ("i", Pointer(Struct("Isect")))], ret_ty: Int32, body: [Call("Sphere_intersect", [Load(Dot(Load(Identifier("env")), Identifier("sphere1"))), Load(Dot(Load(Identifier("env")), Identifier("light"))), Load(Identifier("ray")), Load(Identifier("i"))]), Call("Sphere_intersect", [Load(Dot(Load(Identifier("env")), Identifier("sphere2"))), Load(Dot(Load(Identifier("env")), Identifier("light"))), Load(Identifier("ray")), Load(Identifier("i"))]), Call("Sphere_intersect", [Load(Dot(Load(Identifier("env")), Identifier("sphere3"))), Load(Dot(Load(Identifier("env")), Identifier("light"))), Load(Identifier("ray")), Load(Identifier("i"))]), Call("Plane_intersect", [Load(Dot(Load(Identifier("env")), Identifier("plane"))), Load(Dot(Load(Identifier("env")), Identifier("light"))), Load(Identifier("ray")), Load(Identifier("i"))]), Return(Number(0))] }, Function { name: "Env_new", params: [], ret_ty: Pointer(Struct("Env")), body: [VarDecl("env", Pointer(Struct("Env"))), Assign(Identifier("env"), Call("malloc", [Number(128)])), Assign(Dot(Load(Identifier("env")), Identifier("light")), Call("Vec_new", [FPNumber(0.577), FPNumber(0.577), FPNumber(0.577)])), Assign(Dot(Load(Identifier("env")), Identifier("sphere1")), Call("Sphere_new", [FPNumber(0.5), Call("Vec_new", [FPNumber(0.0), Sub(FPNumber(0.0), FPNumber(0.5)), Call("sin", [FPNumber(0.0)])]), Call("Vec_new", [FPNumber(1.0), FPNumber(0.0), FPNumber(0.0)])])), Assign(Dot(Load(Identifier("env")), Identifier("sphere2")), Call("Sphere_new", [FPNumber(1.0), Call("Vec_new", [FPNumber(2.0), FPNumber(0.0), Call("cos", [Mul(FPNumber(10.0), FPNumber(0.666))])]), Call("Vec_new", [FPNumber(0.0), FPNumber(1.0), FPNumber(0.0)])])), Assign(Dot(Load(Identifier("env")), Identifier("sphere3")), Call("Sphere_new", [FPNumber(1.5), Call("Vec_new", [Sub(FPNumber(0.0), FPNumber(2.0)), FPNumber(0.5), Call("cos", [Mul(FPNumber(10.0), FPNumber(0.333))])]), Call("Vec_new", [FPNumber(0.0), FPNumber(0.0), FPNumber(1.0)])])), Assign(Dot(Load(Identifier("env")), Identifier("plane")), Call("Plane_new", [Call("Vec_new", [FPNumber(0.0), Sub(FPNumber(0.0), FPNumber(1.0)), FPNumber(0.0)]), Call("Vec_new", [FPNumber(0.0), FPNumber(1.0), FPNumber(0.0)]), Call("Vec_new", [FPNumber(1.0), FPNumber(1.0), FPNumber(1.0)])])), Return(Load(Identifier("env")))] }, Function { name: "color_of", params: [("t", F64)], ret_ty: Int32, body: [VarDecl("ret", Int32), Assign(Identifier("ret"), Call("f64_to_i32", [Mul(Call("i32_to_f64", [Number(256)]), Call("clamp", [Load(Identifier("t")), FPNumber(0.0), FPNumber(1.0)]))])), IfElse(Eq(Load(Identifier("ret")), Number(256)), [Return(Sub(Number(256), Number(1)))], None), Return(Load(Identifier("ret")))] }, Function { name: "print_col", params: [("c", Pointer(Struct("Vec")))], ret_ty: Int32, body: [Return(Number(0))] }, Function { name: "main", params: [], ret_ty: Int32, body: [VarDecl("env", Pointer(Struct("Env"))), VarDecl("row", Int32), VarDecl("col", Int32), VarDecl("x", F64), VarDecl("y", F64), VarDecl("ray", Pointer(Struct("Ray"))), VarDecl("i", Pointer(Struct("Isect"))), VarDecl("dest_col", Pointer(Struct("Vec"))), VarDecl("temp_col", Pointer(Struct("Vec"))), VarDecl("j", Int32), VarDecl("q", Pointer(Struct("Ray"))), Assign(Identifier("env"), Call("Env_new", [])), Assign(Identifier("row"), Number(0)), WhileLoop(Lt(Load(Identifier("row")), Number(12)), [Assign(Identifier("col"), Number(0)), WhileLoop(Lt(Load(Identifier("col")), Number(12)), [Assign(Identifier("x"), Sub(Div(Div(Call("i32_to_f64", [Load(Identifier("col"))]), FPNumber(12.0)), FPNumber(20.0)), FPNumber(1.0))), Assign(Identifier("y"), Sub(Div(Div(Call("i32_to_f64", [Sub(Number(12), Load(Identifier("row")))]), FPNumber(12.0)), FPNumber(2.0)), FPNumber(1.0))), Assign(Identifier("ray"), Call("Ray_new", [Call("Vec_new", [FPNumber(0.0), FPNumber(2.0), FPNumber(6.0)]), Call("Vec_normalize", [Call("Vec_new", [Load(Identifier("x")), Load(Identifier("y")), Sub(FPNumber(0.0), FPNumber(1.0))])])])), Assign(Identifier("i"), Call("Isect_new", [Number(0), Call("Vec_new", [FPNumber(0.0), FPNumber(0.0), FPNumber(0.0)]), Call("Vec_new", [FPNumber(0.0), FPNumber(0.0), FPNumber(0.0)]), Call("Vec_new", [FPNumber(0.0), FPNumber(0.0), FPNumber(0.0)]), FPNumber(10000000.0), Call("Vec_new", [FPNumber(0.0), FPNumber(0.0), FPNumber(0.0)])])), Call("Env_intersect", [Load(Identifier("env")), Load(Identifier("ray")), Load(Identifier("i"))]), IfElse(Lt(Number(0), Load(Dot(Load(Identifier("i")), Identifier("hit")))), [Assign(Identifier("dest_col"), Load(Dot(Load(Identifier("i")), Identifier("color")))), Assign(Identifier("temp_col"), Call("Vec_multi", [Call("Vec_new", [FPNumber(1.0), FPNumber(1.0), FPNumber(1.0)]), Load(Dot(Load(Identifier("i")), Identifier("color")))])), Assign(Identifier("j"), Number(1)), WhileLoop(Lt(Load(Identifier("j")), Number(4)), [Assign(Identifier("q"), Call("Ray_new", [Call("Vec_add", [Load(Dot(Load(Identifier("i")), Identifier("hit_point"))), Call("Vec_mul", [Load(Dot(Load(Identifier("i")), Identifier("normal"))), FPNumber(0.0001)])]), Call("Vec_reflect", [Load(Dot(Load(Identifier("i")), Identifier("ray_dir"))), Load(Dot(Load(Identifier("i")), Identifier("normal")))])])), Call("Env_intersect", [Load(Identifier("env")), Load(Identifier("q")), Load(Identifier("i"))]), IfElse(Lt(Load(Identifier("j")), Load(Dot(Load(Identifier("i")), Identifier("hit")))), [Assign(Identifier("dest_col"), Call("Vec_add", [Load(Identifier("dest_col")), Call("Vec_multi", [Load(Identifier("temp_col")), Load(Dot(Load(Identifier("i")), Identifier("color")))])])), Assign(Identifier("temp_col"), Call("Vec_multi", [Load(Identifier("temp_col")), Load(Dot(Load(Identifier("i")), Identifier("color")))]))], None), Assign(Identifier("j"), Add(Load(Identifier("j")), Number(1)))]), Call("print_col", [Load(Identifier("dest_col"))])], Some([Call("print_col", [Call("Vec_new", [Load(Dot(Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Identifier("y"))), Load(Dot(Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Identifier("y"))), Load(Dot(Load(Dot(Load(Identifier("ray")), Identifier("dir"))), Identifier("y")))])])])), Assign(Identifier("col"), Add(Load(Identifier("col")), Number(1)))]), Assign(Identifier("row"), Add(Load(Identifier("row")), Number(1)))]), Return(Number(0))] }], structs: [("Vec", [("x", F64), ("y", F64), ("z", F64)]), ("Isect", [("hit", Int32), ("hit_point", Pointer(Struct("Vec"))), ("normal", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec"))), ("distance", F64), ("ray_dir", Pointer(Struct("Vec")))]), ("Ray", [("origin", Pointer(Struct("Vec"))), ("dir", Pointer(Struct("Vec")))]), ("Sphere", [("radius", F64), ("position", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec")))]), ("Plane", [("position", Pointer(Struct("Vec"))), ("normal", Pointer(Struct("Vec"))), ("color", Pointer(Struct("Vec")))]), ("Env", [("light", Pointer(Struct("Vec"))), ("sphere1", Pointer(Struct("Sphere"))), ("sphere2", Pointer(Struct("Sphere"))), ("sphere3", Pointer(Struct("Sphere"))), ("plane", Pointer(Struct("Plane")))])] }
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define void cilk.println.i32(i32) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define void cilk.printch.i32(i32) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define void cilk.println.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.sin.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.cos.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.sqrt.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.floor.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.fabs.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 cilk.i32_to_f64.i32(i32) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 cilk.f64_to_i32.f64(f64) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i64* cilk.malloc.i32(i32) {
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 clamp(f64, f64, f64) {
label.0:	// pred(), succ(1,2), def(0), in(), out()
    %0 = fcmp ult, f64 %arg.0, f64 %arg.1 // (self:0, users:[Id { idx: 1 }])
    br i1 %0, %label.1, %label.2 // (self:1, users:[])
label.1:	// pred(0), succ(), def(), in(), out()
    ret f64 %arg.1 // (self:2, users:[])
label.2:	// pred(0), succ(3,4), def(3), in(), out()
    %3 = fcmp ult, f64 %arg.2, f64 %arg.0 // (self:3, users:[Id { idx: 4 }])
    br i1 %3, %label.3, %label.4 // (self:4, users:[])
label.3:	// pred(2), succ(), def(), in(), out()
    ret f64 %arg.2 // (self:5, users:[])
label.4:	// pred(2), succ(), def(), in(), out()
    ret f64 %arg.0 // (self:6, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_new(f64, f64, f64) {
label.0:	// pred(), succ(), def(3,9,4,7,6,1,12,10), in(0), out()
    %0 = alloca struct {f64, f64, f64}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 6 }, Id { idx: 9 }, Id { idx: 12 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {f64, f64, f64}** %0 // (self:2, users:[])
    %3 = load struct {f64, f64, f64}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {f64, f64, f64}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 5 }])
    store f64 %arg.0, f64* %4 // (self:5, users:[])
    %6 = load struct {f64, f64, f64}** %0 // (self:6, users:[Id { idx: 7 }])
    %7 = getelementptr struct {f64, f64, f64}* %6, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    store f64 %arg.1, f64* %7 // (self:8, users:[])
    %9 = load struct {f64, f64, f64}** %0 // (self:9, users:[Id { idx: 10 }])
    %10 = getelementptr struct {f64, f64, f64}* %9, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    store f64 %arg.2, f64* %10 // (self:11, users:[])
    %12 = load struct {f64, f64, f64}** %0 // (self:12, users:[Id { idx: 13 }])
    ret struct {f64, f64, f64}* %12 // (self:13, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_add(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(7,9,12,15,2,5,10,13,0,3,6,8,11,14,1,4), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 4 }])
    %2 = getelementptr (ty:8)* %arg.1, i32 0, i32 0 // (self:2, users:[Id { idx: 3 }])
    %3 = load f64* %2 // (self:3, users:[Id { idx: 4 }])
    %4 = add f64 %1, f64 %3 // (self:4, users:[Id { idx: 15 }])
    %5 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:5, users:[Id { idx: 6 }])
    %6 = load f64* %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:8)* %arg.1, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    %8 = load f64* %7 // (self:8, users:[Id { idx: 9 }])
    %9 = add f64 %6, f64 %8 // (self:9, users:[Id { idx: 15 }])
    %10 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    %11 = load f64* %10 // (self:11, users:[Id { idx: 14 }])
    %12 = getelementptr (ty:8)* %arg.1, i32 0, i32 2 // (self:12, users:[Id { idx: 13 }])
    %13 = load f64* %12 // (self:13, users:[Id { idx: 14 }])
    %14 = add f64 %11, f64 %13 // (self:14, users:[Id { idx: 15 }])
    %15 = call struct {f64, f64, f64}* Vec_new, f64 %4, f64 %9, f64 %14 // (self:15, users:[Id { idx: 16 }])
    ret struct {f64, f64, f64}* %15 // (self:16, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_sub(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(6,1,12,15,10,4,7,2,13,8,11,5,0,3,14,9), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 4 }])
    %2 = getelementptr (ty:8)* %arg.1, i32 0, i32 0 // (self:2, users:[Id { idx: 3 }])
    %3 = load f64* %2 // (self:3, users:[Id { idx: 4 }])
    %4 = sub f64 %1, f64 %3 // (self:4, users:[Id { idx: 15 }])
    %5 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:5, users:[Id { idx: 6 }])
    %6 = load f64* %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:8)* %arg.1, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    %8 = load f64* %7 // (self:8, users:[Id { idx: 9 }])
    %9 = sub f64 %6, f64 %8 // (self:9, users:[Id { idx: 15 }])
    %10 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    %11 = load f64* %10 // (self:11, users:[Id { idx: 14 }])
    %12 = getelementptr (ty:8)* %arg.1, i32 0, i32 2 // (self:12, users:[Id { idx: 13 }])
    %13 = load f64* %12 // (self:13, users:[Id { idx: 14 }])
    %14 = sub f64 %11, f64 %13 // (self:14, users:[Id { idx: 15 }])
    %15 = call struct {f64, f64, f64}* Vec_new, f64 %4, f64 %9, f64 %14 // (self:15, users:[Id { idx: 16 }])
    ret struct {f64, f64, f64}* %15 // (self:16, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_mul(struct {f64, f64, f64}*, f64) {
label.0:	// pred(), succ(), def(0,7,4,1,8,5,2,9,6,3), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 2 }])
    %2 = mul f64 %1, f64 %arg.1 // (self:2, users:[Id { idx: 9 }])
    %3 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:3, users:[Id { idx: 4 }])
    %4 = load f64* %3 // (self:4, users:[Id { idx: 5 }])
    %5 = mul f64 %4, f64 %arg.1 // (self:5, users:[Id { idx: 9 }])
    %6 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:6, users:[Id { idx: 7 }])
    %7 = load f64* %6 // (self:7, users:[Id { idx: 8 }])
    %8 = mul f64 %7, f64 %arg.1 // (self:8, users:[Id { idx: 9 }])
    %9 = call struct {f64, f64, f64}* Vec_new, f64 %2, f64 %5, f64 %8 // (self:9, users:[Id { idx: 10 }])
    ret struct {f64, f64, f64}* %9 // (self:10, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_multi(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(4,10,15,12,1,6,9,14,3,0,5,11,8,13,2,7), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 4 }])
    %2 = getelementptr (ty:8)* %arg.1, i32 0, i32 0 // (self:2, users:[Id { idx: 3 }])
    %3 = load f64* %2 // (self:3, users:[Id { idx: 4 }])
    %4 = add f64 %1, f64 %3 // (self:4, users:[Id { idx: 15 }])
    %5 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:5, users:[Id { idx: 6 }])
    %6 = load f64* %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:8)* %arg.1, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    %8 = load f64* %7 // (self:8, users:[Id { idx: 9 }])
    %9 = add f64 %6, f64 %8 // (self:9, users:[Id { idx: 15 }])
    %10 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    %11 = load f64* %10 // (self:11, users:[Id { idx: 14 }])
    %12 = getelementptr (ty:8)* %arg.1, i32 0, i32 2 // (self:12, users:[Id { idx: 13 }])
    %13 = load f64* %12 // (self:13, users:[Id { idx: 14 }])
    %14 = add f64 %11, f64 %13 // (self:14, users:[Id { idx: 15 }])
    %15 = call struct {f64, f64, f64}* Vec_new, f64 %4, f64 %9, f64 %14 // (self:15, users:[Id { idx: 16 }])
    ret struct {f64, f64, f64}* %15 // (self:16, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 Vec_dot(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(5,15,12,9,19,16,7,4,1,14,11,8,18,6,3,0,13,10,17), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 2 }])
    call void cilk.println.f64, f64 %1 // (self:2, users:[])
    %3 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:3, users:[Id { idx: 4 }])
    %4 = load f64* %3 // (self:4, users:[Id { idx: 7 }])
    %5 = getelementptr (ty:8)* %arg.1, i32 0, i32 0 // (self:5, users:[Id { idx: 6 }])
    %6 = load f64* %5 // (self:6, users:[Id { idx: 7 }])
    %7 = mul f64 %4, f64 %6 // (self:7, users:[Id { idx: 13 }])
    %8 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:8, users:[Id { idx: 9 }])
    %9 = load f64* %8 // (self:9, users:[Id { idx: 12 }])
    %10 = getelementptr (ty:8)* %arg.1, i32 0, i32 1 // (self:10, users:[Id { idx: 11 }])
    %11 = load f64* %10 // (self:11, users:[Id { idx: 12 }])
    %12 = mul f64 %9, f64 %11 // (self:12, users:[Id { idx: 13 }])
    %13 = add f64 %7, f64 %12 // (self:13, users:[Id { idx: 19 }])
    %14 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:14, users:[Id { idx: 15 }])
    %15 = load f64* %14 // (self:15, users:[Id { idx: 18 }])
    %16 = getelementptr (ty:8)* %arg.1, i32 0, i32 2 // (self:16, users:[Id { idx: 17 }])
    %17 = load f64* %16 // (self:17, users:[Id { idx: 18 }])
    %18 = mul f64 %15, f64 %17 // (self:18, users:[Id { idx: 19 }])
    %19 = add f64 %13, f64 %18 // (self:19, users:[Id { idx: 20 }])
    ret f64 %19 // (self:20, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_reflect(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(0,2,1,3), in(), out()
    %0 = call f64 Vec_dot, (ty:8)* %arg.1, (ty:8)* %arg.0 // (self:0, users:[Id { idx: 1 }])
    %1 = mul f64 -2, f64 %0 // (self:1, users:[Id { idx: 2 }])
    %2 = call struct {f64, f64, f64}* Vec_mul, (ty:8)* %arg.1, f64 %1 // (self:2, users:[Id { idx: 3 }])
    %3 = call struct {f64, f64, f64}* Vec_add, (ty:8)* %arg.0, struct {f64, f64, f64}* %2 // (self:3, users:[Id { idx: 4 }])
    ret struct {f64, f64, f64}* %3 // (self:4, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define f64 Vec_length(struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(1,16,15,10,9,4,3,17,12,11,6,5,0,14,13,8,7,2), in(), out()
    %0 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:0, users:[Id { idx: 1 }])
    %1 = load f64* %0 // (self:1, users:[Id { idx: 4 }])
    %2 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:2, users:[Id { idx: 3 }])
    %3 = load f64* %2 // (self:3, users:[Id { idx: 4 }])
    %4 = mul f64 %1, f64 %3 // (self:4, users:[Id { idx: 10 }])
    %5 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:5, users:[Id { idx: 6 }])
    %6 = load f64* %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    %8 = load f64* %7 // (self:8, users:[Id { idx: 9 }])
    %9 = mul f64 %6, f64 %8 // (self:9, users:[Id { idx: 10 }])
    %10 = add f64 %4, f64 %9 // (self:10, users:[Id { idx: 16 }])
    %11 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:11, users:[Id { idx: 12 }])
    %12 = load f64* %11 // (self:12, users:[Id { idx: 15 }])
    %13 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:13, users:[Id { idx: 14 }])
    %14 = load f64* %13 // (self:14, users:[Id { idx: 15 }])
    %15 = mul f64 %12, f64 %14 // (self:15, users:[Id { idx: 16 }])
    %16 = add f64 %10, f64 %15 // (self:16, users:[Id { idx: 17 }])
    %17 = call f64 cilk.sqrt.f64, f64 %16 // (self:17, users:[Id { idx: 18 }])
    ret f64 %17 // (self:18, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, f64, f64}* Vec_normalize(struct {f64, f64, f64}*) {
label.0:	// pred(), succ(1,2), def(5,4,2), in(1,0), out(1,0)
    %0 = alloca f64 // (self:0, users:[Id { idx: 3 }, Id { idx: 4 }, Id { idx: 7 }])
    %1 = alloca f64 // (self:1, users:[Id { idx: 9 }, Id { idx: 13 }, Id { idx: 19 }, Id { idx: 25 }])
    %2 = call f64 Vec_length, (ty:8)* %arg.0 // (self:2, users:[Id { idx: 3 }])
    store f64 %2, f64* %0 // (self:3, users:[])
    %4 = load f64* %0 // (self:4, users:[Id { idx: 5 }])
    %5 = fcmp ult, f64 0.00000001, f64 %4 // (self:5, users:[Id { idx: 6 }])
    br i1 %5, %label.1, %label.2 // (self:6, users:[])
label.1:	// pred(0), succ(2), def(8,16,23,10,12,24,18,17,20,11,14,13,7,26,25,19,22), in(1,0), out()
    %7 = load f64* %0 // (self:7, users:[Id { idx: 8 }])
    %8 = div f64 1, f64 %7 // (self:8, users:[Id { idx: 9 }])
    store f64 %8, f64* %1 // (self:9, users:[])
    %10 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:10, users:[Id { idx: 15 }])
    %11 = getelementptr (ty:8)* %arg.0, i32 0, i32 0 // (self:11, users:[Id { idx: 12 }])
    %12 = load f64* %11 // (self:12, users:[Id { idx: 14 }])
    %13 = load f64* %1 // (self:13, users:[Id { idx: 14 }])
    %14 = mul f64 %12, f64 %13 // (self:14, users:[Id { idx: 15 }])
    store f64 %14, f64* %10 // (self:15, users:[])
    %16 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:16, users:[Id { idx: 21 }])
    %17 = getelementptr (ty:8)* %arg.0, i32 0, i32 1 // (self:17, users:[Id { idx: 18 }])
    %18 = load f64* %17 // (self:18, users:[Id { idx: 20 }])
    %19 = load f64* %1 // (self:19, users:[Id { idx: 20 }])
    %20 = mul f64 %18, f64 %19 // (self:20, users:[Id { idx: 21 }])
    store f64 %20, f64* %16 // (self:21, users:[])
    %22 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:22, users:[Id { idx: 27 }])
    %23 = getelementptr (ty:8)* %arg.0, i32 0, i32 2 // (self:23, users:[Id { idx: 24 }])
    %24 = load f64* %23 // (self:24, users:[Id { idx: 26 }])
    %25 = load f64* %1 // (self:25, users:[Id { idx: 26 }])
    %26 = mul f64 %24, f64 %25 // (self:26, users:[Id { idx: 27 }])
    store f64 %26, f64* %22 // (self:27, users:[])
    br %label.2 // (self:28, users:[])
label.2:	// pred(0,1), succ(), def(), in(), out()
    ret (ty:8)* %arg.0 // (self:29, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Ray_new(struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(9,7,6,3,4,1), in(0), out()
    %0 = alloca struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 6 }, Id { idx: 9 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:2, users:[])
    %3 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 5 }])
    store (ty:8)* %arg.0, struct {f64, f64, f64}** %4 // (self:5, users:[])
    %6 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:6, users:[Id { idx: 7 }])
    %7 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %6, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    store (ty:8)* %arg.1, struct {f64, f64, f64}** %7 // (self:8, users:[])
    %9 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:9, users:[Id { idx: 10 }])
    ret struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %9 // (self:10, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* Isect_new(i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(3,4,9,10,15,16,19,6,21,12,1,18,7,13), in(0), out()
    %0 = alloca struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 6 }, Id { idx: 9 }, Id { idx: 12 }, Id { idx: 15 }, Id { idx: 18 }, Id { idx: 21 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:2, users:[])
    %3 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 5 }])
    store i32 %arg.0, i32* %4 // (self:5, users:[])
    %6 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:6, users:[Id { idx: 7 }])
    %7 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %6, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    store (ty:8)* %arg.1, struct {f64, f64, f64}** %7 // (self:8, users:[])
    %9 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:9, users:[Id { idx: 10 }])
    %10 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %9, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    store (ty:8)* %arg.2, struct {f64, f64, f64}** %10 // (self:11, users:[])
    %12 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:12, users:[Id { idx: 13 }])
    %13 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %12, i32 0, i32 3 // (self:13, users:[Id { idx: 14 }])
    store (ty:8)* %arg.3, struct {f64, f64, f64}** %13 // (self:14, users:[])
    %15 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:15, users:[Id { idx: 16 }])
    %16 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %15, i32 0, i32 4 // (self:16, users:[Id { idx: 17 }])
    store f64 %arg.4, f64* %16 // (self:17, users:[])
    %18 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:18, users:[Id { idx: 19 }])
    %19 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %18, i32 0, i32 5 // (self:19, users:[Id { idx: 20 }])
    store (ty:8)* %arg.5, struct {f64, f64, f64}** %19 // (self:20, users:[])
    %21 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %0 // (self:21, users:[Id { idx: 22 }])
    ret struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %21 // (self:22, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Sphere_new(f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(3,9,4,7,6,1,12,10), in(0), out()
    %0 = alloca struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 6 }, Id { idx: 9 }, Id { idx: 12 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:2, users:[])
    %3 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 5 }])
    store f64 %arg.0, f64* %4 // (self:5, users:[])
    %6 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:6, users:[Id { idx: 7 }])
    %7 = getelementptr struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %6, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    store (ty:8)* %arg.1, struct {f64, f64, f64}** %7 // (self:8, users:[])
    %9 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:9, users:[Id { idx: 10 }])
    %10 = getelementptr struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %9, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    store (ty:8)* %arg.2, struct {f64, f64, f64}** %10 // (self:11, users:[])
    %12 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:12, users:[Id { idx: 13 }])
    ret struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %12 // (self:13, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 Sphere_intersect(struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*) {
label.0:	// pred(), succ(1,2), def(39,26,29,16,19,22,9,12,5,32,35,38,28,18,21,8,11,14,7,34,24,27,30,17,20,23,13,6,33,36), in(2,0,3,1,4), out(4)
    %0 = alloca struct {f64, f64, f64}* // (self:0, users:[Id { idx: 10 }, Id { idx: 11 }, Id { idx: 16 }, Id { idx: 17 }])
    %1 = alloca f64 // (self:1, users:[Id { idx: 15 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 32 }])
    %2 = alloca f64 // (self:2, users:[Id { idx: 25 }, Id { idx: 29 }])
    %3 = alloca f64 // (self:3, users:[Id { idx: 31 }, Id { idx: 34 }, Id { idx: 38 }])
    %4 = alloca f64 // (self:4, users:[Id { idx: 37 }, Id { idx: 42 }, Id { idx: 48 }, Id { idx: 57 }, Id { idx: 79 }])
    %5 = getelementptr (ty:23)* %arg.2, i32 0, i32 0 // (self:5, users:[Id { idx: 6 }])
    %6 = load struct {f64, f64, f64}** %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:13)* %arg.0, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    %8 = load struct {f64, f64, f64}** %7 // (self:8, users:[Id { idx: 9 }])
    %9 = call struct {f64, f64, f64}* Vec_sub, struct {f64, f64, f64}* %6, struct {f64, f64, f64}* %8 // (self:9, users:[Id { idx: 10 }])
    store struct {f64, f64, f64}* %9, struct {f64, f64, f64}** %0 // (self:10, users:[])
    %11 = load struct {f64, f64, f64}** %0 // (self:11, users:[Id { idx: 14 }])
    %12 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:12, users:[Id { idx: 13 }])
    %13 = load struct {f64, f64, f64}** %12 // (self:13, users:[Id { idx: 14 }])
    %14 = call f64 Vec_dot, struct {f64, f64, f64}* %11, struct {f64, f64, f64}* %13 // (self:14, users:[Id { idx: 15 }])
    store f64 %14, f64* %1 // (self:15, users:[])
    %16 = load struct {f64, f64, f64}** %0 // (self:16, users:[Id { idx: 18 }])
    %17 = load struct {f64, f64, f64}** %0 // (self:17, users:[Id { idx: 18 }])
    %18 = call f64 Vec_dot, struct {f64, f64, f64}* %16, struct {f64, f64, f64}* %17 // (self:18, users:[Id { idx: 24 }])
    %19 = getelementptr (ty:13)* %arg.0, i32 0, i32 0 // (self:19, users:[Id { idx: 20 }])
    %20 = load f64* %19 // (self:20, users:[Id { idx: 23 }])
    %21 = getelementptr (ty:13)* %arg.0, i32 0, i32 0 // (self:21, users:[Id { idx: 22 }])
    %22 = load f64* %21 // (self:22, users:[Id { idx: 23 }])
    %23 = mul f64 %20, f64 %22 // (self:23, users:[Id { idx: 24 }])
    %24 = sub f64 %18, f64 %23 // (self:24, users:[Id { idx: 25 }])
    store f64 %24, f64* %2 // (self:25, users:[])
    %26 = load f64* %1 // (self:26, users:[Id { idx: 28 }])
    %27 = load f64* %1 // (self:27, users:[Id { idx: 28 }])
    %28 = mul f64 %26, f64 %27 // (self:28, users:[Id { idx: 30 }])
    %29 = load f64* %2 // (self:29, users:[Id { idx: 30 }])
    %30 = sub f64 %28, f64 %29 // (self:30, users:[Id { idx: 31 }])
    store f64 %30, f64* %3 // (self:31, users:[])
    %32 = load f64* %1 // (self:32, users:[Id { idx: 33 }])
    %33 = sub f64 0, f64 %32 // (self:33, users:[Id { idx: 36 }])
    %34 = load f64* %3 // (self:34, users:[Id { idx: 35 }])
    %35 = call f64 cilk.sqrt.f64, f64 %34 // (self:35, users:[Id { idx: 36 }])
    %36 = sub f64 %33, f64 %35 // (self:36, users:[Id { idx: 37 }])
    store f64 %36, f64* %4 // (self:37, users:[])
    %38 = load f64* %3 // (self:38, users:[Id { idx: 39 }])
    %39 = fcmp ule, f64 %38, f64 0 // (self:39, users:[Id { idx: 40 }])
    br i1 %39, %label.1, %label.2 // (self:40, users:[])
label.1:	// pred(0), succ(), def(), in(), out()
    ret i32 0 // (self:41, users:[])
label.2:	// pred(0), succ(3,4), def(43,42), in(4), out(4)
    %42 = load f64* %4 // (self:42, users:[Id { idx: 43 }])
    %43 = fcmp ule, f64 %42, f64 0.0001 // (self:43, users:[Id { idx: 44 }])
    br i1 %43, %label.3, %label.4 // (self:44, users:[])
label.3:	// pred(2), succ(), def(), in(), out()
    ret i32 0 // (self:45, users:[])
label.4:	// pred(2), succ(5,6), def(47,48,46,49), in(4), out(4)
    %46 = getelementptr (ty:25)* %arg.3, i32 0, i32 4 // (self:46, users:[Id { idx: 47 }])
    %47 = load f64* %46 // (self:47, users:[Id { idx: 49 }])
    %48 = load f64* %4 // (self:48, users:[Id { idx: 49 }])
    %49 = fcmp ule, f64 %47, f64 %48 // (self:49, users:[Id { idx: 50 }])
    br i1 %49, %label.5, %label.6 // (self:50, users:[])
label.5:	// pred(4), succ(), def(), in(), out()
    ret i32 0 // (self:51, users:[])
label.6:	// pred(4), succ(), def(83,86,73,76,79,66,69,56,59,62,52,55,82,72,75,78,65,71,58,61,54,88,81,84,87,74,64,67,70,57,63,53), in(4), out()
    %52 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:52, users:[Id { idx: 60 }])
    %53 = getelementptr (ty:23)* %arg.2, i32 0, i32 0 // (self:53, users:[Id { idx: 54 }])
    %54 = load struct {f64, f64, f64}** %53 // (self:54, users:[Id { idx: 59 }])
    %55 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:55, users:[Id { idx: 56 }])
    %56 = load struct {f64, f64, f64}** %55 // (self:56, users:[Id { idx: 58 }])
    %57 = load f64* %4 // (self:57, users:[Id { idx: 58 }])
    %58 = call struct {f64, f64, f64}* Vec_mul, struct {f64, f64, f64}* %56, f64 %57 // (self:58, users:[Id { idx: 59 }])
    %59 = call struct {f64, f64, f64}* Vec_add, struct {f64, f64, f64}* %54, struct {f64, f64, f64}* %58 // (self:59, users:[Id { idx: 60 }])
    store struct {f64, f64, f64}* %59, struct {f64, f64, f64}** %52 // (self:60, users:[])
    %61 = getelementptr (ty:25)* %arg.3, i32 0, i32 2 // (self:61, users:[Id { idx: 68 }])
    %62 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:62, users:[Id { idx: 63 }])
    %63 = load struct {f64, f64, f64}** %62 // (self:63, users:[Id { idx: 66 }])
    %64 = getelementptr (ty:13)* %arg.0, i32 0, i32 1 // (self:64, users:[Id { idx: 65 }])
    %65 = load struct {f64, f64, f64}** %64 // (self:65, users:[Id { idx: 66 }])
    %66 = call struct {f64, f64, f64}* Vec_sub, struct {f64, f64, f64}* %63, struct {f64, f64, f64}* %65 // (self:66, users:[Id { idx: 67 }])
    %67 = call struct {f64, f64, f64}* Vec_normalize, struct {f64, f64, f64}* %66 // (self:67, users:[Id { idx: 68 }])
    store struct {f64, f64, f64}* %67, struct {f64, f64, f64}** %61 // (self:68, users:[])
    %69 = getelementptr (ty:25)* %arg.3, i32 0, i32 3 // (self:69, users:[Id { idx: 77 }])
    %70 = getelementptr (ty:13)* %arg.0, i32 0, i32 2 // (self:70, users:[Id { idx: 71 }])
    %71 = load struct {f64, f64, f64}** %70 // (self:71, users:[Id { idx: 76 }])
    %72 = getelementptr (ty:25)* %arg.3, i32 0, i32 2 // (self:72, users:[Id { idx: 73 }])
    %73 = load struct {f64, f64, f64}** %72 // (self:73, users:[Id { idx: 74 }])
    %74 = call f64 Vec_dot, (ty:8)* %arg.1, struct {f64, f64, f64}* %73 // (self:74, users:[Id { idx: 75 }])
    %75 = call f64 clamp, f64 %74, f64 0.1, f64 1 // (self:75, users:[Id { idx: 76 }])
    %76 = call struct {f64, f64, f64}* Vec_mul, struct {f64, f64, f64}* %71, f64 %75 // (self:76, users:[Id { idx: 77 }])
    store struct {f64, f64, f64}* %76, struct {f64, f64, f64}** %69 // (self:77, users:[])
    %78 = getelementptr (ty:25)* %arg.3, i32 0, i32 4 // (self:78, users:[Id { idx: 80 }])
    %79 = load f64* %4 // (self:79, users:[Id { idx: 80 }])
    store f64 %79, f64* %78 // (self:80, users:[])
    %81 = getelementptr (ty:25)* %arg.3, i32 0, i32 0 // (self:81, users:[Id { idx: 85 }])
    %82 = getelementptr (ty:25)* %arg.3, i32 0, i32 0 // (self:82, users:[Id { idx: 83 }])
    %83 = load i32* %82 // (self:83, users:[Id { idx: 84 }])
    %84 = add i32 %83, i32 1 // (self:84, users:[Id { idx: 85 }])
    store i32 %84, i32* %81 // (self:85, users:[])
    %86 = getelementptr (ty:25)* %arg.3, i32 0, i32 5 // (self:86, users:[Id { idx: 89 }])
    %87 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:87, users:[Id { idx: 88 }])
    %88 = load struct {f64, f64, f64}** %87 // (self:88, users:[Id { idx: 89 }])
    store struct {f64, f64, f64}* %88, struct {f64, f64, f64}** %86 // (self:89, users:[])
    ret i32 0 // (self:90, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Plane_new(struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(6,1,12,10,3,9,4,7), in(0), out()
    %0 = alloca struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 6 }, Id { idx: 9 }, Id { idx: 12 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:2, users:[])
    %3 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 5 }])
    store (ty:8)* %arg.0, struct {f64, f64, f64}** %4 // (self:5, users:[])
    %6 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:6, users:[Id { idx: 7 }])
    %7 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %6, i32 0, i32 1 // (self:7, users:[Id { idx: 8 }])
    store (ty:8)* %arg.1, struct {f64, f64, f64}** %7 // (self:8, users:[])
    %9 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:9, users:[Id { idx: 10 }])
    %10 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %9, i32 0, i32 2 // (self:10, users:[Id { idx: 11 }])
    store (ty:8)* %arg.2, struct {f64, f64, f64}** %10 // (self:11, users:[])
    %12 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:12, users:[Id { idx: 13 }])
    ret struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %12 // (self:13, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 Plane_intersect(struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*) {
label.0:	// pred(), succ(1,2), def(16,13,10,33,30,27,24,18,12,9,29,26,23,20,17,14,11,34,31,28,25,22,19), in(0,7,4,1,8,5,2,6,3), out(8,5,2,7,4,6,3)
    %0 = alloca f64 // (self:0, users:[Id { idx: 15 }, Id { idx: 27 }])
    %1 = alloca f64 // (self:1, users:[Id { idx: 21 }, Id { idx: 29 }])
    %2 = alloca f64 // (self:2, users:[Id { idx: 32 }, Id { idx: 33 }, Id { idx: 39 }, Id { idx: 48 }, Id { idx: 136 }])
    %3 = alloca f64 // (self:3, users:[Id { idx: 60 }, Id { idx: 87 }])
    %4 = alloca f64 // (self:4, users:[Id { idx: 73 }, Id { idx: 89 }, Id { idx: 100 }])
    %5 = alloca f64 // (self:5, users:[Id { idx: 86 }, Id { idx: 92 }, Id { idx: 103 }])
    %6 = alloca f64 // (self:6, users:[Id { idx: 88 }, Id { idx: 95 }, Id { idx: 97 }, Id { idx: 106 }, Id { idx: 108 }, Id { idx: 130 }])
    %7 = alloca f64 // (self:7, users:[Id { idx: 117 }, Id { idx: 119 }, Id { idx: 122 }])
    %8 = alloca f64 // (self:8, users:[Id { idx: 118 }, Id { idx: 125 }, Id { idx: 131 }])
    %9 = getelementptr (ty:14)* %arg.0, i32 0, i32 0 // (self:9, users:[Id { idx: 10 }])
    %10 = load struct {f64, f64, f64}** %9 // (self:10, users:[Id { idx: 13 }])
    %11 = getelementptr (ty:14)* %arg.0, i32 0, i32 1 // (self:11, users:[Id { idx: 12 }])
    %12 = load struct {f64, f64, f64}** %11 // (self:12, users:[Id { idx: 13 }])
    %13 = call f64 Vec_dot, struct {f64, f64, f64}* %10, struct {f64, f64, f64}* %12 // (self:13, users:[Id { idx: 14 }])
    %14 = sub f64 0, f64 %13 // (self:14, users:[Id { idx: 15 }])
    store f64 %14, f64* %0 // (self:15, users:[])
    %16 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:16, users:[Id { idx: 17 }])
    %17 = load struct {f64, f64, f64}** %16 // (self:17, users:[Id { idx: 20 }])
    %18 = getelementptr (ty:14)* %arg.0, i32 0, i32 1 // (self:18, users:[Id { idx: 19 }])
    %19 = load struct {f64, f64, f64}** %18 // (self:19, users:[Id { idx: 20 }])
    %20 = call f64 Vec_dot, struct {f64, f64, f64}* %17, struct {f64, f64, f64}* %19 // (self:20, users:[Id { idx: 21 }])
    store f64 %20, f64* %1 // (self:21, users:[])
    %22 = getelementptr (ty:23)* %arg.2, i32 0, i32 0 // (self:22, users:[Id { idx: 23 }])
    %23 = load struct {f64, f64, f64}** %22 // (self:23, users:[Id { idx: 26 }])
    %24 = getelementptr (ty:14)* %arg.0, i32 0, i32 1 // (self:24, users:[Id { idx: 25 }])
    %25 = load struct {f64, f64, f64}** %24 // (self:25, users:[Id { idx: 26 }])
    %26 = call f64 Vec_dot, struct {f64, f64, f64}* %23, struct {f64, f64, f64}* %25 // (self:26, users:[Id { idx: 28 }])
    %27 = load f64* %0 // (self:27, users:[Id { idx: 28 }])
    %28 = add f64 %26, f64 %27 // (self:28, users:[Id { idx: 30 }])
    %29 = load f64* %1 // (self:29, users:[Id { idx: 30 }])
    %30 = div f64 %28, f64 %29 // (self:30, users:[Id { idx: 31 }])
    %31 = sub f64 0, f64 %30 // (self:31, users:[Id { idx: 32 }])
    store f64 %31, f64* %2 // (self:32, users:[])
    %33 = load f64* %2 // (self:33, users:[Id { idx: 34 }])
    %34 = fcmp ule, f64 %33, f64 0.0001 // (self:34, users:[Id { idx: 35 }])
    br i1 %34, %label.1, %label.2 // (self:35, users:[])
label.1:	// pred(0), succ(), def(), in(), out()
    ret i32 0 // (self:36, users:[])
label.2:	// pred(0), succ(3,4), def(40,37,39,38), in(8,5,2,7,4,6,3), out(8,5,2,7,4,6,3)
    %37 = getelementptr (ty:25)* %arg.3, i32 0, i32 4 // (self:37, users:[Id { idx: 38 }])
    %38 = load f64* %37 // (self:38, users:[Id { idx: 40 }])
    %39 = load f64* %2 // (self:39, users:[Id { idx: 40 }])
    %40 = fcmp ule, f64 %38, f64 %39 // (self:40, users:[Id { idx: 41 }])
    br i1 %40, %label.3, %label.4 // (self:41, users:[])
label.3:	// pred(2), succ(), def(), in(), out()
    ret i32 0 // (self:42, users:[])
label.4:	// pred(2), succ(5,6), def(48,77,74,71,68,65,85,82,47,44,61,58,52,49,78,75,72,69,66,89,83,80,45,62,59,56,53,50,79,76,70,67,64,90,87,84,81,46,43,63,57,54), in(8,5,2,7,4,6,3), out(8,5,2,7,4,6)
    %43 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:43, users:[Id { idx: 51 }])
    %44 = getelementptr (ty:23)* %arg.2, i32 0, i32 0 // (self:44, users:[Id { idx: 45 }])
    %45 = load struct {f64, f64, f64}** %44 // (self:45, users:[Id { idx: 50 }])
    %46 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:46, users:[Id { idx: 47 }])
    %47 = load struct {f64, f64, f64}** %46 // (self:47, users:[Id { idx: 49 }])
    %48 = load f64* %2 // (self:48, users:[Id { idx: 49 }])
    %49 = call struct {f64, f64, f64}* Vec_mul, struct {f64, f64, f64}* %47, f64 %48 // (self:49, users:[Id { idx: 50 }])
    %50 = call struct {f64, f64, f64}* Vec_add, struct {f64, f64, f64}* %45, struct {f64, f64, f64}* %49 // (self:50, users:[Id { idx: 51 }])
    store struct {f64, f64, f64}* %50, struct {f64, f64, f64}** %43 // (self:51, users:[])
    %52 = getelementptr (ty:25)* %arg.3, i32 0, i32 2 // (self:52, users:[Id { idx: 55 }])
    %53 = getelementptr (ty:14)* %arg.0, i32 0, i32 1 // (self:53, users:[Id { idx: 54 }])
    %54 = load struct {f64, f64, f64}** %53 // (self:54, users:[Id { idx: 55 }])
    store struct {f64, f64, f64}* %54, struct {f64, f64, f64}** %52 // (self:55, users:[])
    %56 = getelementptr (ty:25)* %arg.3, i32 0, i32 2 // (self:56, users:[Id { idx: 57 }])
    %57 = load struct {f64, f64, f64}** %56 // (self:57, users:[Id { idx: 58 }])
    %58 = call f64 Vec_dot, (ty:8)* %arg.1, struct {f64, f64, f64}* %57 // (self:58, users:[Id { idx: 59 }])
    %59 = call f64 clamp, f64 %58, f64 0.1, f64 1 // (self:59, users:[Id { idx: 60 }])
    store f64 %59, f64* %3 // (self:60, users:[])
    %61 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:61, users:[Id { idx: 62 }])
    %62 = load struct {f64, f64, f64}** %61 // (self:62, users:[Id { idx: 63 }])
    %63 = getelementptr struct {f64, f64, f64}* %62, i32 0, i32 0 // (self:63, users:[Id { idx: 64 }])
    %64 = load f64* %63 // (self:64, users:[Id { idx: 72 }])
    %65 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:65, users:[Id { idx: 66 }])
    %66 = load struct {f64, f64, f64}** %65 // (self:66, users:[Id { idx: 67 }])
    %67 = getelementptr struct {f64, f64, f64}* %66, i32 0, i32 0 // (self:67, users:[Id { idx: 68 }])
    %68 = load f64* %67 // (self:68, users:[Id { idx: 69 }])
    %69 = div f64 %68, f64 2 // (self:69, users:[Id { idx: 70 }])
    %70 = call f64 cilk.floor.f64, f64 %69 // (self:70, users:[Id { idx: 71 }])
    %71 = mul f64 2, f64 %70 // (self:71, users:[Id { idx: 72 }])
    %72 = sub f64 %64, f64 %71 // (self:72, users:[Id { idx: 73 }])
    store f64 %72, f64* %4 // (self:73, users:[])
    %74 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:74, users:[Id { idx: 75 }])
    %75 = load struct {f64, f64, f64}** %74 // (self:75, users:[Id { idx: 76 }])
    %76 = getelementptr struct {f64, f64, f64}* %75, i32 0, i32 2 // (self:76, users:[Id { idx: 77 }])
    %77 = load f64* %76 // (self:77, users:[Id { idx: 85 }])
    %78 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:78, users:[Id { idx: 79 }])
    %79 = load struct {f64, f64, f64}** %78 // (self:79, users:[Id { idx: 80 }])
    %80 = getelementptr struct {f64, f64, f64}* %79, i32 0, i32 2 // (self:80, users:[Id { idx: 81 }])
    %81 = load f64* %80 // (self:81, users:[Id { idx: 82 }])
    %82 = div f64 %81, f64 2 // (self:82, users:[Id { idx: 83 }])
    %83 = call f64 cilk.floor.f64, f64 %82 // (self:83, users:[Id { idx: 84 }])
    %84 = mul f64 2, f64 %83 // (self:84, users:[Id { idx: 85 }])
    %85 = sub f64 %77, f64 %84 // (self:85, users:[Id { idx: 86 }])
    store f64 %85, f64* %5 // (self:86, users:[])
    %87 = load f64* %3 // (self:87, users:[Id { idx: 88 }])
    store f64 %87, f64* %6 // (self:88, users:[])
    %89 = load f64* %4 // (self:89, users:[Id { idx: 90 }])
    %90 = fcmp ult, f64 1, f64 %89 // (self:90, users:[Id { idx: 91 }])
    br i1 %90, %label.5, %label.6 // (self:91, users:[])
label.5:	// pred(4), succ(8,9), def(92,93), in(8,5,2,7,6), out(8,2,7,6)
    %92 = load f64* %5 // (self:92, users:[Id { idx: 93 }])
    %93 = fcmp ult, f64 1, f64 %92 // (self:93, users:[Id { idx: 94 }])
    br i1 %93, %label.8, %label.9 // (self:94, users:[])
label.6:	// pred(4), succ(10,11), def(100,101), in(8,5,2,7,4,6), out(8,5,2,7,6)
    %100 = load f64* %4 // (self:100, users:[Id { idx: 101 }])
    %101 = fcmp ult, f64 %100, f64 1 // (self:101, users:[Id { idx: 102 }])
    br i1 %101, %label.10, %label.11 // (self:102, users:[])
label.7:	// pred(9,11), succ(14,15), def(112,120,114,119,116,113,115), in(8,2,7,6), out(8,2,7,6)
    %112 = getelementptr (ty:25)* %arg.3, i32 0, i32 1 // (self:112, users:[Id { idx: 113 }])
    %113 = load struct {f64, f64, f64}** %112 // (self:113, users:[Id { idx: 114 }])
    %114 = getelementptr struct {f64, f64, f64}* %113, i32 0, i32 2 // (self:114, users:[Id { idx: 115 }])
    %115 = load f64* %114 // (self:115, users:[Id { idx: 116 }])
    %116 = call f64 cilk.fabs.f64, f64 %115 // (self:116, users:[Id { idx: 117 }])
    store f64 %116, f64* %7 // (self:117, users:[])
    store f64 0, f64* %8 // (self:118, users:[])
    %119 = load f64* %7 // (self:119, users:[Id { idx: 120 }])
    %120 = fcmp ult, f64 %119, f64 25 // (self:120, users:[Id { idx: 121 }])
    br i1 %120, %label.14, %label.15 // (self:121, users:[])
label.8:	// pred(5), succ(9), def(96,95), in(8,2,7,6), out(8,2,7,6)
    %95 = load f64* %6 // (self:95, users:[Id { idx: 96 }])
    %96 = mul f64 %95, f64 0.5 // (self:96, users:[Id { idx: 97 }])
    store f64 %96, f64* %6 // (self:97, users:[])
    br %label.9 // (self:98, users:[])
label.9:	// pred(5,8), succ(7), def(), in(8,2,7,6), out(8,2,7,6)
    br %label.7 // (self:99, users:[])
label.10:	// pred(6), succ(12,13), def(104,103), in(8,5,2,7,6), out(8,2,7,6)
    %103 = load f64* %5 // (self:103, users:[Id { idx: 104 }])
    %104 = fcmp ult, f64 %103, f64 1 // (self:104, users:[Id { idx: 105 }])
    br i1 %104, %label.12, %label.13 // (self:105, users:[])
label.11:	// pred(6,13), succ(7), def(), in(8,2,7,6), out(8,2,7,6)
    br %label.7 // (self:111, users:[])
label.12:	// pred(10), succ(13), def(106,107), in(8,2,7,6), out(8,2,7,6)
    %106 = load f64* %6 // (self:106, users:[Id { idx: 107 }])
    %107 = mul f64 %106, f64 0.5 // (self:107, users:[Id { idx: 108 }])
    store f64 %107, f64* %6 // (self:108, users:[])
    br %label.13 // (self:109, users:[])
label.13:	// pred(10,12), succ(11), def(), in(8,2,7,6), out(8,2,7,6)
    br %label.11 // (self:110, users:[])
label.14:	// pred(7), succ(15), def(124,122,123), in(8,2,7,6), out(8,6,2)
    %122 = load f64* %7 // (self:122, users:[Id { idx: 123 }])
    %123 = mul f64 %122, f64 0.04 // (self:123, users:[Id { idx: 124 }])
    %124 = sub f64 1, f64 %123 // (self:124, users:[Id { idx: 125 }])
    store f64 %124, f64* %8 // (self:125, users:[])
    br %label.15 // (self:126, users:[])
label.15:	// pred(7,14), succ(), def(144,141,138,135,132,129,143,140,131,128,145,139,136,133,130,127), in(8,6,2), out()
    %127 = getelementptr (ty:25)* %arg.3, i32 0, i32 3 // (self:127, users:[Id { idx: 134 }])
    %128 = getelementptr (ty:14)* %arg.0, i32 0, i32 2 // (self:128, users:[Id { idx: 129 }])
    %129 = load struct {f64, f64, f64}** %128 // (self:129, users:[Id { idx: 133 }])
    %130 = load f64* %6 // (self:130, users:[Id { idx: 132 }])
    %131 = load f64* %8 // (self:131, users:[Id { idx: 132 }])
    %132 = mul f64 %130, f64 %131 // (self:132, users:[Id { idx: 133 }])
    %133 = call struct {f64, f64, f64}* Vec_mul, struct {f64, f64, f64}* %129, f64 %132 // (self:133, users:[Id { idx: 134 }])
    store struct {f64, f64, f64}* %133, struct {f64, f64, f64}** %127 // (self:134, users:[])
    %135 = getelementptr (ty:25)* %arg.3, i32 0, i32 4 // (self:135, users:[Id { idx: 137 }])
    %136 = load f64* %2 // (self:136, users:[Id { idx: 137 }])
    store f64 %136, f64* %135 // (self:137, users:[])
    %138 = getelementptr (ty:25)* %arg.3, i32 0, i32 0 // (self:138, users:[Id { idx: 142 }])
    %139 = getelementptr (ty:25)* %arg.3, i32 0, i32 0 // (self:139, users:[Id { idx: 140 }])
    %140 = load i32* %139 // (self:140, users:[Id { idx: 141 }])
    %141 = add i32 %140, i32 1 // (self:141, users:[Id { idx: 142 }])
    store i32 %141, i32* %138 // (self:142, users:[])
    %143 = getelementptr (ty:25)* %arg.3, i32 0, i32 5 // (self:143, users:[Id { idx: 146 }])
    %144 = getelementptr (ty:23)* %arg.2, i32 0, i32 1 // (self:144, users:[Id { idx: 145 }])
    %145 = load struct {f64, f64, f64}** %144 // (self:145, users:[Id { idx: 146 }])
    store struct {f64, f64, f64}* %145, struct {f64, f64, f64}** %143 // (self:146, users:[])
    ret i32 0 // (self:147, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 Env_intersect(struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*) {
label.0:	// pred(), succ(), def(4,19,16,10,15,12,1,6,18,9,14,3,0,5,17,11,8,13,2,7), in(), out()
    %0 = getelementptr (ty:31)* %arg.0, i32 0, i32 1 // (self:0, users:[Id { idx: 1 }])
    %1 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %0 // (self:1, users:[Id { idx: 4 }])
    %2 = getelementptr (ty:31)* %arg.0, i32 0, i32 0 // (self:2, users:[Id { idx: 3 }])
    %3 = load struct {f64, f64, f64}** %2 // (self:3, users:[Id { idx: 4 }])
    %4 = call i32 Sphere_intersect, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %1, struct {f64, f64, f64}* %3, (ty:23)* %arg.1, (ty:25)* %arg.2 // (self:4, users:[])
    %5 = getelementptr (ty:31)* %arg.0, i32 0, i32 2 // (self:5, users:[Id { idx: 6 }])
    %6 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:6, users:[Id { idx: 9 }])
    %7 = getelementptr (ty:31)* %arg.0, i32 0, i32 0 // (self:7, users:[Id { idx: 8 }])
    %8 = load struct {f64, f64, f64}** %7 // (self:8, users:[Id { idx: 9 }])
    %9 = call i32 Sphere_intersect, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %6, struct {f64, f64, f64}* %8, (ty:23)* %arg.1, (ty:25)* %arg.2 // (self:9, users:[])
    %10 = getelementptr (ty:31)* %arg.0, i32 0, i32 3 // (self:10, users:[Id { idx: 11 }])
    %11 = load struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %10 // (self:11, users:[Id { idx: 14 }])
    %12 = getelementptr (ty:31)* %arg.0, i32 0, i32 0 // (self:12, users:[Id { idx: 13 }])
    %13 = load struct {f64, f64, f64}** %12 // (self:13, users:[Id { idx: 14 }])
    %14 = call i32 Sphere_intersect, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %11, struct {f64, f64, f64}* %13, (ty:23)* %arg.1, (ty:25)* %arg.2 // (self:14, users:[])
    %15 = getelementptr (ty:31)* %arg.0, i32 0, i32 4 // (self:15, users:[Id { idx: 16 }])
    %16 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %15 // (self:16, users:[Id { idx: 19 }])
    %17 = getelementptr (ty:31)* %arg.0, i32 0, i32 0 // (self:17, users:[Id { idx: 18 }])
    %18 = load struct {f64, f64, f64}** %17 // (self:18, users:[Id { idx: 19 }])
    %19 = call i32 Plane_intersect, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %16, struct {f64, f64, f64}* %18, (ty:23)* %arg.1, (ty:25)* %arg.2 // (self:19, users:[])
    ret i32 0 // (self:20, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* Env_new() {
label.0:	// pred(), succ(), def(5,15,12,9,22,19,16,29,26,33,3,10,23,17,30,24,7,4,1,14,11,8,21,18,31,28,25,35,32), in(0), out()
    %0 = alloca struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* // (self:0, users:[Id { idx: 2 }, Id { idx: 3 }, Id { idx: 7 }, Id { idx: 14 }, Id { idx: 21 }, Id { idx: 28 }, Id { idx: 35 }])
    %1 = call i64* cilk.malloc.i32, i32 128 // (self:1, users:[Id { idx: 2 }])
    store i64* %1, struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:2, users:[])
    %3 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:3, users:[Id { idx: 4 }])
    %4 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %3, i32 0, i32 0 // (self:4, users:[Id { idx: 6 }])
    %5 = call struct {f64, f64, f64}* Vec_new, f64 0.577, f64 0.577, f64 0.577 // (self:5, users:[Id { idx: 6 }])
    store struct {f64, f64, f64}* %5, struct {f64, f64, f64}** %4 // (self:6, users:[])
    %7 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:7, users:[Id { idx: 8 }])
    %8 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %7, i32 0, i32 1 // (self:8, users:[Id { idx: 13 }])
    %9 = call f64 cilk.sin.f64, f64 0 // (self:9, users:[Id { idx: 10 }])
    %10 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 -0.5, f64 %9 // (self:10, users:[Id { idx: 12 }])
    %11 = call struct {f64, f64, f64}* Vec_new, f64 1, f64 0, f64 0 // (self:11, users:[Id { idx: 12 }])
    %12 = call struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Sphere_new, f64 0.5, struct {f64, f64, f64}* %10, struct {f64, f64, f64}* %11 // (self:12, users:[Id { idx: 13 }])
    store struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %12, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %8 // (self:13, users:[])
    %14 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:14, users:[Id { idx: 15 }])
    %15 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %14, i32 0, i32 2 // (self:15, users:[Id { idx: 20 }])
    %16 = call f64 cilk.cos.f64, f64 6.66 // (self:16, users:[Id { idx: 17 }])
    %17 = call struct {f64, f64, f64}* Vec_new, f64 2, f64 0, f64 %16 // (self:17, users:[Id { idx: 19 }])
    %18 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 1, f64 0 // (self:18, users:[Id { idx: 19 }])
    %19 = call struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Sphere_new, f64 1, struct {f64, f64, f64}* %17, struct {f64, f64, f64}* %18 // (self:19, users:[Id { idx: 20 }])
    store struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %19, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %15 // (self:20, users:[])
    %21 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:21, users:[Id { idx: 22 }])
    %22 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %21, i32 0, i32 3 // (self:22, users:[Id { idx: 27 }])
    %23 = call f64 cilk.cos.f64, f64 3.33 // (self:23, users:[Id { idx: 24 }])
    %24 = call struct {f64, f64, f64}* Vec_new, f64 -2, f64 0.5, f64 %23 // (self:24, users:[Id { idx: 26 }])
    %25 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 0, f64 1 // (self:25, users:[Id { idx: 26 }])
    %26 = call struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Sphere_new, f64 1.5, struct {f64, f64, f64}* %24, struct {f64, f64, f64}* %25 // (self:26, users:[Id { idx: 27 }])
    store struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %26, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %22 // (self:27, users:[])
    %28 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:28, users:[Id { idx: 29 }])
    %29 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %28, i32 0, i32 4 // (self:29, users:[Id { idx: 34 }])
    %30 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 -1, f64 0 // (self:30, users:[Id { idx: 33 }])
    %31 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 1, f64 0 // (self:31, users:[Id { idx: 33 }])
    %32 = call struct {f64, f64, f64}* Vec_new, f64 1, f64 1, f64 1 // (self:32, users:[Id { idx: 33 }])
    %33 = call struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Plane_new, struct {f64, f64, f64}* %30, struct {f64, f64, f64}* %31, struct {f64, f64, f64}* %32 // (self:33, users:[Id { idx: 34 }])
    store struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %33, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %29 // (self:34, users:[])
    %35 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:35, users:[Id { idx: 36 }])
    ret struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %35 // (self:36, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 color_of(f64) {
label.0:	// pred(), succ(1,2), def(7,2,1,4,3,6), in(0), out(0)
    %0 = alloca i32 // (self:0, users:[Id { idx: 5 }, Id { idx: 6 }, Id { idx: 10 }])
    %1 = call f64 cilk.i32_to_f64.i32, i32 256 // (self:1, users:[Id { idx: 3 }])
    %2 = call f64 clamp, f64 %arg.0, f64 0, f64 1 // (self:2, users:[Id { idx: 3 }])
    %3 = mul f64 %1, f64 %2 // (self:3, users:[Id { idx: 4 }])
    %4 = call i32 cilk.f64_to_i32.f64, f64 %3 // (self:4, users:[Id { idx: 5 }])
    store i32 %4, i32* %0 // (self:5, users:[])
    %6 = load i32* %0 // (self:6, users:[Id { idx: 7 }])
    %7 = icmp eq, i32 %6, i32 256 // (self:7, users:[Id { idx: 8 }])
    br i1 %7, %label.1, %label.2 // (self:8, users:[])
label.1:	// pred(0), succ(), def(), in(), out()
    ret i32 255 // (self:9, users:[])
label.2:	// pred(0), succ(), def(10), in(0), out()
    %10 = load i32* %0 // (self:10, users:[Id { idx: 11 }])
    ret i32 %10 // (self:11, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 print_col(struct {f64, f64, f64}*) {
label.0:	// pred(), succ(), def(), in(), out()
    ret i32 0 // (self:0, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs
/home/unsigned/work/cilk/src/codegen/x64/dag/convert.rs: dump function: 
define i32 main() {
label.0:	// pred(), succ(1), def(11), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %0 = alloca struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* // (self:0, users:[Id { idx: 12 }, Id { idx: 49 }, Id { idx: 90 }])
    %1 = alloca i32 // (self:1, users:[Id { idx: 13 }, Id { idx: 15 }, Id { idx: 29 }, Id { idx: 144 }, Id { idx: 146 }])
    %2 = alloca i32 // (self:2, users:[Id { idx: 18 }, Id { idx: 20 }, Id { idx: 23 }, Id { idx: 140 }, Id { idx: 142 }])
    %3 = alloca f64 // (self:3, users:[Id { idx: 28 }, Id { idx: 37 }])
    %4 = alloca f64 // (self:4, users:[Id { idx: 35 }, Id { idx: 38 }])
    %5 = alloca struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* // (self:5, users:[Id { idx: 42 }, Id { idx: 50 }, Id { idx: 122 }, Id { idx: 127 }, Id { idx: 132 }])
    %6 = alloca struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* // (self:6, users:[Id { idx: 48 }, Id { idx: 51 }, Id { idx: 53 }, Id { idx: 58 }, Id { idx: 63 }, Id { idx: 73 }, Id { idx: 76 }, Id { idx: 81 }, Id { idx: 84 }, Id { idx: 92 }])
    %7 = alloca struct {f64, f64, f64}* // (self:7, users:[Id { idx: 61 }, Id { idx: 100 }, Id { idx: 107 }, Id { idx: 119 }])
    %8 = alloca struct {f64, f64, f64}* // (self:8, users:[Id { idx: 67 }, Id { idx: 101 }, Id { idx: 108 }, Id { idx: 113 }])
    %9 = alloca i32 // (self:9, users:[Id { idx: 68 }, Id { idx: 70 }, Id { idx: 94 }, Id { idx: 115 }, Id { idx: 117 }])
    %10 = alloca struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* // (self:10, users:[Id { idx: 89 }, Id { idx: 91 }])
    %11 = call struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* Env_new // (self:11, users:[Id { idx: 12 }])
    store struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %11, struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:12, users:[])
    store i32 0, i32* %1 // (self:13, users:[])
    br %label.1 // (self:14, users:[])
label.1:	// pred(0,6), succ(2,3), def(15,16), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %15 = load i32* %1 // (self:15, users:[Id { idx: 16 }])
    %16 = icmp lt, i32 %15, i32 12 // (self:16, users:[Id { idx: 17 }])
    br i1 %16, %label.2, %label.3 // (self:17, users:[])
label.2:	// pred(1), succ(4), def(), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    store i32 0, i32* %2 // (self:18, users:[])
    br %label.4 // (self:19, users:[])
label.3:	// pred(1), succ(), def(), in(), out()
    ret i32 0 // (self:148, users:[])
label.4:	// pred(2,9), succ(5,6), def(20,21), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %20 = load i32* %2 // (self:20, users:[Id { idx: 21 }])
    %21 = icmp lt, i32 %20, i32 12 // (self:21, users:[Id { idx: 22 }])
    br i1 %21, %label.5, %label.6 // (self:22, users:[])
label.5:	// pred(4), succ(7,8), def(54,24,29,30,41,47,32,37,38,49,50,55,25,26,31,43,44,33,34,39,56,51,52,27,23,40,45,46,36,53), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %23 = load i32* %2 // (self:23, users:[Id { idx: 24 }])
    %24 = call f64 cilk.i32_to_f64.i32, i32 %23 // (self:24, users:[Id { idx: 25 }])
    %25 = div f64 %24, f64 12 // (self:25, users:[Id { idx: 26 }])
    %26 = div f64 %25, f64 20 // (self:26, users:[Id { idx: 27 }])
    %27 = sub f64 %26, f64 1 // (self:27, users:[Id { idx: 28 }])
    store f64 %27, f64* %3 // (self:28, users:[])
    %29 = load i32* %1 // (self:29, users:[Id { idx: 30 }])
    %30 = sub i32 12, i32 %29 // (self:30, users:[Id { idx: 31 }])
    %31 = call f64 cilk.i32_to_f64.i32, i32 %30 // (self:31, users:[Id { idx: 32 }])
    %32 = div f64 %31, f64 12 // (self:32, users:[Id { idx: 33 }])
    %33 = div f64 %32, f64 2 // (self:33, users:[Id { idx: 34 }])
    %34 = sub f64 %33, f64 1 // (self:34, users:[Id { idx: 35 }])
    store f64 %34, f64* %4 // (self:35, users:[])
    %36 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 2, f64 6 // (self:36, users:[Id { idx: 41 }])
    %37 = load f64* %3 // (self:37, users:[Id { idx: 39 }])
    %38 = load f64* %4 // (self:38, users:[Id { idx: 39 }])
    %39 = call struct {f64, f64, f64}* Vec_new, f64 %37, f64 %38, f64 -1 // (self:39, users:[Id { idx: 40 }])
    %40 = call struct {f64, f64, f64}* Vec_normalize, struct {f64, f64, f64}* %39 // (self:40, users:[Id { idx: 41 }])
    %41 = call struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Ray_new, struct {f64, f64, f64}* %36, struct {f64, f64, f64}* %40 // (self:41, users:[Id { idx: 42 }])
    store struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %41, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:42, users:[])
    %43 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 0, f64 0 // (self:43, users:[Id { idx: 47 }])
    %44 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 0, f64 0 // (self:44, users:[Id { idx: 47 }])
    %45 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 0, f64 0 // (self:45, users:[Id { idx: 47 }])
    %46 = call struct {f64, f64, f64}* Vec_new, f64 0, f64 0, f64 0 // (self:46, users:[Id { idx: 47 }])
    %47 = call struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* Isect_new, i32 0, struct {f64, f64, f64}* %43, struct {f64, f64, f64}* %44, struct {f64, f64, f64}* %45, f64 10000000, struct {f64, f64, f64}* %46 // (self:47, users:[Id { idx: 48 }])
    store struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %47, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:48, users:[])
    %49 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:49, users:[Id { idx: 52 }])
    %50 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:50, users:[Id { idx: 52 }])
    %51 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:51, users:[Id { idx: 52 }])
    %52 = call i32 Env_intersect, struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %49, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %50, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %51 // (self:52, users:[])
    %53 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:53, users:[Id { idx: 54 }])
    %54 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %53, i32 0, i32 0 // (self:54, users:[Id { idx: 55 }])
    %55 = load i32* %54 // (self:55, users:[Id { idx: 56 }])
    %56 = icmp lt, i32 0, i32 %55 // (self:56, users:[Id { idx: 57 }])
    br i1 %56, %label.7, %label.8 // (self:57, users:[])
label.6:	// pred(4), succ(1), def(144,145), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %144 = load i32* %1 // (self:144, users:[Id { idx: 145 }])
    %145 = add i32 %144, i32 1 // (self:145, users:[Id { idx: 146 }])
    store i32 %145, i32* %1 // (self:146, users:[])
    br %label.1 // (self:147, users:[])
label.7:	// pred(5), succ(10), def(59,60,65,66,62,58,63,64), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %58 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:58, users:[Id { idx: 59 }])
    %59 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %58, i32 0, i32 3 // (self:59, users:[Id { idx: 60 }])
    %60 = load struct {f64, f64, f64}** %59 // (self:60, users:[Id { idx: 61 }])
    store struct {f64, f64, f64}* %60, struct {f64, f64, f64}** %7 // (self:61, users:[])
    %62 = call struct {f64, f64, f64}* Vec_new, f64 1, f64 1, f64 1 // (self:62, users:[Id { idx: 66 }])
    %63 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:63, users:[Id { idx: 64 }])
    %64 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %63, i32 0, i32 3 // (self:64, users:[Id { idx: 65 }])
    %65 = load struct {f64, f64, f64}** %64 // (self:65, users:[Id { idx: 66 }])
    %66 = call struct {f64, f64, f64}* Vec_multi, struct {f64, f64, f64}* %62, struct {f64, f64, f64}* %65 // (self:66, users:[Id { idx: 67 }])
    store struct {f64, f64, f64}* %66, struct {f64, f64, f64}** %8 // (self:67, users:[])
    store i32 1, i32* %9 // (self:68, users:[])
    br %label.10 // (self:69, users:[])
label.8:	// pred(5), succ(9), def(129,130,135,125,126,137,138,128,133,134,123,124,136,131,132,122,127), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %122 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:122, users:[Id { idx: 123 }])
    %123 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %122, i32 0, i32 1 // (self:123, users:[Id { idx: 124 }])
    %124 = load struct {f64, f64, f64}** %123 // (self:124, users:[Id { idx: 125 }])
    %125 = getelementptr struct {f64, f64, f64}* %124, i32 0, i32 1 // (self:125, users:[Id { idx: 126 }])
    %126 = load f64* %125 // (self:126, users:[Id { idx: 137 }])
    %127 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:127, users:[Id { idx: 128 }])
    %128 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %127, i32 0, i32 1 // (self:128, users:[Id { idx: 129 }])
    %129 = load struct {f64, f64, f64}** %128 // (self:129, users:[Id { idx: 130 }])
    %130 = getelementptr struct {f64, f64, f64}* %129, i32 0, i32 1 // (self:130, users:[Id { idx: 131 }])
    %131 = load f64* %130 // (self:131, users:[Id { idx: 137 }])
    %132 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %5 // (self:132, users:[Id { idx: 133 }])
    %133 = getelementptr struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %132, i32 0, i32 1 // (self:133, users:[Id { idx: 134 }])
    %134 = load struct {f64, f64, f64}** %133 // (self:134, users:[Id { idx: 135 }])
    %135 = getelementptr struct {f64, f64, f64}* %134, i32 0, i32 1 // (self:135, users:[Id { idx: 136 }])
    %136 = load f64* %135 // (self:136, users:[Id { idx: 137 }])
    %137 = call struct {f64, f64, f64}* Vec_new, f64 %126, f64 %131, f64 %136 // (self:137, users:[Id { idx: 138 }])
    %138 = call i32 print_col, struct {f64, f64, f64}* %137 // (self:138, users:[])
    br %label.9 // (self:139, users:[])
label.9:	// pred(12,8), succ(4), def(140,141), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %140 = load i32* %2 // (self:140, users:[Id { idx: 141 }])
    %141 = add i32 %140, i32 1 // (self:141, users:[Id { idx: 142 }])
    store i32 %141, i32* %2 // (self:142, users:[])
    br %label.4 // (self:143, users:[])
label.10:	// pred(7,14), succ(11,12), def(70,71), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %70 = load i32* %9 // (self:70, users:[Id { idx: 71 }])
    %71 = icmp lt, i32 %70, i32 4 // (self:71, users:[Id { idx: 72 }])
    br i1 %71, %label.11, %label.12 // (self:72, users:[])
label.11:	// pred(10), succ(13,14), def(86,75,76,97,98,88,93,94,83,84,73,74,79,96,91,92,81,82,87,77,78,90,95,80,85), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %73 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:73, users:[Id { idx: 74 }])
    %74 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %73, i32 0, i32 1 // (self:74, users:[Id { idx: 75 }])
    %75 = load struct {f64, f64, f64}** %74 // (self:75, users:[Id { idx: 80 }])
    %76 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:76, users:[Id { idx: 77 }])
    %77 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %76, i32 0, i32 2 // (self:77, users:[Id { idx: 78 }])
    %78 = load struct {f64, f64, f64}** %77 // (self:78, users:[Id { idx: 79 }])
    %79 = call struct {f64, f64, f64}* Vec_mul, struct {f64, f64, f64}* %78, f64 0.0001 // (self:79, users:[Id { idx: 80 }])
    %80 = call struct {f64, f64, f64}* Vec_add, struct {f64, f64, f64}* %75, struct {f64, f64, f64}* %79 // (self:80, users:[Id { idx: 88 }])
    %81 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:81, users:[Id { idx: 82 }])
    %82 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %81, i32 0, i32 5 // (self:82, users:[Id { idx: 83 }])
    %83 = load struct {f64, f64, f64}** %82 // (self:83, users:[Id { idx: 87 }])
    %84 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:84, users:[Id { idx: 85 }])
    %85 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %84, i32 0, i32 2 // (self:85, users:[Id { idx: 86 }])
    %86 = load struct {f64, f64, f64}** %85 // (self:86, users:[Id { idx: 87 }])
    %87 = call struct {f64, f64, f64}* Vec_reflect, struct {f64, f64, f64}* %83, struct {f64, f64, f64}* %86 // (self:87, users:[Id { idx: 88 }])
    %88 = call struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* Ray_new, struct {f64, f64, f64}* %80, struct {f64, f64, f64}* %87 // (self:88, users:[Id { idx: 89 }])
    store struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %88, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %10 // (self:89, users:[])
    %90 = load struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}** %0 // (self:90, users:[Id { idx: 93 }])
    %91 = load struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}** %10 // (self:91, users:[Id { idx: 93 }])
    %92 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:92, users:[Id { idx: 93 }])
    %93 = call i32 Env_intersect, struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* %90, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* %91, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %92 // (self:93, users:[])
    %94 = load i32* %9 // (self:94, users:[Id { idx: 98 }])
    %95 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:95, users:[Id { idx: 96 }])
    %96 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %95, i32 0, i32 0 // (self:96, users:[Id { idx: 97 }])
    %97 = load i32* %96 // (self:97, users:[Id { idx: 98 }])
    %98 = icmp lt, i32 %94, i32 %97 // (self:98, users:[Id { idx: 99 }])
    br i1 %98, %label.13, %label.14 // (self:99, users:[])
label.12:	// pred(10), succ(9), def(119,120), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %119 = load struct {f64, f64, f64}** %7 // (self:119, users:[Id { idx: 120 }])
    %120 = call i32 print_col, struct {f64, f64, f64}* %119 // (self:120, users:[])
    br %label.9 // (self:121, users:[])
label.13:	// pred(11), succ(14), def(102,108,103,104,109,110,100,105,106,111,112,101), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %100 = load struct {f64, f64, f64}** %7 // (self:100, users:[Id { idx: 106 }])
    %101 = load struct {f64, f64, f64}** %8 // (self:101, users:[Id { idx: 105 }])
    %102 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:102, users:[Id { idx: 103 }])
    %103 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %102, i32 0, i32 3 // (self:103, users:[Id { idx: 104 }])
    %104 = load struct {f64, f64, f64}** %103 // (self:104, users:[Id { idx: 105 }])
    %105 = call struct {f64, f64, f64}* Vec_multi, struct {f64, f64, f64}* %101, struct {f64, f64, f64}* %104 // (self:105, users:[Id { idx: 106 }])
    %106 = call struct {f64, f64, f64}* Vec_add, struct {f64, f64, f64}* %100, struct {f64, f64, f64}* %105 // (self:106, users:[Id { idx: 107 }])
    store struct {f64, f64, f64}* %106, struct {f64, f64, f64}** %7 // (self:107, users:[])
    %108 = load struct {f64, f64, f64}** %8 // (self:108, users:[Id { idx: 112 }])
    %109 = load struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}** %6 // (self:109, users:[Id { idx: 110 }])
    %110 = getelementptr struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* %109, i32 0, i32 3 // (self:110, users:[Id { idx: 111 }])
    %111 = load struct {f64, f64, f64}** %110 // (self:111, users:[Id { idx: 112 }])
    %112 = call struct {f64, f64, f64}* Vec_multi, struct {f64, f64, f64}* %108, struct {f64, f64, f64}* %111 // (self:112, users:[Id { idx: 113 }])
    store struct {f64, f64, f64}* %112, struct {f64, f64, f64}** %8 // (self:113, users:[])
    br %label.14 // (self:114, users:[])
label.14:	// pred(11,13), succ(10), def(115,116), in(6,1,2,7,8,3,4,9,10,0,5), out(6,1,2,7,8,3,4,9,10,0,5)
    %115 = load i32* %9 // (self:115, users:[Id { idx: 116 }])
    %116 = add i32 %115, i32 1 // (self:116, users:[Id { idx: 117 }])
    store i32 %116, i32* %9 // (self:117, users:[])
    br %label.10 // (self:118, users:[])
}
Debug at /home/unsigned/work/cilk/src/codegen/x64/exec/jit.rs
MachineModule (name: minilang)
MachineFunction(name: cilk.println.i32, ty: void (i32, )):
MachineFunction(name: cilk.printch.i32, ty: void (i32, )):
MachineFunction(name: cilk.println.f64, ty: void (f64, )):
MachineFunction(name: cilk.sin.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.cos.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.sqrt.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.floor.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.fabs.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.i32_to_f64.i32, ty: f64 (i32, )):
MachineFunction(name: cilk.f64_to_i32.f64, ty: i32 (f64, )):
MachineFunction(name: cilk.malloc.i32, ty: i64* (i32, )):
MachineFunction(name: clamp, ty: f64 (f64, f64, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }] } })
 0  ( 0  ): %vreg1 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 2  ( 2  ): UCOMISDrr %vreg1, %vreg2
 3  ( 3  ): JB BB#1
 4  ( 4  ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }] } })
 5  ( 5  ): %vreg3 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 6  ( 6  ): %xmm0 = MOVSDrr %vreg3
 7  ( 7  ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }] } })
 8  ( 8  ): %vreg4 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 9  ( 9  ): %vreg5 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 10 ( 10 ): UCOMISDrr %vreg4, %vreg5
 11 ( 11 ): JB BB#3
 12 ( 12 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }] } })
 13 ( 13 ): %vreg6 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 14 ( 14 ): %xmm0 = MOVSDrr %vreg6
 15 ( 15 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }] } })
 16 ( 16 ): %vreg7 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 17 ( 17 ): %xmm0 = MOVSDrr %vreg7
 18 ( 18 ): RET 
MachineFunction(name: Vec_new, ty: struct {f64, f64, f64}* (f64, f64, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 8  ( 8  ): %vreg4 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 9  ( 9  ): MOVSDmr Base(%vreg3), %vreg4
 10 ( 10 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 11 ( 11 ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 12 ( 12 ): %vreg7 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 13 ( 13 ): MOVSDmr Base(%vreg6), %vreg7
 14 ( 14 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 15 ( 15 ): %vreg9 = ADDr64i32 %vreg8, i32 16 (tie:%vreg9->%vreg8,)
 16 ( 16 ): %vreg10 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 17 ( 17 ): MOVSDmr Base(%vreg9), %vreg10
 18 ( 18 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 19 ( 19 ): %rax = MOVrr64 %vreg11
 20 ( 20 ): RET 
MachineFunction(name: Vec_add, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 3  ( 3  ): %vreg4 = MOVSDrm Base(%vreg3)
 4  ( 4  ): %vreg5 = ADDSDrr %vreg2, %vreg4 (tie:%vreg5->%vreg2,)
 5  ( 5  ): %vreg6 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 6  ): %vreg7 = ADDr64i32 %vreg6, i32 8 (tie:%vreg7->%vreg6,)
 7  ( 7  ): %vreg8 = MOVSDrm Base(%vreg7)
 8  ( 8  ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 9  ( 9  ): %vreg10 = ADDr64i32 %vreg9, i32 8 (tie:%vreg10->%vreg9,)
 10 ( 10 ): %vreg11 = MOVSDrm Base(%vreg10)
 11 ( 11 ): %vreg12 = ADDSDrr %vreg8, %vreg11 (tie:%vreg12->%vreg8,)
 12 ( 12 ): %vreg13 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 13 ( 13 ): %vreg14 = ADDr64i32 %vreg13, i32 16 (tie:%vreg14->%vreg13,)
 14 ( 14 ): %vreg15 = MOVSDrm Base(%vreg14)
 15 ( 15 ): %vreg16 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 16 ( 16 ): %vreg17 = ADDr64i32 %vreg16, i32 16 (tie:%vreg17->%vreg16,)
 17 ( 17 ): %vreg18 = MOVSDrm Base(%vreg17)
 18 ( 18 ): %vreg19 = ADDSDrr %vreg15, %vreg18 (tie:%vreg19->%vreg15,)
 19 ( 19 ): %xmm0 = MOVSDrr %vreg5
 20 ( 20 ): %xmm1 = MOVSDrr %vreg12
 21 ( 21 ): %xmm2 = MOVSDrr %vreg19
 22 ( 22 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 24 ( 24 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 25 ( 25 ): %vreg20 = Copy %rax
 26 ( 26 ): %rax = MOVrr64 %vreg20
 27 ( 27 ): RET 
MachineFunction(name: Vec_sub, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 3  ( 3  ): %vreg4 = MOVSDrm Base(%vreg3)
 4  ( 4  ): %vreg5 = SUBSDrr %vreg2, %vreg4 (tie:%vreg5->%vreg2,)
 5  ( 5  ): %vreg6 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 6  ): %vreg7 = ADDr64i32 %vreg6, i32 8 (tie:%vreg7->%vreg6,)
 7  ( 7  ): %vreg8 = MOVSDrm Base(%vreg7)
 8  ( 8  ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 9  ( 9  ): %vreg10 = ADDr64i32 %vreg9, i32 8 (tie:%vreg10->%vreg9,)
 10 ( 10 ): %vreg11 = MOVSDrm Base(%vreg10)
 11 ( 11 ): %vreg12 = SUBSDrr %vreg8, %vreg11 (tie:%vreg12->%vreg8,)
 12 ( 12 ): %vreg13 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 13 ( 13 ): %vreg14 = ADDr64i32 %vreg13, i32 16 (tie:%vreg14->%vreg13,)
 14 ( 14 ): %vreg15 = MOVSDrm Base(%vreg14)
 15 ( 15 ): %vreg16 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 16 ( 16 ): %vreg17 = ADDr64i32 %vreg16, i32 16 (tie:%vreg17->%vreg16,)
 17 ( 17 ): %vreg18 = MOVSDrm Base(%vreg17)
 18 ( 18 ): %vreg19 = SUBSDrr %vreg15, %vreg18 (tie:%vreg19->%vreg15,)
 19 ( 19 ): %xmm0 = MOVSDrr %vreg5
 20 ( 20 ): %xmm1 = MOVSDrr %vreg12
 21 ( 21 ): %xmm2 = MOVSDrr %vreg19
 22 ( 22 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 24 ( 24 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 25 ( 25 ): %vreg20 = Copy %rax
 26 ( 26 ): %rax = MOVrr64 %vreg20
 27 ( 27 ): RET 
MachineFunction(name: Vec_mul, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %vreg3 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 3  ( 3  ): %vreg4 = MULSDrr %vreg2, %vreg3 (tie:%vreg4->%vreg2,)
 4  ( 4  ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 5  ( 5  ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 6  ( 6  ): %vreg7 = MOVSDrm Base(%vreg6)
 7  ( 7  ): %vreg8 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 8  ( 8  ): %vreg9 = MULSDrr %vreg7, %vreg8 (tie:%vreg9->%vreg7,)
 9  ( 9  ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 10 ( 10 ): %vreg11 = ADDr64i32 %vreg10, i32 16 (tie:%vreg11->%vreg10,)
 11 ( 11 ): %vreg12 = MOVSDrm Base(%vreg11)
 12 ( 12 ): %vreg13 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 13 ( 13 ): %vreg14 = MULSDrr %vreg12, %vreg13 (tie:%vreg14->%vreg12,)
 14 ( 14 ): %xmm0 = MOVSDrr %vreg4
 15 ( 15 ): %xmm1 = MOVSDrr %vreg9
 16 ( 16 ): %xmm2 = MOVSDrr %vreg14
 17 ( 17 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 18 ( 18 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 19 ( 19 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 20 ( 20 ): %vreg15 = Copy %rax
 21 ( 21 ): %rax = MOVrr64 %vreg15
 22 ( 22 ): RET 
MachineFunction(name: Vec_multi, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 3  ( 3  ): %vreg4 = MOVSDrm Base(%vreg3)
 4  ( 4  ): %vreg5 = ADDSDrr %vreg2, %vreg4 (tie:%vreg5->%vreg2,)
 5  ( 5  ): %vreg6 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 6  ): %vreg7 = ADDr64i32 %vreg6, i32 8 (tie:%vreg7->%vreg6,)
 7  ( 7  ): %vreg8 = MOVSDrm Base(%vreg7)
 8  ( 8  ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 9  ( 9  ): %vreg10 = ADDr64i32 %vreg9, i32 8 (tie:%vreg10->%vreg9,)
 10 ( 10 ): %vreg11 = MOVSDrm Base(%vreg10)
 11 ( 11 ): %vreg12 = ADDSDrr %vreg8, %vreg11 (tie:%vreg12->%vreg8,)
 12 ( 12 ): %vreg13 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 13 ( 13 ): %vreg14 = ADDr64i32 %vreg13, i32 16 (tie:%vreg14->%vreg13,)
 14 ( 14 ): %vreg15 = MOVSDrm Base(%vreg14)
 15 ( 15 ): %vreg16 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 16 ( 16 ): %vreg17 = ADDr64i32 %vreg16, i32 16 (tie:%vreg17->%vreg16,)
 17 ( 17 ): %vreg18 = MOVSDrm Base(%vreg17)
 18 ( 18 ): %vreg19 = ADDSDrr %vreg15, %vreg18 (tie:%vreg19->%vreg15,)
 19 ( 19 ): %xmm0 = MOVSDrr %vreg5
 20 ( 20 ): %xmm1 = MOVSDrr %vreg12
 21 ( 21 ): %xmm2 = MOVSDrr %vreg19
 22 ( 22 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 24 ( 24 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 25 ( 25 ): %vreg20 = Copy %rax
 26 ( 26 ): %rax = MOVrr64 %vreg20
 27 ( 27 ): RET 
MachineFunction(name: Vec_dot, ty: f64 (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %xmm0 = MOVSDrr %vreg2
 3  ( 3  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 4  ( 4  ): CALL Address(addr<fn:cilk.println.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 5  ( 5  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 6  ( 6  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 7  ( 7  ): %vreg4 = MOVSDrm Base(%vreg3)
 8  ( 8  ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 9  ( 9  ): %vreg6 = MOVSDrm Base(%vreg5)
 10 ( 10 ): %vreg7 = MULSDrr %vreg4, %vreg6 (tie:%vreg7->%vreg4,)
 11 ( 11 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 12 ( 12 ): %vreg9 = ADDr64i32 %vreg8, i32 8 (tie:%vreg9->%vreg8,)
 13 ( 13 ): %vreg10 = MOVSDrm Base(%vreg9)
 14 ( 14 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 15 ( 15 ): %vreg12 = ADDr64i32 %vreg11, i32 8 (tie:%vreg12->%vreg11,)
 16 ( 16 ): %vreg13 = MOVSDrm Base(%vreg12)
 17 ( 17 ): %vreg14 = MULSDrr %vreg10, %vreg13 (tie:%vreg14->%vreg10,)
 18 ( 18 ): %vreg15 = ADDSDrr %vreg7, %vreg14 (tie:%vreg15->%vreg7,)
 19 ( 19 ): %vreg16 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 20 ( 20 ): %vreg17 = ADDr64i32 %vreg16, i32 16 (tie:%vreg17->%vreg16,)
 21 ( 21 ): %vreg18 = MOVSDrm Base(%vreg17)
 22 ( 22 ): %vreg19 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 23 ( 23 ): %vreg20 = ADDr64i32 %vreg19, i32 16 (tie:%vreg20->%vreg19,)
 24 ( 24 ): %vreg21 = MOVSDrm Base(%vreg20)
 25 ( 25 ): %vreg22 = MULSDrr %vreg18, %vreg21 (tie:%vreg22->%vreg18,)
 26 ( 26 ): %vreg23 = ADDSDrr %vreg15, %vreg22 (tie:%vreg23->%vreg15,)
 27 ( 27 ): %xmm0 = MOVSDrr %vreg23
 28 ( 28 ): RET 
MachineFunction(name: Vec_reflect, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 3  ( 3  ): %vreg4 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 4  ( 4  ): %rdi = MOVrr64 %vreg3
 5  ( 5  ): %rsi = MOVrr64 %vreg4
 6  ( 6  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 7  ( 7  ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 8  ( 8  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 9  ( 9  ): %vreg5 = Copy %xmm0
 10 ( 10 ): %vreg6 = MOVSDrm64 f64 -2
 11 ( 11 ): %vreg7 = MULSDrr %vreg5, %vreg6 (tie:%vreg7->%vreg5,)
 12 ( 12 ): %rdi = MOVrr64 %vreg2
 13 ( 13 ): %xmm1 = MOVSDrr %vreg7
 14 ( 14 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 15 ( 15 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
 16 ( 16 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 17 ( 17 ): %vreg8 = Copy %rax
 18 ( 18 ): %rdi = MOVrr64 %vreg1
 19 ( 19 ): %rsi = MOVrr64 %vreg8
 20 ( 20 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 21 ( 21 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 22 ( 22 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %vreg9 = Copy %rax
 24 ( 24 ): %rax = MOVrr64 %vreg9
 25 ( 25 ): RET 
MachineFunction(name: Vec_length, ty: f64 (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm Base(%vreg1)
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 3  ( 3  ): %vreg4 = MOVSDrm Base(%vreg3)
 4  ( 4  ): %vreg5 = MULSDrr %vreg2, %vreg4 (tie:%vreg5->%vreg2,)
 5  ( 5  ): %vreg6 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 6  ): %vreg7 = ADDr64i32 %vreg6, i32 8 (tie:%vreg7->%vreg6,)
 7  ( 7  ): %vreg8 = MOVSDrm Base(%vreg7)
 8  ( 8  ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 9  ( 9  ): %vreg10 = ADDr64i32 %vreg9, i32 8 (tie:%vreg10->%vreg9,)
 10 ( 10 ): %vreg11 = MOVSDrm Base(%vreg10)
 11 ( 11 ): %vreg12 = MULSDrr %vreg8, %vreg11 (tie:%vreg12->%vreg8,)
 12 ( 12 ): %vreg13 = ADDSDrr %vreg5, %vreg12 (tie:%vreg13->%vreg5,)
 13 ( 13 ): %vreg14 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 14 ( 14 ): %vreg15 = ADDr64i32 %vreg14, i32 16 (tie:%vreg15->%vreg14,)
 15 ( 15 ): %vreg16 = MOVSDrm Base(%vreg15)
 16 ( 16 ): %vreg17 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 17 ( 17 ): %vreg18 = ADDr64i32 %vreg17, i32 16 (tie:%vreg18->%vreg17,)
 18 ( 18 ): %vreg19 = MOVSDrm Base(%vreg18)
 19 ( 19 ): %vreg20 = MULSDrr %vreg16, %vreg19 (tie:%vreg20->%vreg16,)
 20 ( 20 ): %vreg21 = ADDSDrr %vreg13, %vreg20 (tie:%vreg21->%vreg13,)
 21 ( 21 ): %xmm0 = MOVSDrr %vreg21
 22 ( 22 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %xmm0 = CALL Address(addr<fn:cilk.sqrt.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 24 ( 24 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 25 ( 25 ): %vreg22 = Copy %xmm0
 26 ( 26 ): %xmm0 = MOVSDrr %vreg22
 27 ( 27 ): RET 
MachineFunction(name: Vec_normalize, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<f64, Local(0)>)
 1  ( 1  ): %vreg2 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 2  ( 2  ): %rdi = MOVrr64 %vreg2
 3  ( 3  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 4  ( 4  ): %xmm0 = CALL Address(addr<fn:Vec_length>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
 5  ( 5  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 6  ( 6  ): %vreg3 = Copy %xmm0
 7  ( 7  ): MOVSDmr Base(%vreg1), %vreg3
 8  ( 8  ): %vreg4 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 9  ( 9  ): %vreg5 = MOVSDrm64 f64 0.00000001
 10 ( 10 ): UCOMISDrr %vreg4, %vreg5
 11 ( 11 ): JA BB#1
 12 ( 12 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }] } })
 13 ( 13 ): %vreg6 = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 14 ( 14 ): %vreg7 = MOVSDrm64 f64 1
 15 ( 15 ): %vreg8 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 16 ( 16 ): %vreg9 = DIVSDrr %vreg7, %vreg8 (tie:%vreg9->%vreg7,)
 17 ( 17 ): MOVSDmr Base(%vreg6), %vreg9
 18 ( 18 ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 19 ( 19 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 20 ( 20 ): %vreg12 = MOVSDrm Base(%vreg11)
 21 ( 21 ): %vreg13 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 22 ( 22 ): %vreg14 = MULSDrr %vreg12, %vreg13 (tie:%vreg14->%vreg12,)
 23 ( 23 ): MOVSDmr Base(%vreg10), %vreg14
 24 ( 24 ): %vreg15 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 25 ( 25 ): %vreg16 = ADDr64i32 %vreg15, i32 8 (tie:%vreg16->%vreg15,)
 26 ( 26 ): %vreg17 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 27 ( 27 ): %vreg18 = ADDr64i32 %vreg17, i32 8 (tie:%vreg18->%vreg17,)
 28 ( 28 ): %vreg19 = MOVSDrm Base(%vreg18)
 29 ( 29 ): %vreg20 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 30 ( 30 ): %vreg21 = MULSDrr %vreg19, %vreg20 (tie:%vreg21->%vreg19,)
 31 ( 31 ): MOVSDmr Base(%vreg16), %vreg21
 32 ( 32 ): %vreg22 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 33 ( 33 ): %vreg23 = ADDr64i32 %vreg22, i32 16 (tie:%vreg23->%vreg22,)
 34 ( 34 ): %vreg24 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 35 ( 35 ): %vreg25 = ADDr64i32 %vreg24, i32 16 (tie:%vreg25->%vreg24,)
 36 ( 36 ): %vreg26 = MOVSDrm Base(%vreg25)
 37 ( 37 ): %vreg27 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 38 ( 38 ): %vreg28 = MULSDrr %vreg26, %vreg27 (tie:%vreg28->%vreg26,)
 39 ( 39 ): MOVSDmr Base(%vreg23), %vreg28
 40 ( 40 ): JMP BB#2
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }, Id { idx: 1 }], succ: [], iseq: RefCell { value: [Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }] } })
 41 ( 41 ): %vreg29 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 42 ( 42 ): %rax = MOVrr64 %vreg29
 43 ( 43 ): RET 
MachineFunction(name: Ray_new, ty: struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 8  ( 8  ): %vreg4 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 9  ( 9  ): MOVmr64 Base(%vreg3), %vreg4
 10 ( 10 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 11 ( 11 ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 12 ( 12 ): %vreg7 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 13 ( 13 ): MOVmr64 Base(%vreg6), %vreg7
 14 ( 14 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 15 ( 15 ): %rax = MOVrr64 %vreg8
 16 ( 16 ): RET 
MachineFunction(name: Isect_new, ty: struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* (i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 8  ( 8  ): %vreg4 = MOVrm32 BaseFi(%rbp, FI<i32, Arg(0)>)
 9  ( 9  ): MOVmr32 Base(%vreg3), %vreg4
 10 ( 10 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 11 ( 11 ): %vreg6 = ADDr64i32 %vreg5, i32 4 (tie:%vreg6->%vreg5,)
 12 ( 12 ): %vreg7 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 13 ( 13 ): MOVmr64 Base(%vreg6), %vreg7
 14 ( 14 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 15 ( 15 ): %vreg9 = ADDr64i32 %vreg8, i32 12 (tie:%vreg9->%vreg8,)
 16 ( 16 ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 17 ( 17 ): MOVmr64 Base(%vreg9), %vreg10
 18 ( 18 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 19 ( 19 ): %vreg12 = ADDr64i32 %vreg11, i32 20 (tie:%vreg12->%vreg11,)
 20 ( 20 ): %vreg13 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(3)>)
 21 ( 21 ): MOVmr64 Base(%vreg12), %vreg13
 22 ( 22 ): %vreg14 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 23 ( 23 ): %vreg15 = ADDr64i32 %vreg14, i32 28 (tie:%vreg15->%vreg14,)
 24 ( 24 ): %vreg16 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(4)>)
 25 ( 25 ): MOVSDmr Base(%vreg15), %vreg16
 26 ( 26 ): %vreg17 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 27 ( 27 ): %vreg18 = ADDr64i32 %vreg17, i32 36 (tie:%vreg18->%vreg17,)
 28 ( 28 ): %vreg19 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(5)>)
 29 ( 29 ): MOVmr64 Base(%vreg18), %vreg19
 30 ( 30 ): %vreg20 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 31 ( 31 ): %rax = MOVrr64 %vreg20
 32 ( 32 ): RET 
MachineFunction(name: Sphere_new, ty: struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 8  ( 8  ): %vreg4 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 9  ( 9  ): MOVSDmr Base(%vreg3), %vreg4
 10 ( 10 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 11 ( 11 ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 12 ( 12 ): %vreg7 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 13 ( 13 ): MOVmr64 Base(%vreg6), %vreg7
 14 ( 14 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 15 ( 15 ): %vreg9 = ADDr64i32 %vreg8, i32 16 (tie:%vreg9->%vreg8,)
 16 ( 16 ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 17 ( 17 ): MOVmr64 Base(%vreg9), %vreg10
 18 ( 18 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 19 ( 19 ): %rax = MOVrr64 %vreg11
 20 ( 20 ): RET 
MachineFunction(name: Sphere_intersect, ty: i32 (struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 54 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }, Id { idx: 62 }, Id { idx: 63 }, Id { idx: 64 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 1  ( 1  ): %vreg2 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 2  ( 2  ): %vreg3 = MOVrm64 Base(%vreg2)
 3  ( 3  ): %vreg4 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 4  ( 4  ): %vreg5 = ADDr64i32 %vreg4, i32 8 (tie:%vreg5->%vreg4,)
 5  ( 5  ): %vreg6 = MOVrm64 Base(%vreg5)
 6  ( 6  ): %rdi = MOVrr64 %vreg3
 7  ( 7  ): %rsi = MOVrr64 %vreg6
 8  ( 8  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 9  ( 9  ): %rax = CALL Address(addr<fn:Vec_sub>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 10 ( 10 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 11 ( 11 ): %vreg7 = Copy %rax
 12 ( 12 ): MOVmr64 Base(%vreg1), %vreg7
 13 ( 13 ): %vreg8 = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 14 ( 14 ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 15 ( 15 ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 16 ( 16 ): %vreg11 = ADDr64i32 %vreg10, i32 8 (tie:%vreg11->%vreg10,)
 17 ( 17 ): %vreg12 = MOVrm64 Base(%vreg11)
 18 ( 18 ): %rdi = MOVrr64 %vreg9
 19 ( 19 ): %rsi = MOVrr64 %vreg12
 20 ( 20 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 21 ( 21 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 22 ( 22 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 23 ( 23 ): %vreg13 = Copy %xmm0
 24 ( 24 ): MOVSDmr Base(%vreg8), %vreg13
 25 ( 25 ): %vreg14 = LEAr64m BaseFi(%rbp, FI<f64, Local(2)>)
 26 ( 26 ): %vreg15 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 27 ( 27 ): %vreg16 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 28 ( 28 ): %rdi = MOVrr64 %vreg15
 29 ( 29 ): %rsi = MOVrr64 %vreg16
 30 ( 30 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 31 ( 31 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 32 ( 32 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 33 ( 33 ): %vreg17 = Copy %xmm0
 34 ( 34 ): %vreg18 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 35 ( 35 ): %vreg19 = MOVSDrm Base(%vreg18)
 36 ( 36 ): %vreg20 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 37 ( 37 ): %vreg21 = MOVSDrm Base(%vreg20)
 38 ( 38 ): %vreg22 = MULSDrr %vreg19, %vreg21 (tie:%vreg22->%vreg19,)
 39 ( 39 ): %vreg23 = SUBSDrr %vreg17, %vreg22 (tie:%vreg23->%vreg17,)
 40 ( 40 ): MOVSDmr Base(%vreg14), %vreg23
 41 ( 41 ): %vreg24 = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
 42 ( 42 ): %vreg25 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 43 ( 43 ): %vreg26 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 44 ( 44 ): %vreg27 = MULSDrr %vreg25, %vreg26 (tie:%vreg27->%vreg25,)
 45 ( 45 ): %vreg28 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 46 ( 46 ): %vreg29 = SUBSDrr %vreg27, %vreg28 (tie:%vreg29->%vreg27,)
 47 ( 47 ): MOVSDmr Base(%vreg24), %vreg29
 48 ( 48 ): %vreg30 = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
 49 ( 49 ): %vreg31 = MOVSDrm64 f64 0
 50 ( 50 ): %vreg32 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 51 ( 51 ): %vreg33 = SUBSDrr %vreg31, %vreg32 (tie:%vreg33->%vreg31,)
 52 ( 52 ): %vreg34 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 53 ( 53 ): %xmm0 = MOVSDrr %vreg34
 54 ( 54 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 55 ( 55 ): %xmm0 = CALL Address(addr<fn:cilk.sqrt.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 56 ( 56 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 57 ( 57 ): %vreg35 = Copy %xmm0
 58 ( 58 ): %vreg36 = SUBSDrr %vreg33, %vreg35 (tie:%vreg36->%vreg33,)
 59 ( 59 ): MOVSDmr Base(%vreg30), %vreg36
 60 ( 60 ): %vreg37 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 61 ( 61 ): %vreg38 = MOVSDrm64 f64 0
 62 ( 62 ): UCOMISDrr %vreg37, %vreg38
 63 ( 63 ): JBE BB#1
 64 ( 64 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 65 }, Id { idx: 66 }] } })
 65 ( 65 ): %eax = MOVri32 i32 0
 66 ( 66 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }] } })
 67 ( 67 ): %vreg39 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 68 ( 68 ): %vreg40 = MOVSDrm64 f64 0.0001
 69 ( 69 ): UCOMISDrr %vreg39, %vreg40
 70 ( 70 ): JBE BB#3
 71 ( 71 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 72 }, Id { idx: 73 }] } })
 72 ( 72 ): %eax = MOVri32 i32 0
 73 ( 73 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [Id { idx: 5 }, Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 74 }, Id { idx: 75 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }] } })
 74 ( 74 ): %vreg41 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 75 ( 75 ): %vreg42 = ADDr64i32 %vreg41, i32 28 (tie:%vreg42->%vreg41,)
 76 ( 76 ): %vreg43 = MOVSDrm Base(%vreg42)
 77 ( 77 ): %vreg44 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 78 ( 78 ): UCOMISDrr %vreg43, %vreg44
 79 ( 79 ): JBE BB#5
 80 ( 80 ): JMP BB#6
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [], iseq: RefCell { value: [Id { idx: 81 }, Id { idx: 82 }] } })
 81 ( 81 ): %eax = MOVri32 i32 0
 82 ( 82 ): RET 
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [], iseq: RefCell { value: [Id { idx: 83 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 88 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 94 }, Id { idx: 95 }, Id { idx: 96 }, Id { idx: 97 }, Id { idx: 98 }, Id { idx: 99 }, Id { idx: 100 }, Id { idx: 101 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 107 }, Id { idx: 108 }, Id { idx: 109 }, Id { idx: 110 }, Id { idx: 111 }, Id { idx: 112 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 115 }, Id { idx: 116 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 120 }, Id { idx: 121 }, Id { idx: 122 }, Id { idx: 123 }, Id { idx: 124 }, Id { idx: 125 }, Id { idx: 126 }, Id { idx: 127 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }, Id { idx: 132 }, Id { idx: 133 }, Id { idx: 134 }, Id { idx: 135 }, Id { idx: 136 }, Id { idx: 137 }, Id { idx: 138 }, Id { idx: 139 }, Id { idx: 140 }, Id { idx: 141 }, Id { idx: 142 }, Id { idx: 143 }, Id { idx: 144 }, Id { idx: 145 }, Id { idx: 146 }, Id { idx: 147 }, Id { idx: 148 }, Id { idx: 149 }, Id { idx: 150 }, Id { idx: 151 }, Id { idx: 152 }, Id { idx: 153 }, Id { idx: 154 }, Id { idx: 155 }, Id { idx: 156 }, Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }, Id { idx: 160 }, Id { idx: 161 }, Id { idx: 162 }, Id { idx: 163 }, Id { idx: 164 }, Id { idx: 165 }, Id { idx: 166 }, Id { idx: 167 }, Id { idx: 168 }, Id { idx: 169 }] } })
 83 ( 83 ): %vreg45 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 84 ( 84 ): %vreg46 = ADDr64i32 %vreg45, i32 4 (tie:%vreg46->%vreg45,)
 85 ( 85 ): %vreg47 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 86 ( 86 ): %vreg48 = MOVrm64 Base(%vreg47)
 87 ( 87 ): %vreg49 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 88 ( 88 ): %vreg50 = ADDr64i32 %vreg49, i32 8 (tie:%vreg50->%vreg49,)
 89 ( 89 ): %vreg51 = MOVrm64 Base(%vreg50)
 90 ( 90 ): %vreg52 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 91 ( 91 ): %rdi = MOVrr64 %vreg51
 92 ( 92 ): %xmm1 = MOVSDrr %vreg52
 93 ( 93 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 94 ( 94 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
 95 ( 95 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 96 ( 96 ): %vreg53 = Copy %rax
 97 ( 97 ): %rdi = MOVrr64 %vreg48
 98 ( 98 ): %rsi = MOVrr64 %vreg53
 99 ( 99 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
100 (100 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
101 (101 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
102 (102 ): %vreg54 = Copy %rax
103 (103 ): MOVmr64 Base(%vreg46), %vreg54
104 (104 ): %vreg55 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
105 (105 ): %vreg56 = ADDr64i32 %vreg55, i32 12 (tie:%vreg56->%vreg55,)
106 (106 ): %vreg57 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
107 (107 ): %vreg58 = ADDr64i32 %vreg57, i32 4 (tie:%vreg58->%vreg57,)
108 (108 ): %vreg59 = MOVrm64 Base(%vreg58)
109 (109 ): %vreg60 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
110 (110 ): %vreg61 = ADDr64i32 %vreg60, i32 8 (tie:%vreg61->%vreg60,)
111 (111 ): %vreg62 = MOVrm64 Base(%vreg61)
112 (112 ): %rdi = MOVrr64 %vreg59
113 (113 ): %rsi = MOVrr64 %vreg62
114 (114 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
115 (115 ): %rax = CALL Address(addr<fn:Vec_sub>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
116 (116 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
117 (117 ): %vreg63 = Copy %rax
118 (118 ): %rdi = MOVrr64 %vreg63
119 (119 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
120 (120 ): %rax = CALL Address(addr<fn:Vec_normalize>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
121 (121 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
122 (122 ): %vreg64 = Copy %rax
123 (123 ): MOVmr64 Base(%vreg56), %vreg64
124 (124 ): %vreg65 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
125 (125 ): %vreg66 = ADDr64i32 %vreg65, i32 20 (tie:%vreg66->%vreg65,)
126 (126 ): %vreg67 = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
127 (127 ): %vreg68 = ADDr64i32 %vreg67, i32 16 (tie:%vreg68->%vreg67,)
128 (128 ): %vreg69 = MOVrm64 Base(%vreg68)
129 (129 ): %vreg70 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
130 (130 ): %vreg71 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
131 (131 ): %vreg72 = ADDr64i32 %vreg71, i32 12 (tie:%vreg72->%vreg71,)
132 (132 ): %vreg73 = MOVrm64 Base(%vreg72)
133 (133 ): %rdi = MOVrr64 %vreg70
134 (134 ): %rsi = MOVrr64 %vreg73
135 (135 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
136 (136 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
137 (137 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
138 (138 ): %vreg74 = Copy %xmm0
139 (139 ): %xmm0 = MOVSDrr %vreg74
140 (140 ): %xmm1 = MOVSDrm64 f64 0.1
141 (141 ): %xmm2 = MOVSDrm64 f64 1
142 (142 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
143 (143 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
144 (144 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
145 (145 ): %vreg75 = Copy %xmm0
146 (146 ): %rdi = MOVrr64 %vreg69
147 (147 ): %xmm1 = MOVSDrr %vreg75
148 (148 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
149 (149 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
150 (150 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
151 (151 ): %vreg76 = Copy %rax
152 (152 ): MOVmr64 Base(%vreg66), %vreg76
153 (153 ): %vreg77 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
154 (154 ): %vreg78 = ADDr64i32 %vreg77, i32 28 (tie:%vreg78->%vreg77,)
155 (155 ): %vreg79 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
156 (156 ): MOVSDmr Base(%vreg78), %vreg79
157 (157 ): %vreg80 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
158 (158 ): %vreg81 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
159 (159 ): %vreg82 = MOVrm32 Base(%vreg81)
160 (160 ): %vreg83 = ADDri32 %vreg82, i32 1 (tie:%vreg83->%vreg82,)
161 (161 ): MOVmr32 Base(%vreg80), %vreg83
162 (162 ): %vreg84 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
163 (163 ): %vreg85 = ADDr64i32 %vreg84, i32 36 (tie:%vreg85->%vreg84,)
164 (164 ): %vreg86 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
165 (165 ): %vreg87 = ADDr64i32 %vreg86, i32 8 (tie:%vreg87->%vreg86,)
166 (166 ): %vreg88 = MOVrm64 Base(%vreg87)
167 (167 ): MOVmr64 Base(%vreg85), %vreg88
168 (168 ): %eax = MOVri32 i32 0
169 (169 ): RET 
MachineFunction(name: Plane_new, ty: struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 8  ( 8  ): %vreg4 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 9  ( 9  ): MOVmr64 Base(%vreg3), %vreg4
 10 ( 10 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 11 ( 11 ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 12 ( 12 ): %vreg7 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 13 ( 13 ): MOVmr64 Base(%vreg6), %vreg7
 14 ( 14 ): %vreg8 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 15 ( 15 ): %vreg9 = ADDr64i32 %vreg8, i32 16 (tie:%vreg9->%vreg8,)
 16 ( 16 ): %vreg10 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 17 ( 17 ): MOVmr64 Base(%vreg9), %vreg10
 18 ( 18 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 19 ( 19 ): %rax = MOVrr64 %vreg11
 20 ( 20 ): RET 
MachineFunction(name: Plane_intersect, ty: i32 (struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<f64, Local(0)>)
 1  ( 1  ): %vreg2 = MOVSDrm64 f64 0
 2  ( 2  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 3  ( 3  ): %vreg4 = MOVrm64 Base(%vreg3)
 4  ( 4  ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 5  ( 5  ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 6  ( 6  ): %vreg7 = MOVrm64 Base(%vreg6)
 7  ( 7  ): %rdi = MOVrr64 %vreg4
 8  ( 8  ): %rsi = MOVrr64 %vreg7
 9  ( 9  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 10 ( 10 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 11 ( 11 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 12 ( 12 ): %vreg8 = Copy %xmm0
 13 ( 13 ): %vreg9 = SUBSDrr %vreg2, %vreg8 (tie:%vreg9->%vreg2,)
 14 ( 14 ): MOVSDmr Base(%vreg1), %vreg9
 15 ( 15 ): %vreg10 = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 16 ( 16 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 17 ( 17 ): %vreg12 = ADDr64i32 %vreg11, i32 8 (tie:%vreg12->%vreg11,)
 18 ( 18 ): %vreg13 = MOVrm64 Base(%vreg12)
 19 ( 19 ): %vreg14 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 20 ( 20 ): %vreg15 = ADDr64i32 %vreg14, i32 8 (tie:%vreg15->%vreg14,)
 21 ( 21 ): %vreg16 = MOVrm64 Base(%vreg15)
 22 ( 22 ): %rdi = MOVrr64 %vreg13
 23 ( 23 ): %rsi = MOVrr64 %vreg16
 24 ( 24 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 25 ( 25 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 26 ( 26 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 27 ( 27 ): %vreg17 = Copy %xmm0
 28 ( 28 ): MOVSDmr Base(%vreg10), %vreg17
 29 ( 29 ): %vreg18 = LEAr64m BaseFi(%rbp, FI<f64, Local(2)>)
 30 ( 30 ): %vreg19 = MOVSDrm64 f64 0
 31 ( 31 ): %vreg20 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 32 ( 32 ): %vreg21 = MOVrm64 Base(%vreg20)
 33 ( 33 ): %vreg22 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 34 ( 34 ): %vreg23 = ADDr64i32 %vreg22, i32 8 (tie:%vreg23->%vreg22,)
 35 ( 35 ): %vreg24 = MOVrm64 Base(%vreg23)
 36 ( 36 ): %rdi = MOVrr64 %vreg21
 37 ( 37 ): %rsi = MOVrr64 %vreg24
 38 ( 38 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 39 ( 39 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 40 ( 40 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 41 ( 41 ): %vreg25 = Copy %xmm0
 42 ( 42 ): %vreg26 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 43 ( 43 ): %vreg27 = ADDSDrr %vreg25, %vreg26 (tie:%vreg27->%vreg25,)
 44 ( 44 ): %vreg28 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 45 ( 45 ): %vreg29 = DIVSDrr %vreg27, %vreg28 (tie:%vreg29->%vreg27,)
 46 ( 46 ): %vreg30 = SUBSDrr %vreg19, %vreg29 (tie:%vreg30->%vreg19,)
 47 ( 47 ): MOVSDmr Base(%vreg18), %vreg30
 48 ( 48 ): %vreg31 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 49 ( 49 ): %vreg32 = MOVSDrm64 f64 0.0001
 50 ( 50 ): UCOMISDrr %vreg31, %vreg32
 51 ( 51 ): JBE BB#1
 52 ( 52 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 53 }, Id { idx: 54 }] } })
 53 ( 53 ): %eax = MOVri32 i32 0
 54 ( 54 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }] } })
 55 ( 55 ): %vreg33 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 56 ( 56 ): %vreg34 = ADDr64i32 %vreg33, i32 28 (tie:%vreg34->%vreg33,)
 57 ( 57 ): %vreg35 = MOVSDrm Base(%vreg34)
 58 ( 58 ): %vreg36 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 59 ( 59 ): UCOMISDrr %vreg35, %vreg36
 60 ( 60 ): JBE BB#3
 61 ( 61 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 62 }, Id { idx: 63 }] } })
 62 ( 62 ): %eax = MOVri32 i32 0
 63 ( 63 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [Id { idx: 5 }, Id { idx: 8 }], iseq: RefCell { value: [Id { idx: 64 }, Id { idx: 65 }, Id { idx: 66 }, Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }, Id { idx: 72 }, Id { idx: 73 }, Id { idx: 74 }, Id { idx: 75 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }, Id { idx: 81 }, Id { idx: 82 }, Id { idx: 83 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 88 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 94 }, Id { idx: 95 }, Id { idx: 96 }, Id { idx: 97 }, Id { idx: 98 }, Id { idx: 99 }, Id { idx: 100 }, Id { idx: 101 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 107 }, Id { idx: 108 }, Id { idx: 109 }, Id { idx: 110 }, Id { idx: 111 }, Id { idx: 112 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 115 }, Id { idx: 116 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 120 }, Id { idx: 121 }, Id { idx: 122 }, Id { idx: 123 }, Id { idx: 124 }, Id { idx: 125 }, Id { idx: 126 }, Id { idx: 127 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }, Id { idx: 132 }, Id { idx: 133 }, Id { idx: 134 }, Id { idx: 135 }, Id { idx: 136 }, Id { idx: 137 }, Id { idx: 138 }, Id { idx: 139 }, Id { idx: 140 }, Id { idx: 141 }, Id { idx: 142 }, Id { idx: 143 }, Id { idx: 144 }, Id { idx: 145 }, Id { idx: 146 }, Id { idx: 147 }, Id { idx: 148 }, Id { idx: 149 }, Id { idx: 150 }, Id { idx: 151 }, Id { idx: 152 }, Id { idx: 153 }, Id { idx: 154 }, Id { idx: 155 }, Id { idx: 156 }, Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }] } })
 64 ( 64 ): %vreg37 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 65 ( 65 ): %vreg38 = ADDr64i32 %vreg37, i32 4 (tie:%vreg38->%vreg37,)
 66 ( 66 ): %vreg39 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 67 ( 67 ): %vreg40 = MOVrm64 Base(%vreg39)
 68 ( 68 ): %vreg41 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 69 ( 69 ): %vreg42 = ADDr64i32 %vreg41, i32 8 (tie:%vreg42->%vreg41,)
 70 ( 70 ): %vreg43 = MOVrm64 Base(%vreg42)
 71 ( 71 ): %vreg44 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 72 ( 72 ): %rdi = MOVrr64 %vreg43
 73 ( 73 ): %xmm1 = MOVSDrr %vreg44
 74 ( 74 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 75 ( 75 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
 76 ( 76 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 77 ( 77 ): %vreg45 = Copy %rax
 78 ( 78 ): %rdi = MOVrr64 %vreg40
 79 ( 79 ): %rsi = MOVrr64 %vreg45
 80 ( 80 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 81 ( 81 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 82 ( 82 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 83 ( 83 ): %vreg46 = Copy %rax
 84 ( 84 ): MOVmr64 Base(%vreg38), %vreg46
 85 ( 85 ): %vreg47 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 86 ( 86 ): %vreg48 = ADDr64i32 %vreg47, i32 12 (tie:%vreg48->%vreg47,)
 87 ( 87 ): %vreg49 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 88 ( 88 ): %vreg50 = ADDr64i32 %vreg49, i32 8 (tie:%vreg50->%vreg49,)
 89 ( 89 ): %vreg51 = MOVrm64 Base(%vreg50)
 90 ( 90 ): MOVmr64 Base(%vreg48), %vreg51
 91 ( 91 ): %vreg52 = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
 92 ( 92 ): %vreg53 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 93 ( 93 ): %vreg54 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 94 ( 94 ): %vreg55 = ADDr64i32 %vreg54, i32 12 (tie:%vreg55->%vreg54,)
 95 ( 95 ): %vreg56 = MOVrm64 Base(%vreg55)
 96 ( 96 ): %rdi = MOVrr64 %vreg53
 97 ( 97 ): %rsi = MOVrr64 %vreg56
 98 ( 98 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 99 ( 99 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
100 (100 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
101 (101 ): %vreg57 = Copy %xmm0
102 (102 ): %xmm0 = MOVSDrr %vreg57
103 (103 ): %xmm1 = MOVSDrm64 f64 0.1
104 (104 ): %xmm2 = MOVSDrm64 f64 1
105 (105 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
106 (106 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
107 (107 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
108 (108 ): %vreg58 = Copy %xmm0
109 (109 ): MOVSDmr Base(%vreg52), %vreg58
110 (110 ): %vreg59 = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
111 (111 ): %vreg60 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
112 (112 ): %vreg61 = ADDr64i32 %vreg60, i32 4 (tie:%vreg61->%vreg60,)
113 (113 ): %vreg62 = MOVrm64 Base(%vreg61)
114 (114 ): %vreg63 = MOVSDrm Base(%vreg62)
115 (115 ): %vreg64 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
116 (116 ): %vreg65 = ADDr64i32 %vreg64, i32 4 (tie:%vreg65->%vreg64,)
117 (117 ): %vreg66 = MOVrm64 Base(%vreg65)
118 (118 ): %vreg67 = MOVSDrm Base(%vreg66)
119 (119 ): %vreg68 = MOVSDrm64 f64 2
120 (120 ): %vreg69 = DIVSDrr %vreg67, %vreg68 (tie:%vreg69->%vreg67,)
121 (121 ): %xmm0 = MOVSDrr %vreg69
122 (122 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
123 (123 ): %xmm0 = CALL Address(addr<fn:cilk.floor.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
124 (124 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
125 (125 ): %vreg70 = Copy %xmm0
126 (126 ): %vreg71 = MOVSDrm64 f64 2
127 (127 ): %vreg72 = MULSDrr %vreg70, %vreg71 (tie:%vreg72->%vreg70,)
128 (128 ): %vreg73 = SUBSDrr %vreg63, %vreg72 (tie:%vreg73->%vreg63,)
129 (129 ): MOVSDmr Base(%vreg59), %vreg73
130 (130 ): %vreg74 = LEAr64m BaseFi(%rbp, FI<f64, Local(5)>)
131 (131 ): %vreg75 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
132 (132 ): %vreg76 = ADDr64i32 %vreg75, i32 4 (tie:%vreg76->%vreg75,)
133 (133 ): %vreg77 = MOVrm64 Base(%vreg76)
134 (134 ): %vreg78 = ADDr64i32 %vreg77, i32 16 (tie:%vreg78->%vreg77,)
135 (135 ): %vreg79 = MOVSDrm Base(%vreg78)
136 (136 ): %vreg80 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
137 (137 ): %vreg81 = ADDr64i32 %vreg80, i32 4 (tie:%vreg81->%vreg80,)
138 (138 ): %vreg82 = MOVrm64 Base(%vreg81)
139 (139 ): %vreg83 = ADDr64i32 %vreg82, i32 16 (tie:%vreg83->%vreg82,)
140 (140 ): %vreg84 = MOVSDrm Base(%vreg83)
141 (141 ): %vreg85 = MOVSDrm64 f64 2
142 (142 ): %vreg86 = DIVSDrr %vreg84, %vreg85 (tie:%vreg86->%vreg84,)
143 (143 ): %xmm0 = MOVSDrr %vreg86
144 (144 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
145 (145 ): %xmm0 = CALL Address(addr<fn:cilk.floor.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
146 (146 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
147 (147 ): %vreg87 = Copy %xmm0
148 (148 ): %vreg88 = MOVSDrm64 f64 2
149 (149 ): %vreg89 = MULSDrr %vreg87, %vreg88 (tie:%vreg89->%vreg87,)
150 (150 ): %vreg90 = SUBSDrr %vreg79, %vreg89 (tie:%vreg90->%vreg79,)
151 (151 ): MOVSDmr Base(%vreg74), %vreg90
152 (152 ): %vreg91 = LEAr64m BaseFi(%rbp, FI<f64, Local(6)>)
153 (153 ): %vreg92 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
154 (154 ): MOVSDmr Base(%vreg91), %vreg92
155 (155 ): %vreg93 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
156 (156 ): %vreg94 = MOVSDrm64 f64 1
157 (157 ): UCOMISDrr %vreg93, %vreg94
158 (158 ): JA BB#5
159 (159 ): JMP BB#8
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 6 }, Id { idx: 7 }], iseq: RefCell { value: [Id { idx: 160 }, Id { idx: 161 }, Id { idx: 162 }, Id { idx: 163 }, Id { idx: 164 }] } })
160 (160 ): %vreg95 = MOVSDrm BaseFi(%rbp, FI<f64, Local(5)>)
161 (161 ): %vreg96 = MOVSDrm64 f64 1
162 (162 ): UCOMISDrr %vreg95, %vreg96
163 (163 ): JA BB#6
164 (164 ): JMP BB#7
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 5 }], succ: [Id { idx: 7 }], iseq: RefCell { value: [Id { idx: 165 }, Id { idx: 166 }, Id { idx: 167 }, Id { idx: 168 }, Id { idx: 169 }] } })
165 (165 ): %vreg97 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
166 (166 ): %vreg98 = MOVSDrm64 f64 0.5
167 (167 ): %vreg99 = MULSDrr %vreg97, %vreg98 (tie:%vreg99->%vreg97,)
168 (168 ): MOVSDmr Base(%vreg91), %vreg99
169 (169 ): JMP BB#7
MachineBasicBlock #7 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 5 }, Id { idx: 6 }], succ: [Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 170 }] } })
170 (170 ): JMP BB#13
MachineBasicBlock #8 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 9 }, Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 171 }, Id { idx: 172 }, Id { idx: 173 }, Id { idx: 174 }, Id { idx: 175 }] } })
171 (171 ): %vreg100 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
172 (172 ): %vreg101 = MOVSDrm64 f64 1
173 (173 ): UCOMISDrr %vreg100, %vreg101
174 (174 ): JB BB#9
175 (175 ): JMP BB#12
MachineBasicBlock #9 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 8 }], succ: [Id { idx: 10 }, Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 176 }, Id { idx: 177 }, Id { idx: 178 }, Id { idx: 179 }, Id { idx: 180 }] } })
176 (176 ): %vreg102 = MOVSDrm BaseFi(%rbp, FI<f64, Local(5)>)
177 (177 ): %vreg103 = MOVSDrm64 f64 1
178 (178 ): UCOMISDrr %vreg102, %vreg103
179 (179 ): JB BB#10
180 (180 ): JMP BB#11
MachineBasicBlock #10 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 9 }], succ: [Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 181 }, Id { idx: 182 }, Id { idx: 183 }, Id { idx: 184 }, Id { idx: 185 }] } })
181 (181 ): %vreg104 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
182 (182 ): %vreg105 = MOVSDrm64 f64 0.5
183 (183 ): %vreg106 = MULSDrr %vreg104, %vreg105 (tie:%vreg106->%vreg104,)
184 (184 ): MOVSDmr Base(%vreg91), %vreg106
185 (185 ): JMP BB#11
MachineBasicBlock #11 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 9 }, Id { idx: 10 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 186 }] } })
186 (186 ): JMP BB#12
MachineBasicBlock #12 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 8 }, Id { idx: 11 }], succ: [Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 187 }] } })
187 (187 ): JMP BB#13
MachineBasicBlock #13 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 7 }, Id { idx: 12 }], succ: [Id { idx: 14 }, Id { idx: 15 }], iseq: RefCell { value: [Id { idx: 188 }, Id { idx: 189 }, Id { idx: 190 }, Id { idx: 191 }, Id { idx: 192 }, Id { idx: 193 }, Id { idx: 194 }, Id { idx: 195 }, Id { idx: 196 }, Id { idx: 197 }, Id { idx: 198 }, Id { idx: 199 }, Id { idx: 200 }, Id { idx: 201 }, Id { idx: 202 }, Id { idx: 203 }, Id { idx: 204 }, Id { idx: 205 }, Id { idx: 206 }] } })
188 (188 ): %vreg107 = LEAr64m BaseFi(%rbp, FI<f64, Local(7)>)
189 (189 ): %vreg108 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
190 (190 ): %vreg109 = ADDr64i32 %vreg108, i32 4 (tie:%vreg109->%vreg108,)
191 (191 ): %vreg110 = MOVrm64 Base(%vreg109)
192 (192 ): %vreg111 = ADDr64i32 %vreg110, i32 16 (tie:%vreg111->%vreg110,)
193 (193 ): %vreg112 = MOVSDrm Base(%vreg111)
194 (194 ): %xmm0 = MOVSDrr %vreg112
195 (195 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
196 (196 ): %xmm0 = CALL Address(addr<fn:cilk.fabs.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
197 (197 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
198 (198 ): %vreg113 = Copy %xmm0
199 (199 ): MOVSDmr Base(%vreg107), %vreg113
200 (200 ): %vreg114 = MOVSDrm64 f64 0
201 (201 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(8)>), %vreg114
202 (202 ): %vreg115 = MOVSDrm BaseFi(%rbp, FI<f64, Local(7)>)
203 (203 ): %vreg116 = MOVSDrm64 f64 25
204 (204 ): UCOMISDrr %vreg115, %vreg116
205 (205 ): JB BB#14
206 (206 ): JMP BB#15
MachineBasicBlock #14 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 13 }], succ: [Id { idx: 15 }], iseq: RefCell { value: [Id { idx: 207 }, Id { idx: 208 }, Id { idx: 209 }, Id { idx: 210 }, Id { idx: 211 }, Id { idx: 212 }, Id { idx: 213 }, Id { idx: 214 }] } })
207 (207 ): %vreg117 = LEAr64m BaseFi(%rbp, FI<f64, Local(8)>)
208 (208 ): %vreg118 = MOVSDrm64 f64 1
209 (209 ): %vreg119 = MOVSDrm BaseFi(%rbp, FI<f64, Local(7)>)
210 (210 ): %vreg120 = MOVSDrm64 f64 0.04
211 (211 ): %vreg121 = MULSDrr %vreg119, %vreg120 (tie:%vreg121->%vreg119,)
212 (212 ): %vreg122 = SUBSDrr %vreg118, %vreg121 (tie:%vreg122->%vreg118,)
213 (213 ): MOVSDmr Base(%vreg117), %vreg122
214 (214 ): JMP BB#15
MachineBasicBlock #15 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 13 }, Id { idx: 14 }], succ: [], iseq: RefCell { value: [Id { idx: 215 }, Id { idx: 216 }, Id { idx: 217 }, Id { idx: 218 }, Id { idx: 219 }, Id { idx: 220 }, Id { idx: 221 }, Id { idx: 222 }, Id { idx: 223 }, Id { idx: 224 }, Id { idx: 225 }, Id { idx: 226 }, Id { idx: 227 }, Id { idx: 228 }, Id { idx: 229 }, Id { idx: 230 }, Id { idx: 231 }, Id { idx: 232 }, Id { idx: 233 }, Id { idx: 234 }, Id { idx: 235 }, Id { idx: 236 }, Id { idx: 237 }, Id { idx: 238 }, Id { idx: 239 }, Id { idx: 240 }, Id { idx: 241 }, Id { idx: 242 }, Id { idx: 243 }, Id { idx: 244 }, Id { idx: 245 }, Id { idx: 246 }] } })
215 (215 ): %vreg123 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
216 (216 ): %vreg124 = ADDr64i32 %vreg123, i32 20 (tie:%vreg124->%vreg123,)
217 (217 ): %vreg125 = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
218 (218 ): %vreg126 = ADDr64i32 %vreg125, i32 16 (tie:%vreg126->%vreg125,)
219 (219 ): %vreg127 = MOVrm64 Base(%vreg126)
220 (220 ): %vreg128 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
221 (221 ): %vreg129 = MOVSDrm BaseFi(%rbp, FI<f64, Local(8)>)
222 (222 ): %vreg130 = MULSDrr %vreg128, %vreg129 (tie:%vreg130->%vreg128,)
223 (223 ): %rdi = MOVrr64 %vreg127
224 (224 ): %xmm1 = MOVSDrr %vreg130
225 (225 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
226 (226 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
227 (227 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
228 (228 ): %vreg131 = Copy %rax
229 (229 ): MOVmr64 Base(%vreg124), %vreg131
230 (230 ): %vreg132 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
231 (231 ): %vreg133 = ADDr64i32 %vreg132, i32 28 (tie:%vreg133->%vreg132,)
232 (232 ): %vreg134 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
233 (233 ): MOVSDmr Base(%vreg133), %vreg134
234 (234 ): %vreg135 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
235 (235 ): %vreg136 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
236 (236 ): %vreg137 = MOVrm32 Base(%vreg136)
237 (237 ): %vreg138 = ADDri32 %vreg137, i32 1 (tie:%vreg138->%vreg137,)
238 (238 ): MOVmr32 Base(%vreg135), %vreg138
239 (239 ): %vreg139 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
240 (240 ): %vreg140 = ADDr64i32 %vreg139, i32 36 (tie:%vreg140->%vreg139,)
241 (241 ): %vreg141 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
242 (242 ): %vreg142 = ADDr64i32 %vreg141, i32 8 (tie:%vreg142->%vreg141,)
243 (243 ): %vreg143 = MOVrm64 Base(%vreg142)
244 (244 ): MOVmr64 Base(%vreg140), %vreg143
245 (245 ): %eax = MOVri32 i32 0
246 (246 ): RET 
MachineFunction(name: Env_intersect, ty: i32 (struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 54 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }] } })
 0  ( 0  ): %vreg1 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 1  ( 1  ): %vreg2 = ADDr64i32 %vreg1, i32 8 (tie:%vreg2->%vreg1,)
 2  ( 2  ): %vreg3 = MOVrm64 Base(%vreg2)
 3  ( 3  ): %vreg4 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 4  ( 4  ): %vreg5 = MOVrm64 Base(%vreg4)
 5  ( 5  ): %vreg6 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 6  ( 6  ): %vreg7 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 7  ( 7  ): %rdi = MOVrr64 %vreg3
 8  ( 8  ): %rsi = MOVrr64 %vreg5
 9  ( 9  ): %rdx = MOVrr64 %vreg6
 10 ( 10 ): %rcx = MOVrr64 %vreg7
 11 ( 11 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 12 ( 12 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 13 ( 13 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 14 ( 14 ): %vreg8 = Copy %eax
 15 ( 15 ): %vreg9 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 16 ( 16 ): %vreg10 = ADDr64i32 %vreg9, i32 16 (tie:%vreg10->%vreg9,)
 17 ( 17 ): %vreg11 = MOVrm64 Base(%vreg10)
 18 ( 18 ): %vreg12 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 19 ( 19 ): %vreg13 = MOVrm64 Base(%vreg12)
 20 ( 20 ): %vreg14 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 21 ( 21 ): %vreg15 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 22 ( 22 ): %rdi = MOVrr64 %vreg11
 23 ( 23 ): %rsi = MOVrr64 %vreg13
 24 ( 24 ): %rdx = MOVrr64 %vreg14
 25 ( 25 ): %rcx = MOVrr64 %vreg15
 26 ( 26 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 27 ( 27 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 28 ( 28 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 29 ( 29 ): %vreg16 = Copy %eax
 30 ( 30 ): %vreg17 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 31 ( 31 ): %vreg18 = ADDr64i32 %vreg17, i32 24 (tie:%vreg18->%vreg17,)
 32 ( 32 ): %vreg19 = MOVrm64 Base(%vreg18)
 33 ( 33 ): %vreg20 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 34 ( 34 ): %vreg21 = MOVrm64 Base(%vreg20)
 35 ( 35 ): %vreg22 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 36 ( 36 ): %vreg23 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 37 ( 37 ): %rdi = MOVrr64 %vreg19
 38 ( 38 ): %rsi = MOVrr64 %vreg21
 39 ( 39 ): %rdx = MOVrr64 %vreg22
 40 ( 40 ): %rcx = MOVrr64 %vreg23
 41 ( 41 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 42 ( 42 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 43 ( 43 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 44 ( 44 ): %vreg24 = Copy %eax
 45 ( 45 ): %vreg25 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 46 ( 46 ): %vreg26 = ADDr64i32 %vreg25, i32 32 (tie:%vreg26->%vreg25,)
 47 ( 47 ): %vreg27 = MOVrm64 Base(%vreg26)
 48 ( 48 ): %vreg28 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 49 ( 49 ): %vreg29 = MOVrm64 Base(%vreg28)
 50 ( 50 ): %vreg30 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 51 ( 51 ): %vreg31 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 52 ( 52 ): %rdi = MOVrr64 %vreg27
 53 ( 53 ): %rsi = MOVrr64 %vreg29
 54 ( 54 ): %rdx = MOVrr64 %vreg30
 55 ( 55 ): %rcx = MOVrr64 %vreg31
 56 ( 56 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 57 ( 57 ): %eax = CALL Address(addr<fn:Plane_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 58 ( 58 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 59 ( 59 ): %vreg32 = Copy %eax
 60 ( 60 ): %eax = MOVri32 i32 0
 61 ( 61 ): RET 
MachineFunction(name: Env_new, ty: struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* ()):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 54 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }, Id { idx: 62 }, Id { idx: 63 }, Id { idx: 64 }, Id { idx: 65 }, Id { idx: 66 }, Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }, Id { idx: 72 }, Id { idx: 73 }, Id { idx: 74 }, Id { idx: 75 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }, Id { idx: 81 }, Id { idx: 82 }, Id { idx: 83 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 88 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 94 }, Id { idx: 95 }, Id { idx: 96 }, Id { idx: 97 }, Id { idx: 98 }, Id { idx: 99 }, Id { idx: 100 }, Id { idx: 101 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 107 }, Id { idx: 108 }, Id { idx: 109 }, Id { idx: 110 }, Id { idx: 111 }, Id { idx: 112 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 115 }, Id { idx: 116 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 120 }, Id { idx: 121 }, Id { idx: 122 }, Id { idx: 123 }, Id { idx: 124 }, Id { idx: 125 }, Id { idx: 126 }, Id { idx: 127 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }, Id { idx: 132 }, Id { idx: 133 }, Id { idx: 134 }, Id { idx: 135 }, Id { idx: 136 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 1  ( 1  ): %edi = MOVri32 i32 128
 2  ( 2  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 4  ( 4  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 5  ( 5  ): %vreg2 = Copy %rax
 6  ( 6  ): MOVmr64 Base(%vreg1), %vreg2
 7  ( 7  ): %vreg3 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 8  ( 8  ): %xmm0 = MOVSDrm64 f64 0.577
 9  ( 9  ): %xmm1 = MOVSDrm64 f64 0.577
 10 ( 10 ): %xmm2 = MOVSDrm64 f64 0.577
 11 ( 11 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 12 ( 12 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 13 ( 13 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 14 ( 14 ): %vreg4 = Copy %rax
 15 ( 15 ): MOVmr64 Base(%vreg3), %vreg4
 16 ( 16 ): %vreg5 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 17 ( 17 ): %vreg6 = ADDr64i32 %vreg5, i32 8 (tie:%vreg6->%vreg5,)
 18 ( 18 ): %xmm0 = MOVSDrm64 f64 0
 19 ( 19 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 20 ( 20 ): %xmm0 = CALL Address(addr<fn:cilk.sin.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 21 ( 21 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 22 ( 22 ): %vreg7 = Copy %xmm0
 23 ( 23 ): %xmm0 = MOVSDrm64 f64 0
 24 ( 24 ): %xmm1 = MOVSDrm64 f64 -0.5
 25 ( 25 ): %xmm2 = MOVSDrr %vreg7
 26 ( 26 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 27 ( 27 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 28 ( 28 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 29 ( 29 ): %vreg8 = Copy %rax
 30 ( 30 ): %xmm0 = MOVSDrm64 f64 1
 31 ( 31 ): %xmm1 = MOVSDrm64 f64 0
 32 ( 32 ): %xmm2 = MOVSDrm64 f64 0
 33 ( 33 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 34 ( 34 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 35 ( 35 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 36 ( 36 ): %vreg9 = Copy %rax
 37 ( 37 ): %xmm0 = MOVSDrm64 f64 0.5
 38 ( 38 ): %rsi = MOVrr64 %vreg8
 39 ( 39 ): %rdx = MOVrr64 %vreg9
 40 ( 40 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 41 ( 41 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
 42 ( 42 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 43 ( 43 ): %vreg10 = Copy %rax
 44 ( 44 ): MOVmr64 Base(%vreg6), %vreg10
 45 ( 45 ): %vreg11 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 46 ( 46 ): %vreg12 = ADDr64i32 %vreg11, i32 16 (tie:%vreg12->%vreg11,)
 47 ( 47 ): %xmm0 = MOVSDrm64 f64 6.66
 48 ( 48 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 49 ( 49 ): %xmm0 = CALL Address(addr<fn:cilk.cos.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 50 ( 50 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 51 ( 51 ): %vreg13 = Copy %xmm0
 52 ( 52 ): %xmm0 = MOVSDrm64 f64 2
 53 ( 53 ): %xmm1 = MOVSDrm64 f64 0
 54 ( 54 ): %xmm2 = MOVSDrr %vreg13
 55 ( 55 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 56 ( 56 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 57 ( 57 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 58 ( 58 ): %vreg14 = Copy %rax
 59 ( 59 ): %xmm0 = MOVSDrm64 f64 0
 60 ( 60 ): %xmm1 = MOVSDrm64 f64 1
 61 ( 61 ): %xmm2 = MOVSDrm64 f64 0
 62 ( 62 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 63 ( 63 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 64 ( 64 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 65 ( 65 ): %vreg15 = Copy %rax
 66 ( 66 ): %xmm0 = MOVSDrm64 f64 1
 67 ( 67 ): %rsi = MOVrr64 %vreg14
 68 ( 68 ): %rdx = MOVrr64 %vreg15
 69 ( 69 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 70 ( 70 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
 71 ( 71 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 72 ( 72 ): %vreg16 = Copy %rax
 73 ( 73 ): MOVmr64 Base(%vreg12), %vreg16
 74 ( 74 ): %vreg17 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 75 ( 75 ): %vreg18 = ADDr64i32 %vreg17, i32 24 (tie:%vreg18->%vreg17,)
 76 ( 76 ): %xmm0 = MOVSDrm64 f64 3.33
 77 ( 77 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 78 ( 78 ): %xmm0 = CALL Address(addr<fn:cilk.cos.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 79 ( 79 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 80 ( 80 ): %vreg19 = Copy %xmm0
 81 ( 81 ): %xmm0 = MOVSDrm64 f64 -2
 82 ( 82 ): %xmm1 = MOVSDrm64 f64 0.5
 83 ( 83 ): %xmm2 = MOVSDrr %vreg19
 84 ( 84 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 85 ( 85 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 86 ( 86 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 87 ( 87 ): %vreg20 = Copy %rax
 88 ( 88 ): %xmm0 = MOVSDrm64 f64 0
 89 ( 89 ): %xmm1 = MOVSDrm64 f64 0
 90 ( 90 ): %xmm2 = MOVSDrm64 f64 1
 91 ( 91 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 92 ( 92 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 93 ( 93 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 94 ( 94 ): %vreg21 = Copy %rax
 95 ( 95 ): %xmm0 = MOVSDrm64 f64 1.5
 96 ( 96 ): %rsi = MOVrr64 %vreg20
 97 ( 97 ): %rdx = MOVrr64 %vreg21
 98 ( 98 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 99 ( 99 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
100 (100 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
101 (101 ): %vreg22 = Copy %rax
102 (102 ): MOVmr64 Base(%vreg18), %vreg22
103 (103 ): %vreg23 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
104 (104 ): %vreg24 = ADDr64i32 %vreg23, i32 32 (tie:%vreg24->%vreg23,)
105 (105 ): %xmm0 = MOVSDrm64 f64 0
106 (106 ): %xmm1 = MOVSDrm64 f64 -1
107 (107 ): %xmm2 = MOVSDrm64 f64 0
108 (108 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
109 (109 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
110 (110 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
111 (111 ): %vreg25 = Copy %rax
112 (112 ): %xmm0 = MOVSDrm64 f64 0
113 (113 ): %xmm1 = MOVSDrm64 f64 1
114 (114 ): %xmm2 = MOVSDrm64 f64 0
115 (115 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
116 (116 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
117 (117 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
118 (118 ): %vreg26 = Copy %rax
119 (119 ): %xmm0 = MOVSDrm64 f64 1
120 (120 ): %xmm1 = MOVSDrm64 f64 1
121 (121 ): %xmm2 = MOVSDrm64 f64 1
122 (122 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
123 (123 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
124 (124 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
125 (125 ): %vreg27 = Copy %rax
126 (126 ): %rdi = MOVrr64 %vreg25
127 (127 ): %rsi = MOVrr64 %vreg26
128 (128 ): %rdx = MOVrr64 %vreg27
129 (129 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
130 (130 ): %rax = CALL Address(addr<fn:Plane_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
131 (131 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
132 (132 ): %vreg28 = Copy %rax
133 (133 ): MOVmr64 Base(%vreg24), %vreg28
134 (134 ): %vreg29 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
135 (135 ): %rax = MOVrr64 %vreg29
136 (136 ): RET 
MachineFunction(name: color_of, ty: i32 (f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }] } })
 0  ( 0  ): %edi = MOVri32 i32 256
 1  ( 1  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 2  ( 2  ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 3  ( 3  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 4  ( 4  ): %vreg1 = Copy %xmm0
 5  ( 5  ): %vreg2 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 6  ( 6  ): %xmm0 = MOVSDrr %vreg2
 7  ( 7  ): %xmm1 = MOVSDrm64 f64 0
 8  ( 8  ): %xmm2 = MOVSDrm64 f64 1
 9  ( 9  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 10 ( 10 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 11 ( 11 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 12 ( 12 ): %vreg3 = Copy %xmm0
 13 ( 13 ): %vreg4 = MULSDrr %vreg1, %vreg3 (tie:%vreg4->%vreg1,)
 14 ( 14 ): %xmm0 = MOVSDrr %vreg4
 15 ( 15 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 16 ( 16 ): %eax = CALL Address(addr<fn:cilk.f64_to_i32.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 17 ( 17 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 18 ( 18 ): %vreg5 = Copy %eax
 19 ( 19 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(0)>), %vreg5
 20 ( 20 ): %vreg6 = MOVrm32 BaseFi(%rbp, FI<i32, Local(0)>)
 21 ( 21 ): CMPri %vreg6, i32 256
 22 ( 22 ): JE BB#1
 23 ( 23 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 24 }, Id { idx: 25 }] } })
 24 ( 24 ): %eax = MOVri32 i32 255
 25 ( 25 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }] } })
 26 ( 26 ): %vreg7 = MOVrm32 BaseFi(%rbp, FI<i32, Local(0)>)
 27 ( 27 ): %eax = MOVrr32 %vreg7
 28 ( 28 ): RET 
MachineFunction(name: print_col, ty: i32 (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }] } })
 0  ( 0  ): %eax = MOVri32 i32 0
 1  ( 1  ): RET 
MachineFunction(name: main, ty: i32 ()):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }], iseq: RefCell { value: [Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }] } })
 0  ( 0  ): %vreg1 = LEAr64m BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 1  ( 1  ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 2  ( 2  ): %rax = CALL Address(addr<fn:Env_new>) (imp-def:%rsp,imp-use:%rsp,)
 3  ( 3  ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 4  ( 4  ): %vreg2 = Copy %rax
 5  ( 5  ): MOVmr64 Base(%vreg1), %vreg2
 6  ( 6  ): MOVmi32 BaseFi(%rbp, FI<i32, Local(1)>), i32 0
 7  ( 7  ): JMP BB#1
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }, Id { idx: 13 }], succ: [Id { idx: 2 }, Id { idx: 14 }], iseq: RefCell { value: [Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }] } })
 8  ( 8  ): %vreg3 = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
 9  ( 9  ): CMPri %vreg3, i32 12
 10 ( 10 ): JL BB#2
 11 ( 11 ): JMP BB#14
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 1 }], succ: [Id { idx: 3 }], iseq: RefCell { value: [Id { idx: 12 }, Id { idx: 13 }] } })
 12 ( 12 ): MOVmi32 BaseFi(%rbp, FI<i32, Local(2)>), i32 0
 13 ( 13 ): JMP BB#3
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }, Id { idx: 12 }], succ: [Id { idx: 4 }, Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }] } })
 14 ( 14 ): %vreg4 = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
 15 ( 15 ): CMPri %vreg4, i32 12
 16 ( 16 ): JL BB#4
 17 ( 17 ): JMP BB#13
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 3 }], succ: [Id { idx: 5 }, Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 54 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }, Id { idx: 62 }, Id { idx: 63 }, Id { idx: 64 }, Id { idx: 65 }, Id { idx: 66 }, Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }, Id { idx: 72 }, Id { idx: 73 }, Id { idx: 74 }, Id { idx: 75 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }, Id { idx: 81 }, Id { idx: 82 }, Id { idx: 83 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 88 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 94 }, Id { idx: 95 }, Id { idx: 96 }, Id { idx: 97 }, Id { idx: 98 }, Id { idx: 99 }, Id { idx: 100 }, Id { idx: 101 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 107 }, Id { idx: 108 }, Id { idx: 109 }, Id { idx: 110 }, Id { idx: 111 }, Id { idx: 112 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 115 }, Id { idx: 116 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 120 }, Id { idx: 121 }, Id { idx: 122 }, Id { idx: 123 }, Id { idx: 124 }, Id { idx: 125 }, Id { idx: 126 }, Id { idx: 127 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }] } })
 18 ( 18 ): %vreg5 = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
 19 ( 19 ): %vreg6 = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
 20 ( 20 ): %edi = MOVrr32 %vreg6
 21 ( 21 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 22 ( 22 ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 23 ( 23 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 24 ( 24 ): %vreg7 = Copy %xmm0
 25 ( 25 ): %vreg8 = MOVSDrm64 f64 12
 26 ( 26 ): %vreg9 = DIVSDrr %vreg7, %vreg8 (tie:%vreg9->%vreg7,)
 27 ( 27 ): %vreg10 = MOVSDrm64 f64 20
 28 ( 28 ): %vreg11 = DIVSDrr %vreg9, %vreg10 (tie:%vreg11->%vreg9,)
 29 ( 29 ): %vreg12 = MOVSDrm64 f64 1
 30 ( 30 ): %vreg13 = SUBSDrr %vreg11, %vreg12 (tie:%vreg13->%vreg11,)
 31 ( 31 ): MOVSDmr Base(%vreg5), %vreg13
 32 ( 32 ): %vreg14 = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
 33 ( 33 ): %vreg15 = MOVri32 i32 12
 34 ( 34 ): %vreg16 = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
 35 ( 35 ): %vreg17 = SUBrr32 %vreg15, %vreg16 (tie:%vreg17->%vreg15,)
 36 ( 36 ): %edi = MOVrr32 %vreg17
 37 ( 37 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 38 ( 38 ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 39 ( 39 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 40 ( 40 ): %vreg18 = Copy %xmm0
 41 ( 41 ): %vreg19 = MOVSDrm64 f64 12
 42 ( 42 ): %vreg20 = DIVSDrr %vreg18, %vreg19 (tie:%vreg20->%vreg18,)
 43 ( 43 ): %vreg21 = MOVSDrm64 f64 2
 44 ( 44 ): %vreg22 = DIVSDrr %vreg20, %vreg21 (tie:%vreg22->%vreg20,)
 45 ( 45 ): %vreg23 = MOVSDrm64 f64 1
 46 ( 46 ): %vreg24 = SUBSDrr %vreg22, %vreg23 (tie:%vreg24->%vreg22,)
 47 ( 47 ): MOVSDmr Base(%vreg14), %vreg24
 48 ( 48 ): %vreg25 = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
 49 ( 49 ): %xmm0 = MOVSDrm64 f64 0
 50 ( 50 ): %xmm1 = MOVSDrm64 f64 2
 51 ( 51 ): %xmm2 = MOVSDrm64 f64 6
 52 ( 52 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 53 ( 53 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 54 ( 54 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 55 ( 55 ): %vreg26 = Copy %rax
 56 ( 56 ): %vreg27 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 57 ( 57 ): %vreg28 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 58 ( 58 ): %xmm0 = MOVSDrr %vreg27
 59 ( 59 ): %xmm1 = MOVSDrr %vreg28
 60 ( 60 ): %xmm2 = MOVSDrm64 f64 -1
 61 ( 61 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 62 ( 62 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 63 ( 63 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 64 ( 64 ): %vreg29 = Copy %rax
 65 ( 65 ): %rdi = MOVrr64 %vreg29
 66 ( 66 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 67 ( 67 ): %rax = CALL Address(addr<fn:Vec_normalize>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
 68 ( 68 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 69 ( 69 ): %vreg30 = Copy %rax
 70 ( 70 ): %rdi = MOVrr64 %vreg26
 71 ( 71 ): %rsi = MOVrr64 %vreg30
 72 ( 72 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 73 ( 73 ): %rax = CALL Address(addr<fn:Ray_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 74 ( 74 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 75 ( 75 ): %vreg31 = Copy %rax
 76 ( 76 ): MOVmr64 Base(%vreg25), %vreg31
 77 ( 77 ): %vreg32 = LEAr64m BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
 78 ( 78 ): %xmm0 = MOVSDrm64 f64 0
 79 ( 79 ): %xmm1 = MOVSDrm64 f64 0
 80 ( 80 ): %xmm2 = MOVSDrm64 f64 0
 81 ( 81 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 82 ( 82 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 83 ( 83 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 84 ( 84 ): %vreg33 = Copy %rax
 85 ( 85 ): %xmm0 = MOVSDrm64 f64 0
 86 ( 86 ): %xmm1 = MOVSDrm64 f64 0
 87 ( 87 ): %xmm2 = MOVSDrm64 f64 0
 88 ( 88 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 89 ( 89 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 90 ( 90 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 91 ( 91 ): %vreg34 = Copy %rax
 92 ( 92 ): %xmm0 = MOVSDrm64 f64 0
 93 ( 93 ): %xmm1 = MOVSDrm64 f64 0
 94 ( 94 ): %xmm2 = MOVSDrm64 f64 0
 95 ( 95 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
 96 ( 96 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 97 ( 97 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
 98 ( 98 ): %vreg35 = Copy %rax
 99 ( 99 ): %xmm0 = MOVSDrm64 f64 0
100 (100 ): %xmm1 = MOVSDrm64 f64 0
101 (101 ): %xmm2 = MOVSDrm64 f64 0
102 (102 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
103 (103 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
104 (104 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
105 (105 ): %vreg36 = Copy %rax
106 (106 ): %edi = MOVri32 i32 0
107 (107 ): %rsi = MOVrr64 %vreg33
108 (108 ): %rdx = MOVrr64 %vreg34
109 (109 ): %rcx = MOVrr64 %vreg35
110 (110 ): %xmm4 = MOVSDrm64 f64 10000000
111 (111 ): %r9 = MOVrr64 %vreg36
112 (112 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
113 (113 ): %rax = CALL Address(addr<fn:Isect_new>) (imp-def:%rsp,imp-use:%rsp,%edi,%rsi,%rdx,%rcx,%xmm4,%r9,)
114 (114 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
115 (115 ): %vreg37 = Copy %rax
116 (116 ): MOVmr64 Base(%vreg32), %vreg37
117 (117 ): %vreg38 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
118 (118 ): %vreg39 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
119 (119 ): %vreg40 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
120 (120 ): %rdi = MOVrr64 %vreg38
121 (121 ): %rsi = MOVrr64 %vreg39
122 (122 ): %rdx = MOVrr64 %vreg40
123 (123 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
124 (124 ): %eax = CALL Address(addr<fn:Env_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
125 (125 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
126 (126 ): %vreg41 = Copy %eax
127 (127 ): %vreg42 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
128 (128 ): %vreg43 = MOVrm32 Base(%vreg42)
129 (129 ): CMPri %vreg43, i32 0
130 (130 ): JG BB#5
131 (131 ): JMP BB#11
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 132 }, Id { idx: 133 }, Id { idx: 134 }, Id { idx: 135 }, Id { idx: 136 }, Id { idx: 137 }, Id { idx: 138 }, Id { idx: 139 }, Id { idx: 140 }, Id { idx: 141 }, Id { idx: 142 }, Id { idx: 143 }, Id { idx: 144 }, Id { idx: 145 }, Id { idx: 146 }, Id { idx: 147 }, Id { idx: 148 }, Id { idx: 149 }, Id { idx: 150 }, Id { idx: 151 }, Id { idx: 152 }, Id { idx: 153 }, Id { idx: 154 }, Id { idx: 155 }, Id { idx: 156 }] } })
132 (132 ): %vreg44 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
133 (133 ): %vreg45 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
134 (134 ): %vreg46 = ADDr64i32 %vreg45, i32 20 (tie:%vreg46->%vreg45,)
135 (135 ): %vreg47 = MOVrm64 Base(%vreg46)
136 (136 ): MOVmr64 Base(%vreg44), %vreg47
137 (137 ): %vreg48 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
138 (138 ): %xmm0 = MOVSDrm64 f64 1
139 (139 ): %xmm1 = MOVSDrm64 f64 1
140 (140 ): %xmm2 = MOVSDrm64 f64 1
141 (141 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
142 (142 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
143 (143 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
144 (144 ): %vreg49 = Copy %rax
145 (145 ): %vreg50 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
146 (146 ): %vreg51 = ADDr64i32 %vreg50, i32 20 (tie:%vreg51->%vreg50,)
147 (147 ): %vreg52 = MOVrm64 Base(%vreg51)
148 (148 ): %rdi = MOVrr64 %vreg49
149 (149 ): %rsi = MOVrr64 %vreg52
150 (150 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
151 (151 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
152 (152 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
153 (153 ): %vreg53 = Copy %rax
154 (154 ): MOVmr64 Base(%vreg48), %vreg53
155 (155 ): MOVmi32 BaseFi(%rbp, FI<i32, Local(9)>), i32 1
156 (156 ): JMP BB#6
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 5 }, Id { idx: 9 }], succ: [Id { idx: 7 }, Id { idx: 10 }], iseq: RefCell { value: [Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }, Id { idx: 160 }] } })
157 (157 ): %vreg54 = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
158 (158 ): CMPri %vreg54, i32 4
159 (159 ): JL BB#7
160 (160 ): JMP BB#10
MachineBasicBlock #7 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 6 }], succ: [Id { idx: 8 }, Id { idx: 9 }], iseq: RefCell { value: [Id { idx: 161 }, Id { idx: 162 }, Id { idx: 163 }, Id { idx: 164 }, Id { idx: 165 }, Id { idx: 166 }, Id { idx: 167 }, Id { idx: 168 }, Id { idx: 169 }, Id { idx: 170 }, Id { idx: 171 }, Id { idx: 172 }, Id { idx: 173 }, Id { idx: 174 }, Id { idx: 175 }, Id { idx: 176 }, Id { idx: 177 }, Id { idx: 178 }, Id { idx: 179 }, Id { idx: 180 }, Id { idx: 181 }, Id { idx: 182 }, Id { idx: 183 }, Id { idx: 184 }, Id { idx: 185 }, Id { idx: 186 }, Id { idx: 187 }, Id { idx: 188 }, Id { idx: 189 }, Id { idx: 190 }, Id { idx: 191 }, Id { idx: 192 }, Id { idx: 193 }, Id { idx: 194 }, Id { idx: 195 }, Id { idx: 196 }, Id { idx: 197 }, Id { idx: 198 }, Id { idx: 199 }, Id { idx: 200 }, Id { idx: 201 }, Id { idx: 202 }, Id { idx: 203 }, Id { idx: 204 }, Id { idx: 205 }, Id { idx: 206 }, Id { idx: 207 }, Id { idx: 208 }, Id { idx: 209 }, Id { idx: 210 }, Id { idx: 211 }, Id { idx: 212 }, Id { idx: 213 }, Id { idx: 214 }] } })
161 (161 ): %vreg55 = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(10)>)
162 (162 ): %vreg56 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
163 (163 ): %vreg57 = ADDr64i32 %vreg56, i32 4 (tie:%vreg57->%vreg56,)
164 (164 ): %vreg58 = MOVrm64 Base(%vreg57)
165 (165 ): %vreg59 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
166 (166 ): %vreg60 = ADDr64i32 %vreg59, i32 12 (tie:%vreg60->%vreg59,)
167 (167 ): %vreg61 = MOVrm64 Base(%vreg60)
168 (168 ): %rdi = MOVrr64 %vreg61
169 (169 ): %xmm1 = MOVSDrm64 f64 0.0001
170 (170 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
171 (171 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
172 (172 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
173 (173 ): %vreg62 = Copy %rax
174 (174 ): %rdi = MOVrr64 %vreg58
175 (175 ): %rsi = MOVrr64 %vreg62
176 (176 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
177 (177 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
178 (178 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
179 (179 ): %vreg63 = Copy %rax
180 (180 ): %vreg64 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
181 (181 ): %vreg65 = ADDr64i32 %vreg64, i32 36 (tie:%vreg65->%vreg64,)
182 (182 ): %vreg66 = MOVrm64 Base(%vreg65)
183 (183 ): %vreg67 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
184 (184 ): %vreg68 = ADDr64i32 %vreg67, i32 12 (tie:%vreg68->%vreg67,)
185 (185 ): %vreg69 = MOVrm64 Base(%vreg68)
186 (186 ): %rdi = MOVrr64 %vreg66
187 (187 ): %rsi = MOVrr64 %vreg69
188 (188 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
189 (189 ): %rax = CALL Address(addr<fn:Vec_reflect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
190 (190 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
191 (191 ): %vreg70 = Copy %rax
192 (192 ): %rdi = MOVrr64 %vreg63
193 (193 ): %rsi = MOVrr64 %vreg70
194 (194 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
195 (195 ): %rax = CALL Address(addr<fn:Ray_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
196 (196 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
197 (197 ): %vreg71 = Copy %rax
198 (198 ): MOVmr64 Base(%vreg55), %vreg71
199 (199 ): %vreg72 = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
200 (200 ): %vreg73 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(10)>)
201 (201 ): %vreg74 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
202 (202 ): %rdi = MOVrr64 %vreg72
203 (203 ): %rsi = MOVrr64 %vreg73
204 (204 ): %rdx = MOVrr64 %vreg74
205 (205 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
206 (206 ): %eax = CALL Address(addr<fn:Env_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
207 (207 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
208 (208 ): %vreg75 = Copy %eax
209 (209 ): %vreg76 = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
210 (210 ): %vreg77 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
211 (211 ): %vreg78 = MOVrm32 Base(%vreg77)
212 (212 ): CMPrr %vreg76, %vreg78
213 (213 ): JL BB#8
214 (214 ): JMP BB#9
MachineBasicBlock #8 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 7 }], succ: [Id { idx: 9 }], iseq: RefCell { value: [Id { idx: 215 }, Id { idx: 216 }, Id { idx: 217 }, Id { idx: 218 }, Id { idx: 219 }, Id { idx: 220 }, Id { idx: 221 }, Id { idx: 222 }, Id { idx: 223 }, Id { idx: 224 }, Id { idx: 225 }, Id { idx: 226 }, Id { idx: 227 }, Id { idx: 228 }, Id { idx: 229 }, Id { idx: 230 }, Id { idx: 231 }, Id { idx: 232 }, Id { idx: 233 }, Id { idx: 234 }, Id { idx: 235 }, Id { idx: 236 }, Id { idx: 237 }, Id { idx: 238 }, Id { idx: 239 }, Id { idx: 240 }, Id { idx: 241 }, Id { idx: 242 }, Id { idx: 243 }, Id { idx: 244 }] } })
215 (215 ): %vreg79 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
216 (216 ): %vreg80 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
217 (217 ): %vreg81 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
218 (218 ): %vreg82 = ADDr64i32 %vreg81, i32 20 (tie:%vreg82->%vreg81,)
219 (219 ): %vreg83 = MOVrm64 Base(%vreg82)
220 (220 ): %rdi = MOVrr64 %vreg80
221 (221 ): %rsi = MOVrr64 %vreg83
222 (222 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
223 (223 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
224 (224 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
225 (225 ): %vreg84 = Copy %rax
226 (226 ): %rdi = MOVrr64 %vreg79
227 (227 ): %rsi = MOVrr64 %vreg84
228 (228 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
229 (229 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
230 (230 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
231 (231 ): %vreg85 = Copy %rax
232 (232 ): MOVmr64 Base(%vreg44), %vreg85
233 (233 ): %vreg86 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
234 (234 ): %vreg87 = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
235 (235 ): %vreg88 = ADDr64i32 %vreg87, i32 20 (tie:%vreg88->%vreg87,)
236 (236 ): %vreg89 = MOVrm64 Base(%vreg88)
237 (237 ): %rdi = MOVrr64 %vreg86
238 (238 ): %rsi = MOVrr64 %vreg89
239 (239 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
240 (240 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
241 (241 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
242 (242 ): %vreg90 = Copy %rax
243 (243 ): MOVmr64 Base(%vreg48), %vreg90
244 (244 ): JMP BB#9
MachineBasicBlock #9 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 7 }, Id { idx: 8 }], succ: [Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 245 }, Id { idx: 246 }, Id { idx: 247 }, Id { idx: 248 }] } })
245 (245 ): %vreg91 = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
246 (246 ): %vreg92 = ADDri32 %vreg91, i32 1 (tie:%vreg92->%vreg91,)
247 (247 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(9)>), %vreg92
248 (248 ): JMP BB#6
MachineBasicBlock #10 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 6 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 249 }, Id { idx: 250 }, Id { idx: 251 }, Id { idx: 252 }, Id { idx: 253 }, Id { idx: 254 }, Id { idx: 255 }] } })
249 (249 ): %vreg93 = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
250 (250 ): %rdi = MOVrr64 %vreg93
251 (251 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
252 (252 ): %eax = CALL Address(addr<fn:print_col>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
253 (253 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
254 (254 ): %vreg94 = Copy %eax
255 (255 ): JMP BB#12
MachineBasicBlock #11 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 256 }, Id { idx: 257 }, Id { idx: 258 }, Id { idx: 259 }, Id { idx: 260 }, Id { idx: 261 }, Id { idx: 262 }, Id { idx: 263 }, Id { idx: 264 }, Id { idx: 265 }, Id { idx: 266 }, Id { idx: 267 }, Id { idx: 268 }, Id { idx: 269 }, Id { idx: 270 }, Id { idx: 271 }, Id { idx: 272 }, Id { idx: 273 }, Id { idx: 274 }, Id { idx: 275 }, Id { idx: 276 }, Id { idx: 277 }, Id { idx: 278 }, Id { idx: 279 }, Id { idx: 280 }, Id { idx: 281 }, Id { idx: 282 }, Id { idx: 283 }] } })
256 (256 ): %vreg95 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
257 (257 ): %vreg96 = ADDr64i32 %vreg95, i32 8 (tie:%vreg96->%vreg95,)
258 (258 ): %vreg97 = MOVrm64 Base(%vreg96)
259 (259 ): %vreg98 = ADDr64i32 %vreg97, i32 8 (tie:%vreg98->%vreg97,)
260 (260 ): %vreg99 = MOVSDrm Base(%vreg98)
261 (261 ): %vreg100 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
262 (262 ): %vreg101 = ADDr64i32 %vreg100, i32 8 (tie:%vreg101->%vreg100,)
263 (263 ): %vreg102 = MOVrm64 Base(%vreg101)
264 (264 ): %vreg103 = ADDr64i32 %vreg102, i32 8 (tie:%vreg103->%vreg102,)
265 (265 ): %vreg104 = MOVSDrm Base(%vreg103)
266 (266 ): %vreg105 = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
267 (267 ): %vreg106 = ADDr64i32 %vreg105, i32 8 (tie:%vreg106->%vreg105,)
268 (268 ): %vreg107 = MOVrm64 Base(%vreg106)
269 (269 ): %vreg108 = ADDr64i32 %vreg107, i32 8 (tie:%vreg108->%vreg107,)
270 (270 ): %vreg109 = MOVSDrm Base(%vreg108)
271 (271 ): %xmm0 = MOVSDrr %vreg99
272 (272 ): %xmm1 = MOVSDrr %vreg104
273 (273 ): %xmm2 = MOVSDrr %vreg109
274 (274 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
275 (275 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
276 (276 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
277 (277 ): %vreg110 = Copy %rax
278 (278 ): %rdi = MOVrr64 %vreg110
279 (279 ): AdjStackDown i32 0 (imp-def:%rsp,imp-use:%rsp,)
280 (280 ): %eax = CALL Address(addr<fn:print_col>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
281 (281 ): AdjStackUp i32 0 (imp-def:%rsp,imp-use:%rsp,)
282 (282 ): %vreg111 = Copy %eax
283 (283 ): JMP BB#12
MachineBasicBlock #12 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 10 }, Id { idx: 11 }], succ: [Id { idx: 3 }], iseq: RefCell { value: [Id { idx: 284 }, Id { idx: 285 }, Id { idx: 286 }, Id { idx: 287 }] } })
284 (284 ): %vreg112 = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
285 (285 ): %vreg113 = ADDri32 %vreg112, i32 1 (tie:%vreg113->%vreg112,)
286 (286 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(2)>), %vreg113
287 (287 ): JMP BB#3
MachineBasicBlock #13 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 3 }], succ: [Id { idx: 1 }], iseq: RefCell { value: [Id { idx: 288 }, Id { idx: 289 }, Id { idx: 290 }, Id { idx: 291 }] } })
288 (288 ): %vreg114 = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
289 (289 ): %vreg115 = ADDri32 %vreg114, i32 1 (tie:%vreg115->%vreg114,)
290 (290 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(1)>), %vreg115
291 (291 ): JMP BB#1
MachineBasicBlock #14 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 1 }], succ: [], iseq: RefCell { value: [Id { idx: 292 }, Id { idx: 293 }] } })
292 (292 ): %eax = MOVri32 i32 0
293 (293 ): RET 

>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:480, end: 0:512 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:432, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:144, end: 0:224 }, LiveSegment { start: 0:432, end: 0:480 }] })
>>%xmm2
-Some(LiveRange { segments: [LiveSegment { start: 0:448, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:16, end: 0:64 }, LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:144, end: 0:224 }, LiveSegment { start: 0:432, end: 0:480 }] })
>>%xmm2
-Some(LiveRange { segments: [LiveSegment { start: 0:64, end: 0:416 }, LiveSegment { start: 0:448, end: 0:480 }] })
>>%xmm3
-None
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:176, end: 0:208 }, LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:16, end: 0:64 }, LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:144, end: 0:224 }, LiveSegment { start: 0:432, end: 0:480 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:112, end: 0:144 }, LiveSegment { start: 0:176, end: 0:208 }, LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:16, end: 0:64 }, LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:16, end: 0:64 }, LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:368, end: 0:400 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:48, end: 0:80 }, LiveSegment { start: 0:144, end: 0:224 }, LiveSegment { start: 0:432, end: 0:480 }] })
>>%xmm0
-Some(LiveRange { segments: [LiveSegment { start: 0:16, end: 0:64 }, LiveSegment { start: 0:208, end: 0:240 }, LiveSegment { start: 0:368, end: 0:400 }, LiveSegment { start: 0:416, end: 0:480 }] })
>>%xmm1
-Some(LiveRange { segments: [LiveSegment { start: 0:48, end: 0:80 }, LiveSegment { start: 0:144, end: 0:224 }, LiveSegment { start: 0:304, end: 0:384 }, LiveSegment { start: 0:432, end: 0:480 }] })
>>%xmm2
-Some(LiveRange { segments: [LiveSegment { start: 0:64, end: 0:416 }, LiveSegment { start: 0:448, end: 0:480 }] })
>>%xmm3
-Some(LiveRange { segments: [LiveSegment { start: 0:384, end: 0:448 }] })
>>%xmm4
-None
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:0, end: 0:16 }, LiveSegment { start: 0:112, end: 0:144 }, LiveSegment { start: 0:176, end: 0:208 }, LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:0, end: 0:16 }, LiveSegment { start: 0:112, end: 0:144 }, LiveSegment { start: 0:160, end: 0:176 }, LiveSegment { start: 0:176, end: 0:208 }, LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
>>%rax
-Some(LiveRange { segments: [LiveSegment { start: 0:0, end: 0:16 }, LiveSegment { start: 0:96, end: 0:112 }, LiveSegment { start: 0:112, end: 0:144 }, LiveSegment { start: 0:160, end: 0:176 }, LiveSegment { start: 0:176, end: 0:208 }, LiveSegment { start: 0:256, end: 0:272 }, LiveSegment { start: 0:272, end: 0:304 }, LiveSegment { start: 0:320, end: 0:336 }, LiveSegment { start: 0:336, end: 0:368 }, LiveSegment { start: 0:480, end: 0:528 }, LiveSegment { start: 0:528, end: 0:528 }] })
Debug at /home/unsigned/work/cilk/src/codegen/x64/exec/jit.rs
MachineModule (name: minilang)
MachineFunction(name: cilk.println.i32, ty: void (i32, )):
MachineFunction(name: cilk.printch.i32, ty: void (i32, )):
MachineFunction(name: cilk.println.f64, ty: void (f64, )):
MachineFunction(name: cilk.sin.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.cos.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.sqrt.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.floor.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.fabs.f64, ty: f64 (f64, )):
MachineFunction(name: cilk.i32_to_f64.i32, ty: f64 (i32, )):
MachineFunction(name: cilk.f64_to_i32.f64, ty: i32 (f64, )):
MachineFunction(name: cilk.malloc.i32, ty: i64* (i32, )):
MachineFunction(name: clamp, ty: f64 (f64, f64, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg1, %vreg2}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }] } })
 0  ( 19 ): PUSH64 %rbp
 1  ( 20 ): %rbp = MOVrr64 %rsp
 2  ( 21 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 22 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(0)>), %xmm0
 4  ( 23 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(1)>), %xmm1
 5  ( 24 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(2)>), %xmm2
 6  ( 0  ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 7  ( 1  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 8  ( 2  ): UCOMISDrr %xmm1, %xmm0
 9  ( 3  ): JB BB#1
 10 ( 4  ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001000000000000000]), def: {%vreg3}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 5 }, Id { idx: 6 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 7 }] } })
 11 ( 5  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 12 ( 6  ): %xmm0 = MOVSDrr %xmm0
 13 ( 25 ): %rsp = MOVrr64 %rbp
 14 ( 26 ): POP64 %rbp
 15 ( 7  ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg4, %vreg5}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }] } })
 16 ( 8  ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 17 ( 9  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 18 ( 10 ): UCOMISDrr %xmm1, %xmm0
 19 ( 11 ): JB BB#3
 20 ( 12 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001000000000000000]), def: {%vreg6}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 13 }, Id { idx: 14 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 15 }] } })
 21 ( 13 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 22 ( 14 ): %xmm0 = MOVSDrr %xmm0
 23 ( 27 ): %rsp = MOVrr64 %rbp
 24 ( 28 ): POP64 %rbp
 25 ( 15 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001000000000000000]), def: {%vreg7}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 16 }, Id { idx: 17 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 18 }] } })
 26 ( 16 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 27 ( 17 ): %xmm0 = MOVSDrr %xmm0
 28 ( 29 ): %rsp = MOVrr64 %rbp
 29 ( 30 ): POP64 %rbp
 30 ( 18 ): RET 
MachineFunction(name: Vec_new, ty: struct {f64, f64, f64}* (f64, f64, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011000000001000000000000000]), def: {%vreg10, %vreg7, %vreg4, %vreg1, %vreg11, %vreg8, %vreg5, %vreg2, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 23 }, Id { idx: 3 }, Id { idx: 24 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 21 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 22 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 20 }] } })
 0  ( 25 ): PUSH64 %rbp
 1  ( 26 ): %rbp = MOVrr64 %rsp
 2  ( 27 ): %rsp = SUBr64i32 %rsp, i32 48
 3  ( 28 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(0)>), %xmm0
 4  ( 29 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(1)>), %xmm1
 5  ( 30 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(2)>), %xmm2
 6  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 7  ( 1  ): %edi = MOVri32 i32 128
 8  ( 23 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 9  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 10 ( 24 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 11 ( 6  ): MOVmr64 Base(%rcx), %rax
 12 ( 7  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 13 ( 8  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 14 ( 9  ): MOVSDmr Base(%rax), %xmm0
 15 ( 10 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 16 ( 21 ): %rax = ADDr64i32 %rax, i32 8
 17 ( 12 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 18 ( 13 ): MOVSDmr Base(%rax), %xmm0
 19 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 20 ( 22 ): %rax = ADDr64i32 %rax, i32 16
 21 ( 16 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(2)>)
 22 ( 17 ): MOVSDmr Base(%rax), %xmm0
 23 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 24 ( 31 ): %rsp = MOVrr64 %rbp
 25 ( 32 ): POP64 %rbp
 26 ( 20 ): RET 
MachineFunction(name: Vec_add, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001111100000000000]), def: {%vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 28 }, Id { idx: 5 }, Id { idx: 29 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 30 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 31 }, Id { idx: 12 }, Id { idx: 32 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 33 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 34 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 23 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 27 }] } })
 0  ( 35 ): PUSH64 %rbp
 1  ( 36 ): %rbp = MOVrr64 %rsp
 2  ( 37 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 38 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 39 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 7  ( 2  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 8  ( 3  ): %xmm1 = MOVSDrm Base(%rax)
 9  ( 4  ): %xmm2 = MOVSDrr %xmm0
 10 ( 28 ): %xmm2 = ADDSDrr %xmm2, %xmm1
 11 ( 5  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 12 ( 29 ): %rax = ADDr64i32 %rax, i32 8
 13 ( 7  ): %xmm1 = MOVSDrm Base(%rax)
 14 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 15 ( 30 ): %rax = ADDr64i32 %rax, i32 8
 16 ( 10 ): %xmm0 = MOVSDrm Base(%rax)
 17 ( 11 ): %xmm4 = MOVSDrr %xmm1
 18 ( 31 ): %xmm4 = ADDSDrr %xmm4, %xmm0
 19 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 20 ( 32 ): %rax = ADDr64i32 %rax, i32 16
 21 ( 14 ): %xmm1 = MOVSDrm Base(%rax)
 22 ( 15 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 23 ( 33 ): %rax = ADDr64i32 %rax, i32 16
 24 ( 17 ): %xmm0 = MOVSDrm Base(%rax)
 25 ( 18 ): %xmm3 = MOVSDrr %xmm1
 26 ( 34 ): %xmm3 = ADDSDrr %xmm3, %xmm0
 27 ( 19 ): %xmm0 = MOVSDrr %xmm2
 28 ( 20 ): %xmm1 = MOVSDrr %xmm4
 29 ( 21 ): %xmm2 = MOVSDrr %xmm3
 30 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 31 ( 40 ): %rsp = MOVrr64 %rbp
 32 ( 41 ): POP64 %rbp
 33 ( 27 ): RET 
MachineFunction(name: Vec_sub, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001111100000000000]), def: {%vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 28 }, Id { idx: 5 }, Id { idx: 29 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 30 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 31 }, Id { idx: 12 }, Id { idx: 32 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 33 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 34 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 23 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 27 }] } })
 0  ( 35 ): PUSH64 %rbp
 1  ( 36 ): %rbp = MOVrr64 %rsp
 2  ( 37 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 38 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 39 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 7  ( 2  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 8  ( 3  ): %xmm1 = MOVSDrm Base(%rax)
 9  ( 4  ): %xmm2 = MOVSDrr %xmm0
 10 ( 28 ): %xmm2 = SUBSDrr %xmm2, %xmm1
 11 ( 5  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 12 ( 29 ): %rax = ADDr64i32 %rax, i32 8
 13 ( 7  ): %xmm1 = MOVSDrm Base(%rax)
 14 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 15 ( 30 ): %rax = ADDr64i32 %rax, i32 8
 16 ( 10 ): %xmm0 = MOVSDrm Base(%rax)
 17 ( 11 ): %xmm4 = MOVSDrr %xmm1
 18 ( 31 ): %xmm4 = SUBSDrr %xmm4, %xmm0
 19 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 20 ( 32 ): %rax = ADDr64i32 %rax, i32 16
 21 ( 14 ): %xmm1 = MOVSDrm Base(%rax)
 22 ( 15 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 23 ( 33 ): %rax = ADDr64i32 %rax, i32 16
 24 ( 17 ): %xmm0 = MOVSDrm Base(%rax)
 25 ( 18 ): %xmm3 = MOVSDrr %xmm1
 26 ( 34 ): %xmm3 = SUBSDrr %xmm3, %xmm0
 27 ( 19 ): %xmm0 = MOVSDrr %xmm2
 28 ( 20 ): %xmm1 = MOVSDrr %xmm4
 29 ( 21 ): %xmm2 = MOVSDrr %xmm3
 30 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 31 ( 40 ): %rsp = MOVrr64 %rbp
 32 ( 41 ): POP64 %rbp
 33 ( 27 ): RET 
MachineFunction(name: Vec_mul, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001111100000000000]), def: {%vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 23 }, Id { idx: 4 }, Id { idx: 24 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 25 }, Id { idx: 9 }, Id { idx: 26 }, Id { idx: 11 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 27 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 18 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 22 }] } })
 0  ( 28 ): PUSH64 %rbp
 1  ( 29 ): %rbp = MOVrr64 %rsp
 2  ( 30 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 31 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 32 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(1)>), %xmm1
 5  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 7  ( 2  ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 8  ( 3  ): %xmm3 = MOVSDrr %xmm0
 9  ( 23 ): %xmm3 = MULSDrr %xmm3, %xmm1
 10 ( 4  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 11 ( 24 ): %rax = ADDr64i32 %rax, i32 8
 12 ( 6  ): %xmm1 = MOVSDrm Base(%rax)
 13 ( 7  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 14 ( 8  ): %xmm4 = MOVSDrr %xmm1
 15 ( 25 ): %xmm4 = MULSDrr %xmm4, %xmm0
 16 ( 9  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 17 ( 26 ): %rax = ADDr64i32 %rax, i32 16
 18 ( 11 ): %xmm1 = MOVSDrm Base(%rax)
 19 ( 12 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(1)>)
 20 ( 13 ): %xmm2 = MOVSDrr %xmm1
 21 ( 27 ): %xmm2 = MULSDrr %xmm2, %xmm0
 22 ( 14 ): %xmm0 = MOVSDrr %xmm3
 23 ( 15 ): %xmm1 = MOVSDrr %xmm4
 24 ( 16 ): %xmm2 = MOVSDrr %xmm2
 25 ( 18 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 26 ( 33 ): %rsp = MOVrr64 %rbp
 27 ( 34 ): POP64 %rbp
 28 ( 22 ): RET 
MachineFunction(name: Vec_multi, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001111100000000000]), def: {%vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 28 }, Id { idx: 5 }, Id { idx: 29 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 30 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 31 }, Id { idx: 12 }, Id { idx: 32 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 33 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 34 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 23 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 27 }] } })
 0  ( 35 ): PUSH64 %rbp
 1  ( 36 ): %rbp = MOVrr64 %rsp
 2  ( 37 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 38 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 39 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 7  ( 2  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 8  ( 3  ): %xmm1 = MOVSDrm Base(%rax)
 9  ( 4  ): %xmm2 = MOVSDrr %xmm0
 10 ( 28 ): %xmm2 = ADDSDrr %xmm2, %xmm1
 11 ( 5  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 12 ( 29 ): %rax = ADDr64i32 %rax, i32 8
 13 ( 7  ): %xmm1 = MOVSDrm Base(%rax)
 14 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 15 ( 30 ): %rax = ADDr64i32 %rax, i32 8
 16 ( 10 ): %xmm0 = MOVSDrm Base(%rax)
 17 ( 11 ): %xmm4 = MOVSDrr %xmm1
 18 ( 31 ): %xmm4 = ADDSDrr %xmm4, %xmm0
 19 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 20 ( 32 ): %rax = ADDr64i32 %rax, i32 16
 21 ( 14 ): %xmm1 = MOVSDrm Base(%rax)
 22 ( 15 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 23 ( 33 ): %rax = ADDr64i32 %rax, i32 16
 24 ( 17 ): %xmm0 = MOVSDrm Base(%rax)
 25 ( 18 ): %xmm3 = MOVSDrr %xmm1
 26 ( 34 ): %xmm3 = ADDSDrr %xmm3, %xmm0
 27 ( 19 ): %xmm0 = MOVSDrr %xmm2
 28 ( 20 ): %xmm1 = MOVSDrr %xmm4
 29 ( 21 ): %xmm2 = MOVSDrr %xmm3
 30 ( 23 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 31 ( 40 ): %rsp = MOVrr64 %rbp
 32 ( 41 ): POP64 %rbp
 33 ( 27 ): RET 
MachineFunction(name: Vec_dot, ty: f64 (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001110000000000000]), def: {%vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 4 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 29 }, Id { idx: 11 }, Id { idx: 30 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 31 }, Id { idx: 16 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 19 }, Id { idx: 34 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 35 }, Id { idx: 24 }, Id { idx: 36 }, Id { idx: 26 }, Id { idx: 37 }, Id { idx: 27 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 28 }] } })
 0  ( 38 ): PUSH64 %rbp
 1  ( 39 ): %rbp = MOVrr64 %rsp
 2  ( 40 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 41 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 42 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 7  ( 2  ): %xmm0 = MOVSDrr %xmm0
 8  ( 4  ): CALL Address(addr<fn:cilk.println.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 9  ( 6  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 10 ( 7  ): %xmm0 = MOVSDrm Base(%rax)
 11 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 12 ( 9  ): %xmm1 = MOVSDrm Base(%rax)
 13 ( 10 ): %xmm2 = MOVSDrr %xmm0
 14 ( 29 ): %xmm2 = MULSDrr %xmm2, %xmm1
 15 ( 11 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 16 ( 30 ): %rax = ADDr64i32 %rax, i32 8
 17 ( 13 ): %xmm0 = MOVSDrm Base(%rax)
 18 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 19 ( 31 ): %rax = ADDr64i32 %rax, i32 8
 20 ( 16 ): %xmm1 = MOVSDrm Base(%rax)
 21 ( 32 ): %xmm0 = MULSDrr %xmm0, %xmm1
 22 ( 33 ): %xmm2 = ADDSDrr %xmm2, %xmm0
 23 ( 19 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 24 ( 34 ): %rax = ADDr64i32 %rax, i32 16
 25 ( 21 ): %xmm1 = MOVSDrm Base(%rax)
 26 ( 22 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 27 ( 35 ): %rax = ADDr64i32 %rax, i32 16
 28 ( 24 ): %xmm0 = MOVSDrm Base(%rax)
 29 ( 36 ): %xmm1 = MULSDrr %xmm1, %xmm0
 30 ( 26 ): %xmm0 = MOVSDrr %xmm2
 31 ( 37 ): %xmm0 = ADDSDrr %xmm0, %xmm1
 32 ( 27 ): %xmm0 = MOVSDrr %xmm0
 33 ( 43 ): %rsp = MOVrr64 %rbp
 34 ( 44 ): POP64 %rbp
 35 ( 28 ): RET 
MachineFunction(name: Vec_reflect, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010110000000011111011110000001100000000000000]), def: {%vreg7, %vreg4, %vreg1, %vreg8, %vreg5, %vreg2, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 27 }, Id { idx: 29 }, Id { idx: 7 }, Id { idx: 30 }, Id { idx: 28 }, Id { idx: 10 }, Id { idx: 26 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 31 }, Id { idx: 15 }, Id { idx: 32 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 21 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 25 }] } })
 0  ( 33 ): PUSH64 %rbp
 1  ( 34 ): %rbp = MOVrr64 %rsp
 2  ( 35 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 36 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 37 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 1  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 7  ( 2  ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 8  ( 3  ): %rsi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 9  ( 27 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(0)>), %rcx
 10 ( 29 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rax
 11 ( 7  ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 12 ( 30 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 13 ( 28 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(0)>)
 14 ( 10 ): %xmm1 = MOVSDrm64 Address(label<data:0>)
 15 ( 26 ): %xmm0 = MULSDrr %xmm0, %xmm1
 16 ( 12 ): %rdi = MOVrr64 %rax
 17 ( 13 ): %xmm1 = MOVSDrr %xmm0
 18 ( 31 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(0)>), %rcx
 19 ( 15 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
 20 ( 32 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(0)>)
 21 ( 17 ): %rsi = MOVrr64 %rax
 22 ( 18 ): %rdi = MOVrr64 %rcx
 23 ( 21 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 24 ( 38 ): %rsp = MOVrr64 %rbp
 25 ( 39 ): POP64 %rbp
 26 ( 25 ): RET 
MachineFunction(name: Vec_length, ty: f64 (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010000000000010101010000000001110000000000000]), def: {%vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 37 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 40 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 28 }, Id { idx: 5 }, Id { idx: 29 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 30 }, Id { idx: 10 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 13 }, Id { idx: 33 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 34 }, Id { idx: 18 }, Id { idx: 35 }, Id { idx: 20 }, Id { idx: 36 }, Id { idx: 21 }, Id { idx: 23 }, Id { idx: 26 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 27 }] } })
 0  ( 37 ): PUSH64 %rbp
 1  ( 38 ): %rbp = MOVrr64 %rsp
 2  ( 39 ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 40 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 5  ( 1  ): %xmm0 = MOVSDrm Base(%rax)
 6  ( 2  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 7  ( 3  ): %xmm1 = MOVSDrm Base(%rax)
 8  ( 4  ): %xmm2 = MOVSDrr %xmm0
 9  ( 28 ): %xmm2 = MULSDrr %xmm2, %xmm1
 10 ( 5  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 11 ( 29 ): %rax = ADDr64i32 %rax, i32 8
 12 ( 7  ): %xmm1 = MOVSDrm Base(%rax)
 13 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 14 ( 30 ): %rax = ADDr64i32 %rax, i32 8
 15 ( 10 ): %xmm0 = MOVSDrm Base(%rax)
 16 ( 31 ): %xmm1 = MULSDrr %xmm1, %xmm0
 17 ( 32 ): %xmm2 = ADDSDrr %xmm2, %xmm1
 18 ( 13 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 19 ( 33 ): %rax = ADDr64i32 %rax, i32 16
 20 ( 15 ): %xmm0 = MOVSDrm Base(%rax)
 21 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 22 ( 34 ): %rax = ADDr64i32 %rax, i32 16
 23 ( 18 ): %xmm1 = MOVSDrm Base(%rax)
 24 ( 35 ): %xmm0 = MULSDrr %xmm0, %xmm1
 25 ( 20 ): %xmm1 = MOVSDrr %xmm2
 26 ( 36 ): %xmm1 = ADDSDrr %xmm1, %xmm0
 27 ( 21 ): %xmm0 = MOVSDrr %xmm1
 28 ( 23 ): %xmm0 = CALL Address(addr<fn:cilk.sqrt.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 29 ( 26 ): %xmm0 = MOVSDrr %xmm0
 30 ( 41 ): %rsp = MOVrr64 %rbp
 31 ( 42 ): POP64 %rbp
 32 ( 27 ): RET 
MachineFunction(name: Vec_normalize, ty: struct {f64, f64, f64}* (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010010000000010101011010000001100000000000000]), def: {%vreg5, %vreg2, %vreg4, %vreg1, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 54 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 52 }, Id { idx: 4 }, Id { idx: 53 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 12 }] } })
 0  ( 54 ): PUSH64 %rbp
 1  ( 55 ): %rbp = MOVrr64 %rsp
 2  ( 56 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 57 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 0  ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(0)>)
 5  ( 1  ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 6  ( 52 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rax
 7  ( 4  ): %xmm0 = CALL Address(addr<fn:Vec_length>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
 8  ( 53 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
 9  ( 7  ): MOVSDmr Base(%rax), %xmm0
 10 ( 8  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 11 ( 9  ): %xmm1 = MOVSDrm64 Address(label<data:1>)
 12 ( 10 ): UCOMISDrr %xmm0, %xmm1
 13 ( 11 ): JA BB#1
 14 ( 12 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110000000000000011110000000000001100000000000000]), def: {%vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 44 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 45 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 46 }, Id { idx: 26 }, Id { idx: 47 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 48 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 49 }, Id { idx: 34 }, Id { idx: 50 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 51 }, Id { idx: 39 }, Id { idx: 40 }] } })
 15 ( 13 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 16 ( 14 ): %xmm0 = MOVSDrm64 Address(label<data:2>)
 17 ( 15 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 18 ( 44 ): %xmm0 = DIVSDrr %xmm0, %xmm1
 19 ( 17 ): MOVSDmr Base(%rax), %xmm0
 20 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 21 ( 19 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 22 ( 20 ): %xmm1 = MOVSDrm Base(%rcx)
 23 ( 21 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 24 ( 45 ): %xmm1 = MULSDrr %xmm1, %xmm0
 25 ( 23 ): MOVSDmr Base(%rax), %xmm1
 26 ( 24 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 27 ( 46 ): %rax = ADDr64i32 %rax, i32 8
 28 ( 26 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 29 ( 47 ): %rcx = ADDr64i32 %rcx, i32 8
 30 ( 28 ): %xmm0 = MOVSDrm Base(%rcx)
 31 ( 29 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 32 ( 48 ): %xmm0 = MULSDrr %xmm0, %xmm1
 33 ( 31 ): MOVSDmr Base(%rax), %xmm0
 34 ( 32 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 35 ( 33 ): %rcx = MOVrr64 %rax
 36 ( 49 ): %rcx = ADDr64i32 %rcx, i32 16
 37 ( 34 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 38 ( 50 ): %rax = ADDr64i32 %rax, i32 16
 39 ( 36 ): %xmm0 = MOVSDrm Base(%rax)
 40 ( 37 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 41 ( 51 ): %xmm0 = MULSDrr %xmm0, %xmm1
 42 ( 39 ): MOVSDmr Base(%rcx), %xmm0
 43 ( 40 ): JMP BB#2
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010100000000000000000000000000000]), def: {%vreg29}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }, Id { idx: 1 }], succ: [], iseq: RefCell { value: [Id { idx: 41 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 43 }] } })
 44 ( 41 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 45 ( 58 ): %rsp = MOVrr64 %rbp
 46 ( 59 ): POP64 %rbp
 47 ( 43 ): RET 
MachineFunction(name: Ray_new, ty: struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011000000000000000000000000]), def: {%vreg7, %vreg4, %vreg1, %vreg8, %vreg5, %vreg2, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 18 }, Id { idx: 3 }, Id { idx: 19 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 17 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 16 }] } })
 0  ( 20 ): PUSH64 %rbp
 1  ( 21 ): %rbp = MOVrr64 %rsp
 2  ( 22 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 23 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 24 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 6  ( 1  ): %edi = MOVri32 i32 128
 7  ( 18 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 8  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 9  ( 19 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 10 ( 6  ): MOVmr64 Base(%rcx), %rax
 11 ( 7  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 12 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 13 ( 9  ): MOVmr64 Base(%rcx), %rax
 14 ( 10 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 15 ( 11 ): %rcx = MOVrr64 %rax
 16 ( 17 ): %rcx = ADDr64i32 %rcx, i32 8
 17 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 18 ( 13 ): MOVmr64 Base(%rcx), %rax
 19 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(0)>)
 20 ( 25 ): %rsp = MOVrr64 %rbp
 21 ( 26 ): POP64 %rbp
 22 ( 16 ): RET 
MachineFunction(name: Isect_new, ty: struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}* (i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011000000001000000000000000]), def: {%vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 38 }, Id { idx: 3 }, Id { idx: 39 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 33 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 34 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 35 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 36 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 37 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 32 }] } })
 0  ( 40 ): PUSH64 %rbp
 1  ( 41 ): %rbp = MOVrr64 %rsp
 2  ( 42 ): %rsp = SUBr64i32 %rsp, i32 64
 3  ( 43 ): MOVmr32 BaseFi(%rbp, FI<i32, Arg(0)>), %edi
 4  ( 44 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 45 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>), %rdx
 6  ( 46 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(3)>), %rcx
 7  ( 47 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(4)>), %xmm4
 8  ( 48 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(5)>), %r9
 9  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 10 ( 1  ): %edi = MOVri32 i32 128
 11 ( 38 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 12 ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 13 ( 39 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 14 ( 6  ): MOVmr64 Base(%rcx), %rax
 15 ( 7  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 16 ( 8  ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Arg(0)>)
 17 ( 9  ): MOVmr32 Base(%rcx), %eax
 18 ( 10 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 19 ( 11 ): %rcx = MOVrr64 %rax
 20 ( 33 ): %rcx = ADDr64i32 %rcx, i32 4
 21 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 22 ( 13 ): MOVmr64 Base(%rcx), %rax
 23 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 24 ( 15 ): %rcx = MOVrr64 %rax
 25 ( 34 ): %rcx = ADDr64i32 %rcx, i32 12
 26 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 27 ( 17 ): MOVmr64 Base(%rcx), %rax
 28 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 29 ( 19 ): %rcx = MOVrr64 %rax
 30 ( 35 ): %rcx = ADDr64i32 %rcx, i32 20
 31 ( 20 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(3)>)
 32 ( 21 ): MOVmr64 Base(%rcx), %rax
 33 ( 22 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 34 ( 36 ): %rax = ADDr64i32 %rax, i32 28
 35 ( 24 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(4)>)
 36 ( 25 ): MOVSDmr Base(%rax), %xmm0
 37 ( 26 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 38 ( 27 ): %rcx = MOVrr64 %rax
 39 ( 37 ): %rcx = ADDr64i32 %rcx, i32 36
 40 ( 28 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(5)>)
 41 ( 29 ): MOVmr64 Base(%rcx), %rax
 42 ( 30 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(0)>)
 43 ( 49 ): %rsp = MOVrr64 %rbp
 44 ( 50 ): POP64 %rbp
 45 ( 32 ): RET 
MachineFunction(name: Sphere_new, ty: struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011000000001000000000000000]), def: {%vreg10, %vreg7, %vreg4, %vreg1, %vreg11, %vreg8, %vreg5, %vreg2, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 23 }, Id { idx: 3 }, Id { idx: 24 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 21 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 22 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 20 }] } })
 0  ( 25 ): PUSH64 %rbp
 1  ( 26 ): %rbp = MOVrr64 %rsp
 2  ( 27 ): %rsp = SUBr64i32 %rsp, i32 48
 3  ( 28 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(0)>), %xmm0
 4  ( 29 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 30 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>), %rdx
 6  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 7  ( 1  ): %edi = MOVri32 i32 128
 8  ( 23 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 9  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 10 ( 24 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 11 ( 6  ): MOVmr64 Base(%rcx), %rax
 12 ( 7  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 13 ( 8  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 14 ( 9  ): MOVSDmr Base(%rax), %xmm0
 15 ( 10 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 16 ( 11 ): %rcx = MOVrr64 %rax
 17 ( 21 ): %rcx = ADDr64i32 %rcx, i32 8
 18 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 19 ( 13 ): MOVmr64 Base(%rcx), %rax
 20 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 21 ( 15 ): %rcx = MOVrr64 %rax
 22 ( 22 ): %rcx = ADDr64i32 %rcx, i32 16
 23 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 24 ( 17 ): MOVmr64 Base(%rcx), %rax
 25 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Local(0)>)
 26 ( 31 ): %rsp = MOVrr64 %rbp
 27 ( 32 ): POP64 %rbp
 28 ( 20 ): RET 
MachineFunction(name: Sphere_intersect, ty: i32 (struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010110000000011111011110000001110000000000000]), def: {%vreg37, %vreg34, %vreg31, %vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg38, %vreg35, %vreg32, %vreg29, %vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg36, %vreg33, %vreg30, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 221 }, Id { idx: 222 }, Id { idx: 223 }, Id { idx: 224 }, Id { idx: 225 }, Id { idx: 226 }, Id { idx: 227 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 170 }, Id { idx: 5 }, Id { idx: 191 }, Id { idx: 9 }, Id { idx: 192 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 171 }, Id { idx: 17 }, Id { idx: 193 }, Id { idx: 21 }, Id { idx: 194 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 195 }, Id { idx: 31 }, Id { idx: 196 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 172 }, Id { idx: 39 }, Id { idx: 173 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 43 }, Id { idx: 174 }, Id { idx: 45 }, Id { idx: 175 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 176 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 197 }, Id { idx: 199 }, Id { idx: 55 }, Id { idx: 200 }, Id { idx: 198 }, Id { idx: 58 }, Id { idx: 177 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }, Id { idx: 62 }, Id { idx: 63 }, Id { idx: 64 }] } })
 0  (221 ): PUSH64 %rbp
 1  (222 ): %rbp = MOVrr64 %rsp
 2  (223 ): %rsp = SUBr64i32 %rsp, i32 96
 3  (224 ): MOVmr64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>), %rdi
 4  (225 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  (226 ): MOVmr64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>), %rdx
 6  (227 ): MOVmr64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>), %rcx
 7  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 8  ( 1  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 9  ( 2  ): %rdi = MOVrm64 Base(%rax)
 10 ( 3  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 11 (170 ): %rax = ADDr64i32 %rax, i32 8
 12 ( 5  ): %rsi = MOVrm64 Base(%rax)
 13 (191 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rcx
 14 ( 9  ): %rax = CALL Address(addr<fn:Vec_sub>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 15 (192 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
 16 ( 12 ): MOVmr64 Base(%rcx), %rax
 17 ( 13 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 18 ( 14 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 19 ( 15 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 20 (171 ): %rcx = ADDr64i32 %rcx, i32 8
 21 ( 17 ): %rsi = MOVrm64 Base(%rcx)
 22 (193 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rax
 23 ( 21 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 24 (194 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
 25 ( 24 ): MOVSDmr Base(%rax), %xmm0
 26 ( 25 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(2)>)
 27 ( 26 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 28 ( 27 ): %rsi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(0)>)
 29 (195 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rcx
 30 ( 31 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 31 (196 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
 32 ( 33 ): %xmm2 = MOVSDrr %xmm0
 33 ( 34 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 34 ( 35 ): %xmm0 = MOVSDrm Base(%rax)
 35 ( 36 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
 36 ( 37 ): %xmm1 = MOVSDrm Base(%rax)
 37 (172 ): %xmm0 = MULSDrr %xmm0, %xmm1
 38 ( 39 ): %xmm1 = MOVSDrr %xmm2
 39 (173 ): %xmm1 = SUBSDrr %xmm1, %xmm0
 40 ( 40 ): MOVSDmr Base(%rcx), %xmm1
 41 ( 41 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
 42 ( 42 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 43 ( 43 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 44 (174 ): %xmm0 = MULSDrr %xmm0, %xmm1
 45 ( 45 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 46 (175 ): %xmm0 = SUBSDrr %xmm0, %xmm1
 47 ( 47 ): MOVSDmr Base(%rax), %xmm0
 48 ( 48 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
 49 ( 49 ): %xmm0 = MOVSDrm64 Address(label<data:3>)
 50 ( 50 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 51 ( 51 ): %xmm2 = MOVSDrr %xmm0
 52 (176 ): %xmm2 = SUBSDrr %xmm2, %xmm1
 53 ( 52 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 54 ( 53 ): %xmm0 = MOVSDrr %xmm0
 55 (197 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(6)>), %xmm2
 56 (199 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rax
 57 ( 55 ): %xmm0 = CALL Address(addr<fn:cilk.sqrt.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 58 (200 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
 59 (198 ): %xmm2 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
 60 ( 58 ): %xmm1 = MOVSDrr %xmm2
 61 (177 ): %xmm1 = SUBSDrr %xmm1, %xmm0
 62 ( 59 ): MOVSDmr Base(%rax), %xmm1
 63 ( 60 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 64 ( 61 ): %xmm1 = MOVSDrm64 Address(label<data:4>)
 65 ( 62 ): UCOMISDrr %xmm0, %xmm1
 66 ( 63 ): JBE BB#1
 67 ( 64 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 65 }, Id { idx: 228 }, Id { idx: 229 }, Id { idx: 66 }] } })
 68 ( 65 ): %eax = MOVri32 i32 0
 69 (228 ): %rsp = MOVrr64 %rbp
 70 (229 ): POP64 %rbp
 71 ( 66 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg40, %vreg39}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }] } })
 72 ( 67 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 73 ( 68 ): %xmm1 = MOVSDrm64 Address(label<data:5>)
 74 ( 69 ): UCOMISDrr %xmm0, %xmm1
 75 ( 70 ): JBE BB#3
 76 ( 71 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 72 }, Id { idx: 230 }, Id { idx: 231 }, Id { idx: 73 }] } })
 77 ( 72 ): %eax = MOVri32 i32 0
 78 (230 ): %rsp = MOVrr64 %rbp
 79 (231 ): POP64 %rbp
 80 ( 73 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010100000000000001100000000000000]), def: {%vreg42, %vreg44, %vreg41, %vreg43}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [Id { idx: 5 }, Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 74 }, Id { idx: 178 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }] } })
 81 ( 74 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 82 (178 ): %rax = ADDr64i32 %rax, i32 28
 83 ( 76 ): %xmm0 = MOVSDrm Base(%rax)
 84 ( 77 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 85 ( 78 ): UCOMISDrr %xmm0, %xmm1
 86 ( 79 ): JBE BB#5
 87 ( 80 ): JMP BB#6
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [], iseq: RefCell { value: [Id { idx: 81 }, Id { idx: 232 }, Id { idx: 233 }, Id { idx: 82 }] } })
 88 ( 81 ): %eax = MOVri32 i32 0
 89 (232 ): %rsp = MOVrr64 %rbp
 90 (233 ): POP64 %rbp
 91 ( 82 ): RET 
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010110000000011111011110000001110000000000000]), def: {%vreg64, %vreg61, %vreg58, %vreg55, %vreg52, %vreg49, %vreg46, %vreg86, %vreg83, %vreg80, %vreg77, %vreg74, %vreg71, %vreg68, %vreg65, %vreg62, %vreg59, %vreg56, %vreg53, %vreg50, %vreg47, %vreg87, %vreg84, %vreg81, %vreg78, %vreg75, %vreg72, %vreg69, %vreg66, %vreg63, %vreg60, %vreg57, %vreg54, %vreg51, %vreg48, %vreg45, %vreg88, %vreg85, %vreg82, %vreg79, %vreg76, %vreg73, %vreg70, %vreg67}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [], iseq: RefCell { value: [Id { idx: 83 }, Id { idx: 84 }, Id { idx: 179 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 180 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 92 }, Id { idx: 201 }, Id { idx: 203 }, Id { idx: 94 }, Id { idx: 204 }, Id { idx: 202 }, Id { idx: 96 }, Id { idx: 97 }, Id { idx: 205 }, Id { idx: 100 }, Id { idx: 206 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 105 }, Id { idx: 181 }, Id { idx: 106 }, Id { idx: 182 }, Id { idx: 108 }, Id { idx: 109 }, Id { idx: 183 }, Id { idx: 111 }, Id { idx: 207 }, Id { idx: 115 }, Id { idx: 208 }, Id { idx: 117 }, Id { idx: 209 }, Id { idx: 120 }, Id { idx: 210 }, Id { idx: 123 }, Id { idx: 124 }, Id { idx: 125 }, Id { idx: 184 }, Id { idx: 126 }, Id { idx: 185 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 186 }, Id { idx: 132 }, Id { idx: 211 }, Id { idx: 213 }, Id { idx: 136 }, Id { idx: 214 }, Id { idx: 212 }, Id { idx: 139 }, Id { idx: 140 }, Id { idx: 141 }, Id { idx: 215 }, Id { idx: 217 }, Id { idx: 143 }, Id { idx: 218 }, Id { idx: 216 }, Id { idx: 146 }, Id { idx: 147 }, Id { idx: 219 }, Id { idx: 149 }, Id { idx: 220 }, Id { idx: 152 }, Id { idx: 153 }, Id { idx: 187 }, Id { idx: 155 }, Id { idx: 156 }, Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }, Id { idx: 188 }, Id { idx: 161 }, Id { idx: 162 }, Id { idx: 163 }, Id { idx: 189 }, Id { idx: 164 }, Id { idx: 190 }, Id { idx: 166 }, Id { idx: 167 }, Id { idx: 168 }, Id { idx: 234 }, Id { idx: 235 }, Id { idx: 169 }] } })
 92 ( 83 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 93 ( 84 ): %rcx = MOVrr64 %rax
 94 (179 ): %rcx = ADDr64i32 %rcx, i32 4
 95 ( 85 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 96 ( 86 ): %rdx = MOVrm64 Base(%rax)
 97 ( 87 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 98 (180 ): %rax = ADDr64i32 %rax, i32 8
 99 ( 89 ): %rdi = MOVrm64 Base(%rax)
100 ( 90 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
101 ( 92 ): %xmm1 = MOVSDrr %xmm0
102 (201 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rdx
103 (203 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(7)>), %rcx
104 ( 94 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
105 (204 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(7)>)
106 (202 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
107 ( 96 ): %rsi = MOVrr64 %rax
108 ( 97 ): %rdi = MOVrr64 %rdx
109 (205 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rcx
110 (100 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
111 (206 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
112 (103 ): MOVmr64 Base(%rcx), %rax
113 (104 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
114 (105 ): %rcx = MOVrr64 %rax
115 (181 ): %rcx = ADDr64i32 %rcx, i32 12
116 (106 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
117 (182 ): %rax = ADDr64i32 %rax, i32 4
118 (108 ): %rdi = MOVrm64 Base(%rax)
119 (109 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
120 (183 ): %rax = ADDr64i32 %rax, i32 8
121 (111 ): %rsi = MOVrm64 Base(%rax)
122 (207 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rcx
123 (115 ): %rax = CALL Address(addr<fn:Vec_sub>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
124 (208 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
125 (117 ): %rdi = MOVrr64 %rax
126 (209 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rcx
127 (120 ): %rax = CALL Address(addr<fn:Vec_normalize>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
128 (210 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
129 (123 ): MOVmr64 Base(%rcx), %rax
130 (124 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
131 (125 ): %rdx = MOVrr64 %rax
132 (184 ): %rdx = ADDr64i32 %rdx, i32 20
133 (126 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:13)*, Arg(0)>)
134 (185 ): %rax = ADDr64i32 %rax, i32 16
135 (128 ): %rax = MOVrm64 Base(%rax)
136 (129 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
137 (130 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
138 (186 ): %rcx = ADDr64i32 %rcx, i32 12
139 (132 ): %rsi = MOVrm64 Base(%rcx)
140 (211 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rax
141 (213 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(7)>), %rdx
142 (136 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
143 (214 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(7)>)
144 (212 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
145 (139 ): %xmm0 = MOVSDrr %xmm0
146 (140 ): %xmm1 = MOVSDrm64 Address(label<data:6>)
147 (141 ): %xmm2 = MOVSDrm64 Address(label<data:7>)
148 (215 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rax
149 (217 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(7)>), %rdx
150 (143 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
151 (218 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(7)>)
152 (216 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
153 (146 ): %rdi = MOVrr64 %rax
154 (147 ): %xmm1 = MOVSDrr %xmm0
155 (219 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(5)>), %rdx
156 (149 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
157 (220 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(5)>)
158 (152 ): MOVmr64 Base(%rdx), %rax
159 (153 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
160 (187 ): %rax = ADDr64i32 %rax, i32 28
161 (155 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
162 (156 ): MOVSDmr Base(%rax), %xmm0
163 (157 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
164 (158 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
165 (159 ): %ecx = MOVrm32 Base(%rcx)
166 (188 ): %ecx = ADDri32 %ecx, i32 1
167 (161 ): MOVmr32 Base(%rax), %ecx
168 (162 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
169 (163 ): %rcx = MOVrr64 %rax
170 (189 ): %rcx = ADDr64i32 %rcx, i32 36
171 (164 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
172 (190 ): %rax = ADDr64i32 %rax, i32 8
173 (166 ): %rax = MOVrm64 Base(%rax)
174 (167 ): MOVmr64 Base(%rcx), %rax
175 (168 ): %eax = MOVri32 i32 0
176 (234 ): %rsp = MOVrr64 %rbp
177 (235 ): POP64 %rbp
178 (169 ): RET 
MachineFunction(name: Plane_new, ty: struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}* (struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011000000000000000000000000]), def: {%vreg10, %vreg7, %vreg4, %vreg1, %vreg11, %vreg8, %vreg5, %vreg2, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 25 }, Id { idx: 26 }, Id { idx: 27 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 23 }, Id { idx: 3 }, Id { idx: 24 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }, Id { idx: 21 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 22 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 20 }] } })
 0  ( 25 ): PUSH64 %rbp
 1  ( 26 ): %rbp = MOVrr64 %rsp
 2  ( 27 ): %rsp = SUBr64i32 %rsp, i32 48
 3  ( 28 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 29 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  ( 30 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>), %rdx
 6  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 7  ( 1  ): %edi = MOVri32 i32 128
 8  ( 23 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 9  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 10 ( 24 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 11 ( 6  ): MOVmr64 Base(%rcx), %rax
 12 ( 7  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 13 ( 8  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>)
 14 ( 9  ): MOVmr64 Base(%rcx), %rax
 15 ( 10 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 16 ( 11 ): %rcx = MOVrr64 %rax
 17 ( 21 ): %rcx = ADDr64i32 %rcx, i32 8
 18 ( 12 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
 19 ( 13 ): MOVmr64 Base(%rcx), %rax
 20 ( 14 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 21 ( 15 ): %rcx = MOVrr64 %rax
 22 ( 22 ): %rcx = ADDr64i32 %rcx, i32 16
 23 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(2)>)
 24 ( 17 ): MOVmr64 Base(%rcx), %rax
 25 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Local(0)>)
 26 ( 31 ): %rsp = MOVrr64 %rbp
 27 ( 32 ): POP64 %rbp
 28 ( 20 ): RET 
MachineFunction(name: Plane_intersect, ty: i32 (struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, f64, f64}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010110000000011111011110000001110000000000000]), def: {%vreg31, %vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg32, %vreg29, %vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg30, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 318 }, Id { idx: 319 }, Id { idx: 320 }, Id { idx: 321 }, Id { idx: 322 }, Id { idx: 323 }, Id { idx: 324 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 247 }, Id { idx: 6 }, Id { idx: 286 }, Id { idx: 288 }, Id { idx: 10 }, Id { idx: 289 }, Id { idx: 287 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 248 }, Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 249 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 250 }, Id { idx: 21 }, Id { idx: 290 }, Id { idx: 25 }, Id { idx: 291 }, Id { idx: 28 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 251 }, Id { idx: 35 }, Id { idx: 292 }, Id { idx: 294 }, Id { idx: 39 }, Id { idx: 295 }, Id { idx: 293 }, Id { idx: 41 }, Id { idx: 42 }, Id { idx: 252 }, Id { idx: 44 }, Id { idx: 253 }, Id { idx: 46 }, Id { idx: 254 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 52 }] } })
 0  (318 ): PUSH64 %rbp
 1  (319 ): %rbp = MOVrr64 %rsp
 2  (320 ): %rsp = SUBr64i32 %rsp, i32 128
 3  (321 ): MOVmr64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>), %rdi
 4  (322 ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>), %rsi
 5  (323 ): MOVmr64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>), %rdx
 6  (324 ): MOVmr64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>), %rcx
 7  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(0)>)
 8  ( 1  ): %xmm1 = MOVSDrm64 Address(label<data:8>)
 9  ( 2  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 10 ( 3  ): %rdi = MOVrm64 Base(%rax)
 11 ( 4  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 12 (247 ): %rax = ADDr64i32 %rax, i32 8
 13 ( 6  ): %rsi = MOVrm64 Base(%rax)
 14 (286 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
 15 (288 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(10)>), %xmm1
 16 ( 10 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 17 (289 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(10)>)
 18 (287 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
 19 ( 12 ): %xmm2 = MOVSDrr %xmm0
 20 ( 13 ): %xmm0 = MOVSDrr %xmm1
 21 (248 ): %xmm0 = SUBSDrr %xmm0, %xmm2
 22 ( 14 ): MOVSDmr Base(%rcx), %xmm0
 23 ( 15 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(1)>)
 24 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 25 (249 ): %rax = ADDr64i32 %rax, i32 8
 26 ( 18 ): %rdi = MOVrm64 Base(%rax)
 27 ( 19 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 28 (250 ): %rax = ADDr64i32 %rax, i32 8
 29 ( 21 ): %rsi = MOVrm64 Base(%rax)
 30 (290 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
 31 ( 25 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 32 (291 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
 33 ( 28 ): MOVSDmr Base(%rcx), %xmm0
 34 ( 29 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(2)>)
 35 ( 30 ): %xmm1 = MOVSDrm64 Address(label<data:9>)
 36 ( 31 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 37 ( 32 ): %rdi = MOVrm64 Base(%rax)
 38 ( 33 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 39 (251 ): %rax = ADDr64i32 %rax, i32 8
 40 ( 35 ): %rsi = MOVrm64 Base(%rax)
 41 (292 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
 42 (294 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(10)>), %xmm1
 43 ( 39 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 44 (295 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(10)>)
 45 (293 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
 46 ( 41 ): %xmm2 = MOVSDrr %xmm0
 47 ( 42 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(0)>)
 48 (252 ): %xmm2 = ADDSDrr %xmm2, %xmm0
 49 ( 44 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 50 (253 ): %xmm2 = DIVSDrr %xmm2, %xmm0
 51 ( 46 ): %xmm0 = MOVSDrr %xmm1
 52 (254 ): %xmm0 = SUBSDrr %xmm0, %xmm2
 53 ( 47 ): MOVSDmr Base(%rcx), %xmm0
 54 ( 48 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 55 ( 49 ): %xmm1 = MOVSDrm64 Address(label<data:10>)
 56 ( 50 ): UCOMISDrr %xmm0, %xmm1
 57 ( 51 ): JBE BB#1
 58 ( 52 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 53 }, Id { idx: 325 }, Id { idx: 326 }, Id { idx: 54 }] } })
 59 ( 53 ): %eax = MOVri32 i32 0
 60 (325 ): %rsp = MOVrr64 %rbp
 61 (326 ): POP64 %rbp
 62 ( 54 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010100000000000001100000000000000]), def: {%vreg34, %vreg36, %vreg33, %vreg35}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [Id { idx: 3 }, Id { idx: 4 }], iseq: RefCell { value: [Id { idx: 55 }, Id { idx: 255 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }] } })
 63 ( 55 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 64 (255 ): %rax = ADDr64i32 %rax, i32 28
 65 ( 57 ): %xmm0 = MOVSDrm Base(%rax)
 66 ( 58 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 67 ( 59 ): UCOMISDrr %xmm0, %xmm1
 68 ( 60 ): JBE BB#3
 69 ( 61 ): JMP BB#4
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }], succ: [], iseq: RefCell { value: [Id { idx: 62 }, Id { idx: 327 }, Id { idx: 328 }, Id { idx: 63 }] } })
 70 ( 62 ): %eax = MOVri32 i32 0
 71 (327 ): %rsp = MOVrr64 %rbp
 72 (328 ): POP64 %rbp
 73 ( 63 ): RET 
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010110000000011111011110000001110000000000000]), def: {%vreg61, %vreg55, %vreg49, %vreg43, %vreg37, %vreg92, %vreg86, %vreg80, %vreg74, %vreg68, %vreg62, %vreg56, %vreg50, %vreg44, %vreg38, %vreg93, %vreg87, %vreg81, %vreg75, %vreg69, %vreg63, %vreg57, %vreg51, %vreg45, %vreg39, %vreg94, %vreg88, %vreg82, %vreg76, %vreg70, %vreg64, %vreg58, %vreg52, %vreg46, %vreg40, %vreg89, %vreg83, %vreg77, %vreg71, %vreg65, %vreg59, %vreg53, %vreg47, %vreg41, %vreg90, %vreg84, %vreg78, %vreg72, %vreg66, %vreg60, %vreg54, %vreg48, %vreg42, %vreg91, %vreg85, %vreg79, %vreg73, %vreg67}, live_in: {}, live_out: {%vreg91} } }, pred: [Id { idx: 2 }], succ: [Id { idx: 5 }, Id { idx: 8 }], iseq: RefCell { value: [Id { idx: 64 }, Id { idx: 65 }, Id { idx: 256 }, Id { idx: 66 }, Id { idx: 67 }, Id { idx: 68 }, Id { idx: 257 }, Id { idx: 70 }, Id { idx: 71 }, Id { idx: 73 }, Id { idx: 296 }, Id { idx: 298 }, Id { idx: 75 }, Id { idx: 299 }, Id { idx: 297 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 300 }, Id { idx: 81 }, Id { idx: 301 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 258 }, Id { idx: 87 }, Id { idx: 259 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 260 }, Id { idx: 95 }, Id { idx: 302 }, Id { idx: 99 }, Id { idx: 303 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 304 }, Id { idx: 106 }, Id { idx: 305 }, Id { idx: 109 }, Id { idx: 110 }, Id { idx: 111 }, Id { idx: 261 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 115 }, Id { idx: 262 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 263 }, Id { idx: 121 }, Id { idx: 306 }, Id { idx: 308 }, Id { idx: 123 }, Id { idx: 309 }, Id { idx: 307 }, Id { idx: 125 }, Id { idx: 126 }, Id { idx: 264 }, Id { idx: 128 }, Id { idx: 265 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }, Id { idx: 266 }, Id { idx: 133 }, Id { idx: 267 }, Id { idx: 135 }, Id { idx: 136 }, Id { idx: 268 }, Id { idx: 138 }, Id { idx: 269 }, Id { idx: 140 }, Id { idx: 141 }, Id { idx: 270 }, Id { idx: 143 }, Id { idx: 310 }, Id { idx: 312 }, Id { idx: 145 }, Id { idx: 313 }, Id { idx: 311 }, Id { idx: 147 }, Id { idx: 148 }, Id { idx: 271 }, Id { idx: 150 }, Id { idx: 272 }, Id { idx: 151 }, Id { idx: 152 }, Id { idx: 153 }, Id { idx: 154 }, Id { idx: 155 }, Id { idx: 156 }, Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }] } })
 74 ( 64 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 75 ( 65 ): %rcx = MOVrr64 %rax
 76 (256 ): %rcx = ADDr64i32 %rcx, i32 4
 77 ( 66 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 78 ( 67 ): %rdx = MOVrm64 Base(%rax)
 79 ( 68 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
 80 (257 ): %rax = ADDr64i32 %rax, i32 8
 81 ( 70 ): %rdi = MOVrm64 Base(%rax)
 82 ( 71 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
 83 ( 73 ): %xmm1 = MOVSDrr %xmm0
 84 (296 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rdx
 85 (298 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rcx
 86 ( 75 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
 87 (299 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 88 (297 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
 89 ( 77 ): %rsi = MOVrr64 %rax
 90 ( 78 ): %rdi = MOVrr64 %rdx
 91 (300 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
 92 ( 81 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 93 (301 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
 94 ( 84 ): MOVmr64 Base(%rcx), %rax
 95 ( 85 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
 96 ( 86 ): %rcx = MOVrr64 %rax
 97 (258 ): %rcx = ADDr64i32 %rcx, i32 12
 98 ( 87 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
 99 (259 ): %rax = ADDr64i32 %rax, i32 8
100 ( 89 ): %rax = MOVrm64 Base(%rax)
101 ( 90 ): MOVmr64 Base(%rcx), %rax
102 ( 91 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
103 ( 92 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Arg(1)>)
104 ( 93 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
105 (260 ): %rax = ADDr64i32 %rax, i32 12
106 ( 95 ): %rsi = MOVrm64 Base(%rax)
107 (302 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
108 ( 99 ): %xmm0 = CALL Address(addr<fn:Vec_dot>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
109 (303 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
110 (102 ): %xmm0 = MOVSDrr %xmm0
111 (103 ): %xmm1 = MOVSDrm64 Address(label<data:11>)
112 (104 ): %xmm2 = MOVSDrm64 Address(label<data:12>)
113 (304 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
114 (106 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
115 (305 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
116 (109 ): MOVSDmr Base(%rcx), %xmm0
117 (110 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
118 (111 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
119 (261 ): %rax = ADDr64i32 %rax, i32 4
120 (113 ): %rax = MOVrm64 Base(%rax)
121 (114 ): %xmm2 = MOVSDrm Base(%rax)
122 (115 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
123 (262 ): %rax = ADDr64i32 %rax, i32 4
124 (117 ): %rax = MOVrm64 Base(%rax)
125 (118 ): %xmm0 = MOVSDrm Base(%rax)
126 (119 ): %xmm1 = MOVSDrm64 Address(label<data:13>)
127 (263 ): %xmm0 = DIVSDrr %xmm0, %xmm1
128 (121 ): %xmm0 = MOVSDrr %xmm0
129 (306 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
130 (308 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(10)>), %xmm2
131 (123 ): %xmm0 = CALL Address(addr<fn:cilk.floor.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
132 (309 ): %xmm2 = MOVSDrm BaseFi(%rbp, FI<f64, Local(10)>)
133 (307 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
134 (125 ): %xmm1 = MOVSDrr %xmm0
135 (126 ): %xmm0 = MOVSDrm64 Address(label<data:14>)
136 (264 ): %xmm1 = MULSDrr %xmm1, %xmm0
137 (128 ): %xmm0 = MOVSDrr %xmm2
138 (265 ): %xmm0 = SUBSDrr %xmm0, %xmm1
139 (129 ): MOVSDmr Base(%rcx), %xmm0
140 (130 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(5)>)
141 (131 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
142 (266 ): %rcx = ADDr64i32 %rcx, i32 4
143 (133 ): %rcx = MOVrm64 Base(%rcx)
144 (267 ): %rcx = ADDr64i32 %rcx, i32 16
145 (135 ): %xmm2 = MOVSDrm Base(%rcx)
146 (136 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
147 (268 ): %rcx = ADDr64i32 %rcx, i32 4
148 (138 ): %rcx = MOVrm64 Base(%rcx)
149 (269 ): %rcx = ADDr64i32 %rcx, i32 16
150 (140 ): %xmm0 = MOVSDrm Base(%rcx)
151 (141 ): %xmm1 = MOVSDrm64 Address(label<data:15>)
152 (270 ): %xmm0 = DIVSDrr %xmm0, %xmm1
153 (143 ): %xmm0 = MOVSDrr %xmm0
154 (310 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rax
155 (312 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(10)>), %xmm2
156 (145 ): %xmm0 = CALL Address(addr<fn:cilk.floor.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
157 (313 ): %xmm2 = MOVSDrm BaseFi(%rbp, FI<f64, Local(10)>)
158 (311 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
159 (147 ): %xmm1 = MOVSDrr %xmm0
160 (148 ): %xmm0 = MOVSDrm64 Address(label<data:16>)
161 (271 ): %xmm1 = MULSDrr %xmm1, %xmm0
162 (150 ): %xmm0 = MOVSDrr %xmm2
163 (272 ): %xmm0 = SUBSDrr %xmm0, %xmm1
164 (151 ): MOVSDmr Base(%rax), %xmm0
165 (152 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(6)>)
166 (153 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
167 (154 ): MOVSDmr Base(%rax), %xmm0
168 (155 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
169 (156 ): %xmm1 = MOVSDrm64 Address(label<data:17>)
170 (157 ): UCOMISDrr %xmm0, %xmm1
171 (158 ): JA BB#5
172 (159 ): JMP BB#8
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg96, %vreg95}, live_in: {%vreg91}, live_out: {%vreg91} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 6 }, Id { idx: 7 }], iseq: RefCell { value: [Id { idx: 160 }, Id { idx: 161 }, Id { idx: 162 }, Id { idx: 163 }, Id { idx: 164 }] } })
173 (160 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(5)>)
174 (161 ): %xmm1 = MOVSDrm64 Address(label<data:18>)
175 (162 ): UCOMISDrr %xmm0, %xmm1
176 (163 ): JA BB#6
177 (164 ): JMP BB#7
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg97, %vreg98, %vreg99}, live_in: {%vreg91}, live_out: {} } }, pred: [Id { idx: 5 }], succ: [Id { idx: 7 }], iseq: RefCell { value: [Id { idx: 165 }, Id { idx: 166 }, Id { idx: 273 }, Id { idx: 168 }, Id { idx: 169 }] } })
178 (165 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
179 (166 ): %xmm0 = MOVSDrm64 Address(label<data:19>)
180 (273 ): %xmm1 = MULSDrr %xmm1, %xmm0
181 (168 ): MOVSDmr Base(%rax), %xmm1
182 (169 ): JMP BB#7
MachineBasicBlock #7 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 5 }, Id { idx: 6 }], succ: [Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 170 }] } })
183 (170 ): JMP BB#13
MachineBasicBlock #8 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg100, %vreg101}, live_in: {%vreg91}, live_out: {%vreg91} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 9 }, Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 171 }, Id { idx: 172 }, Id { idx: 173 }, Id { idx: 174 }, Id { idx: 175 }] } })
184 (171 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
185 (172 ): %xmm1 = MOVSDrm64 Address(label<data:20>)
186 (173 ): UCOMISDrr %xmm0, %xmm1
187 (174 ): JB BB#9
188 (175 ): JMP BB#12
MachineBasicBlock #9 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg102, %vreg103}, live_in: {%vreg91}, live_out: {%vreg91} } }, pred: [Id { idx: 8 }], succ: [Id { idx: 10 }, Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 176 }, Id { idx: 177 }, Id { idx: 178 }, Id { idx: 179 }, Id { idx: 180 }] } })
189 (176 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(5)>)
190 (177 ): %xmm1 = MOVSDrm64 Address(label<data:21>)
191 (178 ): UCOMISDrr %xmm0, %xmm1
192 (179 ): JB BB#10
193 (180 ): JMP BB#11
MachineBasicBlock #10 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000001100000000000000]), def: {%vreg104, %vreg105, %vreg106}, live_in: {%vreg91}, live_out: {} } }, pred: [Id { idx: 9 }], succ: [Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 181 }, Id { idx: 182 }, Id { idx: 274 }, Id { idx: 184 }, Id { idx: 185 }] } })
194 (181 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
195 (182 ): %xmm0 = MOVSDrm64 Address(label<data:22>)
196 (274 ): %xmm1 = MULSDrr %xmm1, %xmm0
197 (184 ): MOVSDmr Base(%rax), %xmm1
198 (185 ): JMP BB#11
MachineBasicBlock #11 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 9 }, Id { idx: 10 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 186 }] } })
199 (186 ): JMP BB#12
MachineBasicBlock #12 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 8 }, Id { idx: 11 }], succ: [Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 187 }] } })
200 (187 ): JMP BB#13
MachineBasicBlock #13 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010000000000011111010000000001100000000000000]), def: {%vreg112, %vreg109, %vreg116, %vreg113, %vreg110, %vreg107, %vreg114, %vreg111, %vreg108, %vreg115}, live_in: {}, live_out: {} } }, pred: [Id { idx: 7 }, Id { idx: 12 }], succ: [Id { idx: 14 }, Id { idx: 15 }], iseq: RefCell { value: [Id { idx: 188 }, Id { idx: 189 }, Id { idx: 275 }, Id { idx: 191 }, Id { idx: 276 }, Id { idx: 193 }, Id { idx: 194 }, Id { idx: 314 }, Id { idx: 196 }, Id { idx: 315 }, Id { idx: 199 }, Id { idx: 200 }, Id { idx: 201 }, Id { idx: 202 }, Id { idx: 203 }, Id { idx: 204 }, Id { idx: 205 }, Id { idx: 206 }] } })
201 (188 ): %rcx = LEAr64m BaseFi(%rbp, FI<f64, Local(7)>)
202 (189 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
203 (275 ): %rax = ADDr64i32 %rax, i32 4
204 (191 ): %rax = MOVrm64 Base(%rax)
205 (276 ): %rax = ADDr64i32 %rax, i32 16
206 (193 ): %xmm0 = MOVSDrm Base(%rax)
207 (194 ): %xmm0 = MOVSDrr %xmm0
208 (314 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
209 (196 ): %xmm0 = CALL Address(addr<fn:cilk.fabs.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
210 (315 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
211 (199 ): MOVSDmr Base(%rcx), %xmm0
212 (200 ): %xmm0 = MOVSDrm64 Address(label<data:23>)
213 (201 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(8)>), %xmm0
214 (202 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(7)>)
215 (203 ): %xmm0 = MOVSDrm64 Address(label<data:24>)
216 (204 ): UCOMISDrr %xmm1, %xmm0
217 (205 ): JB BB#14
218 (206 ): JMP BB#15
MachineBasicBlock #14 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010100000000000001111000000000000]), def: {%vreg120, %vreg117, %vreg122, %vreg119, %vreg121, %vreg118}, live_in: {}, live_out: {} } }, pred: [Id { idx: 13 }], succ: [Id { idx: 15 }], iseq: RefCell { value: [Id { idx: 207 }, Id { idx: 208 }, Id { idx: 209 }, Id { idx: 210 }, Id { idx: 211 }, Id { idx: 277 }, Id { idx: 212 }, Id { idx: 278 }, Id { idx: 213 }, Id { idx: 214 }] } })
219 (207 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(8)>)
220 (208 ): %xmm2 = MOVSDrm64 Address(label<data:25>)
221 (209 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(7)>)
222 (210 ): %xmm3 = MOVSDrm64 Address(label<data:26>)
223 (211 ): %xmm1 = MOVSDrr %xmm0
224 (277 ): %xmm1 = MULSDrr %xmm1, %xmm3
225 (212 ): %xmm0 = MOVSDrr %xmm2
226 (278 ): %xmm0 = SUBSDrr %xmm0, %xmm1
227 (213 ): MOVSDmr Base(%rax), %xmm0
228 (214 ): JMP BB#15
MachineBasicBlock #15 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010010000000011111011010000001100000000000000]), def: {%vreg128, %vreg125, %vreg142, %vreg139, %vreg136, %vreg133, %vreg130, %vreg127, %vreg124, %vreg141, %vreg138, %vreg135, %vreg132, %vreg129, %vreg126, %vreg123, %vreg143, %vreg140, %vreg137, %vreg134, %vreg131}, live_in: {}, live_out: {} } }, pred: [Id { idx: 13 }, Id { idx: 14 }], succ: [], iseq: RefCell { value: [Id { idx: 215 }, Id { idx: 216 }, Id { idx: 279 }, Id { idx: 217 }, Id { idx: 280 }, Id { idx: 219 }, Id { idx: 220 }, Id { idx: 221 }, Id { idx: 281 }, Id { idx: 224 }, Id { idx: 316 }, Id { idx: 226 }, Id { idx: 317 }, Id { idx: 229 }, Id { idx: 230 }, Id { idx: 282 }, Id { idx: 232 }, Id { idx: 233 }, Id { idx: 234 }, Id { idx: 235 }, Id { idx: 236 }, Id { idx: 283 }, Id { idx: 238 }, Id { idx: 239 }, Id { idx: 240 }, Id { idx: 284 }, Id { idx: 241 }, Id { idx: 285 }, Id { idx: 243 }, Id { idx: 244 }, Id { idx: 245 }, Id { idx: 329 }, Id { idx: 330 }, Id { idx: 246 }] } })
229 (215 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
230 (216 ): %rcx = MOVrr64 %rax
231 (279 ): %rcx = ADDr64i32 %rcx, i32 20
232 (217 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:14)*, Arg(0)>)
233 (280 ): %rax = ADDr64i32 %rax, i32 16
234 (219 ): %rdi = MOVrm64 Base(%rax)
235 (220 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(6)>)
236 (221 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(8)>)
237 (281 ): %xmm1 = MULSDrr %xmm1, %xmm0
238 (224 ): %xmm1 = MOVSDrr %xmm1
239 (316 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(9)>), %rcx
240 (226 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
241 (317 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(9)>)
242 (229 ): MOVmr64 Base(%rcx), %rax
243 (230 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
244 (282 ): %rax = ADDr64i32 %rax, i32 28
245 (232 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(2)>)
246 (233 ): MOVSDmr Base(%rax), %xmm0
247 (234 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
248 (235 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
249 (236 ): %eax = MOVrm32 Base(%rax)
250 (283 ): %eax = ADDri32 %eax, i32 1
251 (238 ): MOVmr32 Base(%rcx), %eax
252 (239 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(3)>)
253 (240 ): %rcx = MOVrr64 %rax
254 (284 ): %rcx = ADDr64i32 %rcx, i32 36
255 (241 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(2)>)
256 (285 ): %rax = ADDr64i32 %rax, i32 8
257 (243 ): %rax = MOVrm64 Base(%rax)
258 (244 ): MOVmr64 Base(%rcx), %rax
259 (245 ): %eax = MOVri32 i32 0
260 (329 ): %rsp = MOVrr64 %rbp
261 (330 ): POP64 %rbp
262 (246 ): RET 
MachineFunction(name: Env_intersect, ty: i32 (struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {i32, struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*, f64, struct {f64, f64, f64}*}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010110000000011111011110000000000000000000000]), def: {%vreg31, %vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg32, %vreg29, %vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg30, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 66 }, Id { idx: 67 }, Id { idx: 68 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 71 }, Id { idx: 0 }, Id { idx: 62 }, Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 12 }, Id { idx: 15 }, Id { idx: 63 }, Id { idx: 17 }, Id { idx: 18 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 27 }, Id { idx: 30 }, Id { idx: 64 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 36 }, Id { idx: 42 }, Id { idx: 45 }, Id { idx: 65 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 57 }, Id { idx: 60 }, Id { idx: 72 }, Id { idx: 73 }, Id { idx: 61 }] } })
 0  ( 66 ): PUSH64 %rbp
 1  ( 67 ): %rbp = MOVrr64 %rsp
 2  ( 68 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 69 ): MOVmr64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>), %rdi
 4  ( 70 ): MOVmr64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>), %rsi
 5  ( 71 ): MOVmr64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>), %rdx
 6  ( 0  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 7  ( 62 ): %rax = ADDr64i32 %rax, i32 8
 8  ( 2  ): %rdi = MOVrm64 Base(%rax)
 9  ( 3  ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 10 ( 4  ): %rsi = MOVrm64 Base(%rax)
 11 ( 5  ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 12 ( 6  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 13 ( 12 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 14 ( 15 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 15 ( 63 ): %rax = ADDr64i32 %rax, i32 16
 16 ( 17 ): %rdi = MOVrm64 Base(%rax)
 17 ( 18 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 18 ( 19 ): %rsi = MOVrm64 Base(%rax)
 19 ( 20 ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 20 ( 21 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 21 ( 27 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 22 ( 30 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 23 ( 64 ): %rax = ADDr64i32 %rax, i32 24
 24 ( 32 ): %rdi = MOVrm64 Base(%rax)
 25 ( 33 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 26 ( 34 ): %rsi = MOVrm64 Base(%rax)
 27 ( 35 ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 28 ( 36 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 29 ( 42 ): %eax = CALL Address(addr<fn:Sphere_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 30 ( 45 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 31 ( 65 ): %rax = ADDr64i32 %rax, i32 32
 32 ( 47 ): %rdi = MOVrm64 Base(%rax)
 33 ( 48 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Arg(0)>)
 34 ( 49 ): %rsi = MOVrm64 Base(%rax)
 35 ( 50 ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Arg(1)>)
 36 ( 51 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Arg(2)>)
 37 ( 57 ): %eax = CALL Address(addr<fn:Plane_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,%rcx,)
 38 ( 60 ): %eax = MOVri32 i32 0
 39 ( 72 ): %rsp = MOVrr64 %rbp
 40 ( 73 ): POP64 %rbp
 41 ( 61 ): RET 
MachineFunction(name: Env_new, ty: struct {struct {f64, f64, f64}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {f64, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*, struct {struct {f64, f64, f64}*, struct {f64, f64, f64}*, struct {f64, f64, f64}*}*}* ()):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010110000000011111011110000001110000000000000]), def: {%vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg4, %vreg1, %vreg29, %vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg2, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 189 }, Id { idx: 190 }, Id { idx: 191 }, Id { idx: 0 }, Id { idx: 1 }, Id { idx: 141 }, Id { idx: 3 }, Id { idx: 142 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 143 }, Id { idx: 12 }, Id { idx: 144 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }, Id { idx: 137 }, Id { idx: 18 }, Id { idx: 145 }, Id { idx: 20 }, Id { idx: 146 }, Id { idx: 22 }, Id { idx: 23 }, Id { idx: 24 }, Id { idx: 25 }, Id { idx: 147 }, Id { idx: 27 }, Id { idx: 148 }, Id { idx: 29 }, Id { idx: 30 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 149 }, Id { idx: 151 }, Id { idx: 34 }, Id { idx: 152 }, Id { idx: 150 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 153 }, Id { idx: 41 }, Id { idx: 154 }, Id { idx: 44 }, Id { idx: 45 }, Id { idx: 46 }, Id { idx: 138 }, Id { idx: 47 }, Id { idx: 155 }, Id { idx: 49 }, Id { idx: 156 }, Id { idx: 51 }, Id { idx: 52 }, Id { idx: 53 }, Id { idx: 54 }, Id { idx: 157 }, Id { idx: 56 }, Id { idx: 158 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 61 }, Id { idx: 159 }, Id { idx: 161 }, Id { idx: 63 }, Id { idx: 162 }, Id { idx: 160 }, Id { idx: 65 }, Id { idx: 66 }, Id { idx: 163 }, Id { idx: 70 }, Id { idx: 164 }, Id { idx: 73 }, Id { idx: 74 }, Id { idx: 75 }, Id { idx: 139 }, Id { idx: 76 }, Id { idx: 165 }, Id { idx: 78 }, Id { idx: 166 }, Id { idx: 80 }, Id { idx: 81 }, Id { idx: 82 }, Id { idx: 83 }, Id { idx: 167 }, Id { idx: 85 }, Id { idx: 168 }, Id { idx: 87 }, Id { idx: 88 }, Id { idx: 89 }, Id { idx: 90 }, Id { idx: 169 }, Id { idx: 171 }, Id { idx: 92 }, Id { idx: 172 }, Id { idx: 170 }, Id { idx: 94 }, Id { idx: 95 }, Id { idx: 173 }, Id { idx: 99 }, Id { idx: 174 }, Id { idx: 102 }, Id { idx: 103 }, Id { idx: 104 }, Id { idx: 140 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 107 }, Id { idx: 175 }, Id { idx: 109 }, Id { idx: 176 }, Id { idx: 111 }, Id { idx: 112 }, Id { idx: 113 }, Id { idx: 114 }, Id { idx: 177 }, Id { idx: 179 }, Id { idx: 116 }, Id { idx: 180 }, Id { idx: 178 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 120 }, Id { idx: 121 }, Id { idx: 181 }, Id { idx: 183 }, Id { idx: 185 }, Id { idx: 123 }, Id { idx: 186 }, Id { idx: 184 }, Id { idx: 182 }, Id { idx: 125 }, Id { idx: 187 }, Id { idx: 130 }, Id { idx: 188 }, Id { idx: 133 }, Id { idx: 134 }, Id { idx: 192 }, Id { idx: 193 }, Id { idx: 136 }] } })
 0  (189 ): PUSH64 %rbp
 1  (190 ): %rbp = MOVrr64 %rsp
 2  (191 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 4  ( 1  ): %edi = MOVri32 i32 128
 5  (141 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 6  ( 3  ): %rax = CALL Address(addr<fn:cilk.malloc.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 7  (142 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 8  ( 6  ): MOVmr64 Base(%rcx), %rax
 9  ( 7  ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 10 ( 8  ): %xmm0 = MOVSDrm64 Address(label<data:27>)
 11 ( 9  ): %xmm1 = MOVSDrm64 Address(label<data:28>)
 12 ( 10 ): %xmm2 = MOVSDrm64 Address(label<data:29>)
 13 (143 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 14 ( 12 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 15 (144 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 16 ( 15 ): MOVmr64 Base(%rcx), %rax
 17 ( 16 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 18 ( 17 ): %rcx = MOVrr64 %rax
 19 (137 ): %rcx = ADDr64i32 %rcx, i32 8
 20 ( 18 ): %xmm0 = MOVSDrm64 Address(label<data:30>)
 21 (145 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 22 ( 20 ): %xmm0 = CALL Address(addr<fn:cilk.sin.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 23 (146 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 24 ( 22 ): %xmm2 = MOVSDrr %xmm0
 25 ( 23 ): %xmm0 = MOVSDrm64 Address(label<data:31>)
 26 ( 24 ): %xmm1 = MOVSDrm64 Address(label<data:32>)
 27 ( 25 ): %xmm2 = MOVSDrr %xmm2
 28 (147 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 29 ( 27 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 30 (148 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 31 ( 29 ): %rsi = MOVrr64 %rax
 32 ( 30 ): %xmm0 = MOVSDrm64 Address(label<data:33>)
 33 ( 31 ): %xmm1 = MOVSDrm64 Address(label<data:34>)
 34 ( 32 ): %xmm2 = MOVSDrm64 Address(label<data:35>)
 35 (149 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rsi
 36 (151 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rcx
 37 ( 34 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 38 (152 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
 39 (150 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 40 ( 36 ): %rdx = MOVrr64 %rax
 41 ( 37 ): %xmm0 = MOVSDrm64 Address(label<data:36>)
 42 (153 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 43 ( 41 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
 44 (154 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 45 ( 44 ): MOVmr64 Base(%rcx), %rax
 46 ( 45 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 47 ( 46 ): %rcx = MOVrr64 %rax
 48 (138 ): %rcx = ADDr64i32 %rcx, i32 16
 49 ( 47 ): %xmm0 = MOVSDrm64 Address(label<data:37>)
 50 (155 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 51 ( 49 ): %xmm0 = CALL Address(addr<fn:cilk.cos.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 52 (156 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 53 ( 51 ): %xmm2 = MOVSDrr %xmm0
 54 ( 52 ): %xmm0 = MOVSDrm64 Address(label<data:38>)
 55 ( 53 ): %xmm1 = MOVSDrm64 Address(label<data:39>)
 56 ( 54 ): %xmm2 = MOVSDrr %xmm2
 57 (157 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 58 ( 56 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 59 (158 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 60 ( 58 ): %rsi = MOVrr64 %rax
 61 ( 59 ): %xmm0 = MOVSDrm64 Address(label<data:40>)
 62 ( 60 ): %xmm1 = MOVSDrm64 Address(label<data:41>)
 63 ( 61 ): %xmm2 = MOVSDrm64 Address(label<data:42>)
 64 (159 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 65 (161 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rsi
 66 ( 63 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 67 (162 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
 68 (160 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 69 ( 65 ): %rdx = MOVrr64 %rax
 70 ( 66 ): %xmm0 = MOVSDrm64 Address(label<data:43>)
 71 (163 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 72 ( 70 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
 73 (164 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 74 ( 73 ): MOVmr64 Base(%rcx), %rax
 75 ( 74 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 76 ( 75 ): %rcx = MOVrr64 %rax
 77 (139 ): %rcx = ADDr64i32 %rcx, i32 24
 78 ( 76 ): %xmm0 = MOVSDrm64 Address(label<data:44>)
 79 (165 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 80 ( 78 ): %xmm0 = CALL Address(addr<fn:cilk.cos.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 81 (166 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 82 ( 80 ): %xmm2 = MOVSDrr %xmm0
 83 ( 81 ): %xmm0 = MOVSDrm64 Address(label<data:45>)
 84 ( 82 ): %xmm1 = MOVSDrm64 Address(label<data:46>)
 85 ( 83 ): %xmm2 = MOVSDrr %xmm2
 86 (167 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
 87 ( 85 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 88 (168 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 89 ( 87 ): %rsi = MOVrr64 %rax
 90 ( 88 ): %xmm0 = MOVSDrm64 Address(label<data:47>)
 91 ( 89 ): %xmm1 = MOVSDrm64 Address(label<data:48>)
 92 ( 90 ): %xmm2 = MOVSDrm64 Address(label<data:49>)
 93 (169 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rsi
 94 (171 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rcx
 95 ( 92 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 96 (172 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
 97 (170 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
 98 ( 94 ): %rdx = MOVrr64 %rax
 99 ( 95 ): %xmm0 = MOVSDrm64 Address(label<data:50>)
100 (173 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
101 ( 99 ): %rax = CALL Address(addr<fn:Sphere_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%rsi,%rdx,)
102 (174 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
103 (102 ): MOVmr64 Base(%rcx), %rax
104 (103 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
105 (104 ): %rcx = MOVrr64 %rax
106 (140 ): %rcx = ADDr64i32 %rcx, i32 32
107 (105 ): %xmm0 = MOVSDrm64 Address(label<data:51>)
108 (106 ): %xmm1 = MOVSDrm64 Address(label<data:52>)
109 (107 ): %xmm2 = MOVSDrm64 Address(label<data:53>)
110 (175 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
111 (109 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
112 (176 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
113 (111 ): %rdi = MOVrr64 %rax
114 (112 ): %xmm0 = MOVSDrm64 Address(label<data:54>)
115 (113 ): %xmm1 = MOVSDrm64 Address(label<data:55>)
116 (114 ): %xmm2 = MOVSDrm64 Address(label<data:56>)
117 (177 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
118 (179 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rdi
119 (116 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
120 (180 ): %rdi = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
121 (178 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
122 (118 ): %rsi = MOVrr64 %rax
123 (119 ): %xmm0 = MOVSDrm64 Address(label<data:57>)
124 (120 ): %xmm1 = MOVSDrm64 Address(label<data:58>)
125 (121 ): %xmm2 = MOVSDrm64 Address(label<data:59>)
126 (181 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
127 (183 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(2)>), %rdi
128 (185 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(3)>), %rsi
129 (123 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
130 (186 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(3)>)
131 (184 ): %rdi = MOVrm64 BaseFi(%rbp, FI<i64, Local(2)>)
132 (182 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
133 (125 ): %rdx = MOVrr64 %rax
134 (187 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(1)>), %rcx
135 (130 ): %rax = CALL Address(addr<fn:Plane_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
136 (188 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(1)>)
137 (133 ): MOVmr64 Base(%rcx), %rax
138 (134 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
139 (192 ): %rsp = MOVrr64 %rbp
140 (193 ): POP64 %rbp
141 (136 ): RET 
MachineFunction(name: color_of, ty: i32 (f64, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010010000000010001011000000001111000000000000]), def: {%vreg5, %vreg2, %vreg4, %vreg1, %vreg6, %vreg3}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }, Id { idx: 2 }], iseq: RefCell { value: [Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 0 }, Id { idx: 2 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 8 }, Id { idx: 30 }, Id { idx: 10 }, Id { idx: 31 }, Id { idx: 12 }, Id { idx: 13 }, Id { idx: 29 }, Id { idx: 14 }, Id { idx: 16 }, Id { idx: 19 }, Id { idx: 20 }, Id { idx: 21 }, Id { idx: 22 }, Id { idx: 23 }] } })
 0  ( 32 ): PUSH64 %rbp
 1  ( 33 ): %rbp = MOVrr64 %rsp
 2  ( 34 ): %rsp = SUBr64i32 %rsp, i32 32
 3  ( 35 ): MOVSDmr BaseFi(%rbp, FI<f64, Arg(0)>), %xmm0
 4  ( 0  ): %edi = MOVri32 i32 256
 5  ( 2  ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 6  ( 4  ): %xmm3 = MOVSDrr %xmm0
 7  ( 5  ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Arg(0)>)
 8  ( 6  ): %xmm0 = MOVSDrr %xmm0
 9  ( 7  ): %xmm1 = MOVSDrm64 Address(label<data:60>)
 10 ( 8  ): %xmm2 = MOVSDrm64 Address(label<data:61>)
 11 ( 30 ): MOVSDmr BaseFi(%rbp, FI<f64, Local(1)>), %xmm3
 12 ( 10 ): %xmm0 = CALL Address(addr<fn:clamp>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 13 ( 31 ): %xmm3 = MOVSDrm BaseFi(%rbp, FI<f64, Local(1)>)
 14 ( 12 ): %xmm1 = MOVSDrr %xmm0
 15 ( 13 ): %xmm0 = MOVSDrr %xmm3
 16 ( 29 ): %xmm0 = MULSDrr %xmm0, %xmm1
 17 ( 14 ): %xmm0 = MOVSDrr %xmm0
 18 ( 16 ): %eax = CALL Address(addr<fn:cilk.f64_to_i32.f64>) (imp-def:%rsp,imp-use:%rsp,%xmm0,)
 19 ( 19 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(0)>), %eax
 20 ( 20 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(0)>)
 21 ( 21 ): CMPri %eax, i32 256
 22 ( 22 ): JE BB#1
 23 ( 23 ): JMP BB#2
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 24 }, Id { idx: 36 }, Id { idx: 37 }, Id { idx: 25 }] } })
 24 ( 24 ): %eax = MOVri32 i32 255
 25 ( 36 ): %rsp = MOVrr64 %rbp
 26 ( 37 ): POP64 %rbp
 27 ( 25 ): RET 
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg7}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }], succ: [], iseq: RefCell { value: [Id { idx: 26 }, Id { idx: 38 }, Id { idx: 39 }, Id { idx: 28 }] } })
 28 ( 26 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(0)>)
 29 ( 38 ): %rsp = MOVrr64 %rbp
 30 ( 39 ): POP64 %rbp
 31 ( 28 ): RET 
MachineFunction(name: print_col, ty: i32 (struct {f64, f64, f64}*, )):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [], succ: [], iseq: RefCell { value: [Id { idx: 2 }, Id { idx: 3 }, Id { idx: 4 }, Id { idx: 5 }, Id { idx: 0 }, Id { idx: 6 }, Id { idx: 7 }, Id { idx: 1 }] } })
 0  ( 2  ): PUSH64 %rbp
 1  ( 3  ): %rbp = MOVrr64 %rsp
 2  ( 4  ): %rsp = SUBr64i32 %rsp, i32 16
 3  ( 5  ): MOVmr64 BaseFi(%rbp, FI<(ty:8)*, Arg(0)>), %rdi
 4  ( 0  ): %eax = MOVri32 i32 0
 5  ( 6  ): %rsp = MOVrr64 %rbp
 6  ( 7  ): POP64 %rbp
 7  ( 1  ): RET 
MachineFunction(name: main, ty: i32 ()):
MachineBasicBlock #0 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010000000000011111010000000000000000000000000]), def: {%vreg1, %vreg2}, live_in: {}, live_out: {} } }, pred: [], succ: [Id { idx: 1 }], iseq: RefCell { value: [Id { idx: 412 }, Id { idx: 413 }, Id { idx: 414 }, Id { idx: 0 }, Id { idx: 318 }, Id { idx: 2 }, Id { idx: 319 }, Id { idx: 5 }, Id { idx: 6 }, Id { idx: 7 }] } })
 0  (412 ): PUSH64 %rbp
 1  (413 ): %rbp = MOVrr64 %rsp
 2  (414 ): %rsp = SUBr64i32 %rsp, i32 112
 3  ( 0  ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
 4  (318 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rcx
 5  ( 2  ): %rax = CALL Address(addr<fn:Env_new>) (imp-def:%rsp,imp-use:%rsp,)
 6  (319 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 7  ( 5  ): MOVmr64 Base(%rcx), %rax
 8  ( 6  ): MOVmi32 BaseFi(%rbp, FI<i32, Local(1)>), i32 0
 9  ( 7  ): JMP BB#1
MachineBasicBlock #1 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg3}, live_in: {}, live_out: {} } }, pred: [Id { idx: 0 }, Id { idx: 13 }], succ: [Id { idx: 2 }, Id { idx: 14 }], iseq: RefCell { value: [Id { idx: 8 }, Id { idx: 9 }, Id { idx: 10 }, Id { idx: 11 }] } })
 10 ( 8  ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
 11 ( 9  ): CMPri %eax, i32 12
 12 ( 10 ): JL BB#2
 13 ( 11 ): JMP BB#14
MachineBasicBlock #2 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [000000000000000000000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 1 }], succ: [Id { idx: 3 }], iseq: RefCell { value: [Id { idx: 12 }, Id { idx: 13 }] } })
 14 ( 12 ): MOVmi32 BaseFi(%rbp, FI<i32, Local(2)>), i32 0
 15 ( 13 ): JMP BB#3
MachineBasicBlock #3 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg4}, live_in: {}, live_out: {} } }, pred: [Id { idx: 2 }, Id { idx: 12 }], succ: [Id { idx: 4 }, Id { idx: 13 }], iseq: RefCell { value: [Id { idx: 14 }, Id { idx: 15 }, Id { idx: 16 }, Id { idx: 17 }] } })
 16 ( 14 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
 17 ( 15 ): CMPri %eax, i32 12
 18 ( 16 ): JL BB#4
 19 ( 17 ): JMP BB#13
MachineBasicBlock #4 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010111100000011111011111100001110100000000000]), def: {%vreg43, %vreg40, %vreg37, %vreg34, %vreg31, %vreg28, %vreg25, %vreg22, %vreg19, %vreg16, %vreg13, %vreg10, %vreg7, %vreg41, %vreg38, %vreg35, %vreg32, %vreg29, %vreg26, %vreg23, %vreg20, %vreg17, %vreg14, %vreg11, %vreg8, %vreg5, %vreg42, %vreg39, %vreg36, %vreg33, %vreg30, %vreg27, %vreg24, %vreg21, %vreg18, %vreg15, %vreg12, %vreg9, %vreg6}, live_in: {}, live_out: {} } }, pred: [Id { idx: 3 }], succ: [Id { idx: 5 }, Id { idx: 11 }], iseq: RefCell { value: [Id { idx: 18 }, Id { idx: 19 }, Id { idx: 320 }, Id { idx: 22 }, Id { idx: 321 }, Id { idx: 25 }, Id { idx: 294 }, Id { idx: 27 }, Id { idx: 295 }, Id { idx: 29 }, Id { idx: 296 }, Id { idx: 31 }, Id { idx: 32 }, Id { idx: 33 }, Id { idx: 34 }, Id { idx: 35 }, Id { idx: 297 }, Id { idx: 322 }, Id { idx: 38 }, Id { idx: 323 }, Id { idx: 40 }, Id { idx: 41 }, Id { idx: 298 }, Id { idx: 43 }, Id { idx: 299 }, Id { idx: 45 }, Id { idx: 300 }, Id { idx: 47 }, Id { idx: 48 }, Id { idx: 49 }, Id { idx: 50 }, Id { idx: 51 }, Id { idx: 324 }, Id { idx: 53 }, Id { idx: 325 }, Id { idx: 55 }, Id { idx: 56 }, Id { idx: 57 }, Id { idx: 58 }, Id { idx: 59 }, Id { idx: 60 }, Id { idx: 326 }, Id { idx: 328 }, Id { idx: 62 }, Id { idx: 329 }, Id { idx: 327 }, Id { idx: 64 }, Id { idx: 330 }, Id { idx: 332 }, Id { idx: 67 }, Id { idx: 333 }, Id { idx: 331 }, Id { idx: 69 }, Id { idx: 70 }, Id { idx: 334 }, Id { idx: 73 }, Id { idx: 335 }, Id { idx: 76 }, Id { idx: 77 }, Id { idx: 78 }, Id { idx: 79 }, Id { idx: 80 }, Id { idx: 336 }, Id { idx: 82 }, Id { idx: 337 }, Id { idx: 84 }, Id { idx: 85 }, Id { idx: 86 }, Id { idx: 87 }, Id { idx: 338 }, Id { idx: 340 }, Id { idx: 89 }, Id { idx: 341 }, Id { idx: 339 }, Id { idx: 91 }, Id { idx: 92 }, Id { idx: 93 }, Id { idx: 94 }, Id { idx: 342 }, Id { idx: 344 }, Id { idx: 346 }, Id { idx: 96 }, Id { idx: 347 }, Id { idx: 345 }, Id { idx: 343 }, Id { idx: 98 }, Id { idx: 99 }, Id { idx: 100 }, Id { idx: 101 }, Id { idx: 348 }, Id { idx: 350 }, Id { idx: 352 }, Id { idx: 354 }, Id { idx: 103 }, Id { idx: 355 }, Id { idx: 353 }, Id { idx: 351 }, Id { idx: 349 }, Id { idx: 105 }, Id { idx: 106 }, Id { idx: 110 }, Id { idx: 356 }, Id { idx: 113 }, Id { idx: 357 }, Id { idx: 116 }, Id { idx: 117 }, Id { idx: 118 }, Id { idx: 119 }, Id { idx: 124 }, Id { idx: 127 }, Id { idx: 128 }, Id { idx: 129 }, Id { idx: 130 }, Id { idx: 131 }] } })
 20 ( 18 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(3)>)
 21 ( 19 ): %edi = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
 22 (320 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rax
 23 ( 22 ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 24 (321 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 25 ( 25 ): %xmm1 = MOVSDrm64 Address(label<data:62>)
 26 (294 ): %xmm0 = DIVSDrr %xmm0, %xmm1
 27 ( 27 ): %xmm1 = MOVSDrm64 Address(label<data:63>)
 28 (295 ): %xmm0 = DIVSDrr %xmm0, %xmm1
 29 ( 29 ): %xmm1 = MOVSDrm64 Address(label<data:64>)
 30 (296 ): %xmm0 = SUBSDrr %xmm0, %xmm1
 31 ( 31 ): MOVSDmr Base(%rax), %xmm0
 32 ( 32 ): %rax = LEAr64m BaseFi(%rbp, FI<f64, Local(4)>)
 33 ( 33 ): %edx = MOVri32 i32 12
 34 ( 34 ): %ecx = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
 35 ( 35 ): %edi = MOVrr32 %edx
 36 (297 ): %edi = SUBrr32 %edi, %ecx
 37 (322 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rax
 38 ( 38 ): %xmm0 = CALL Address(addr<fn:cilk.i32_to_f64.i32>) (imp-def:%rsp,imp-use:%rsp,%edi,)
 39 (323 ): %rax = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 40 ( 40 ): %xmm1 = MOVSDrr %xmm0
 41 ( 41 ): %xmm0 = MOVSDrm64 Address(label<data:65>)
 42 (298 ): %xmm1 = DIVSDrr %xmm1, %xmm0
 43 ( 43 ): %xmm0 = MOVSDrm64 Address(label<data:66>)
 44 (299 ): %xmm1 = DIVSDrr %xmm1, %xmm0
 45 ( 45 ): %xmm0 = MOVSDrm64 Address(label<data:67>)
 46 (300 ): %xmm1 = SUBSDrr %xmm1, %xmm0
 47 ( 47 ): MOVSDmr Base(%rax), %xmm1
 48 ( 48 ): %rdx = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
 49 ( 49 ): %xmm0 = MOVSDrm64 Address(label<data:68>)
 50 ( 50 ): %xmm1 = MOVSDrm64 Address(label<data:69>)
 51 ( 51 ): %xmm2 = MOVSDrm64 Address(label<data:70>)
 52 (324 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rdx
 53 ( 53 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 54 (325 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 55 ( 55 ): %rcx = MOVrr64 %rax
 56 ( 56 ): %xmm0 = MOVSDrm BaseFi(%rbp, FI<f64, Local(3)>)
 57 ( 57 ): %xmm1 = MOVSDrm BaseFi(%rbp, FI<f64, Local(4)>)
 58 ( 58 ): %xmm0 = MOVSDrr %xmm0
 59 ( 59 ): %xmm1 = MOVSDrr %xmm1
 60 ( 60 ): %xmm2 = MOVSDrm64 Address(label<data:71>)
 61 (326 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rdx
 62 (328 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rcx
 63 ( 62 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 64 (329 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
 65 (327 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 66 ( 64 ): %rdi = MOVrr64 %rax
 67 (330 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rdx
 68 (332 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rcx
 69 ( 67 ): %rax = CALL Address(addr<fn:Vec_normalize>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
 70 (333 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
 71 (331 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 72 ( 69 ): %rsi = MOVrr64 %rax
 73 ( 70 ): %rdi = MOVrr64 %rcx
 74 (334 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %rdx
 75 ( 73 ): %rax = CALL Address(addr<fn:Ray_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
 76 (335 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 77 ( 76 ): MOVmr64 Base(%rdx), %rax
 78 ( 77 ): %r8 = LEAr64m BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
 79 ( 78 ): %xmm0 = MOVSDrm64 Address(label<data:72>)
 80 ( 79 ): %xmm1 = MOVSDrm64 Address(label<data:73>)
 81 ( 80 ): %xmm2 = MOVSDrm64 Address(label<data:74>)
 82 (336 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
 83 ( 82 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 84 (337 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 85 ( 84 ): %rsi = MOVrr64 %rax
 86 ( 85 ): %xmm0 = MOVSDrm64 Address(label<data:75>)
 87 ( 86 ): %xmm1 = MOVSDrm64 Address(label<data:76>)
 88 ( 87 ): %xmm2 = MOVSDrm64 Address(label<data:77>)
 89 (338 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
 90 (340 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rsi
 91 ( 89 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
 92 (341 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
 93 (339 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
 94 ( 91 ): %rdx = MOVrr64 %rax
 95 ( 92 ): %xmm0 = MOVSDrm64 Address(label<data:78>)
 96 ( 93 ): %xmm1 = MOVSDrm64 Address(label<data:79>)
 97 ( 94 ): %xmm2 = MOVSDrm64 Address(label<data:80>)
 98 (342 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
 99 (344 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rsi
100 (346 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rdx
101 ( 96 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
102 (347 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
103 (345 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
104 (343 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
105 ( 98 ): %rcx = MOVrr64 %rax
106 ( 99 ): %xmm0 = MOVSDrm64 Address(label<data:81>)
107 (100 ): %xmm1 = MOVSDrm64 Address(label<data:82>)
108 (101 ): %xmm2 = MOVSDrm64 Address(label<data:83>)
109 (348 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
110 (350 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rdx
111 (352 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rsi
112 (354 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(14)>), %rcx
113 (103 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
114 (355 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(14)>)
115 (353 ): %rsi = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
116 (351 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
117 (349 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
118 (105 ): %r9 = MOVrr64 %rax
119 (106 ): %edi = MOVri32 i32 0
120 (110 ): %xmm4 = MOVSDrm64 Address(label<data:84>)
121 (356 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
122 (113 ): %rax = CALL Address(addr<fn:Isect_new>) (imp-def:%rsp,imp-use:%rsp,%edi,%rsi,%rdx,%rcx,%xmm4,%r9,)
123 (357 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
124 (116 ): MOVmr64 Base(%r8), %rax
125 (117 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
126 (118 ): %rsi = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
127 (119 ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
128 (124 ): %eax = CALL Address(addr<fn:Env_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
129 (127 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
130 (128 ): %eax = MOVrm32 Base(%rax)
131 (129 ): CMPri %eax, i32 0
132 (130 ): JG BB#5
133 (131 ): JMP BB#11
MachineBasicBlock #5 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010111100000010101011111100001110000000000000]), def: {%vreg48, %vreg45, %vreg52, %vreg49, %vreg46, %vreg53, %vreg50, %vreg47, %vreg44, %vreg51}, live_in: {}, live_out: {%vreg44, %vreg48} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 132 }, Id { idx: 133 }, Id { idx: 301 }, Id { idx: 135 }, Id { idx: 136 }, Id { idx: 137 }, Id { idx: 138 }, Id { idx: 139 }, Id { idx: 140 }, Id { idx: 358 }, Id { idx: 360 }, Id { idx: 142 }, Id { idx: 361 }, Id { idx: 359 }, Id { idx: 144 }, Id { idx: 145 }, Id { idx: 302 }, Id { idx: 147 }, Id { idx: 362 }, Id { idx: 364 }, Id { idx: 151 }, Id { idx: 365 }, Id { idx: 363 }, Id { idx: 154 }, Id { idx: 155 }, Id { idx: 156 }] } })
134 (132 ): %r8 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
135 (133 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
136 (301 ): %rax = ADDr64i32 %rax, i32 20
137 (135 ): %rax = MOVrm64 Base(%rax)
138 (136 ): MOVmr64 Base(%r8), %rax
139 (137 ): %r9 = LEAr64m BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
140 (138 ): %xmm0 = MOVSDrm64 Address(label<data:85>)
141 (139 ): %xmm1 = MOVSDrm64 Address(label<data:86>)
142 (140 ): %xmm2 = MOVSDrm64 Address(label<data:87>)
143 (358 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
144 (360 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r8
145 (142 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
146 (361 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
147 (359 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
148 (144 ): %rdi = MOVrr64 %rax
149 (145 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
150 (302 ): %rax = ADDr64i32 %rax, i32 20
151 (147 ): %rsi = MOVrm64 Base(%rax)
152 (362 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
153 (364 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r8
154 (151 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
155 (365 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
156 (363 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
157 (154 ): MOVmr64 Base(%r9), %rax
158 (155 ): MOVmi32 BaseFi(%rbp, FI<i32, Local(9)>), i32 1
159 (156 ): JMP BB#6
MachineBasicBlock #6 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg54}, live_in: {%vreg44, %vreg48}, live_out: {%vreg44, %vreg48} } }, pred: [Id { idx: 5 }, Id { idx: 9 }], succ: [Id { idx: 7 }, Id { idx: 10 }], iseq: RefCell { value: [Id { idx: 157 }, Id { idx: 158 }, Id { idx: 159 }, Id { idx: 160 }] } })
160 (157 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
161 (158 ): CMPri %eax, i32 4
162 (159 ): JL BB#7
163 (160 ): JMP BB#10
MachineBasicBlock #7 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [111010111100000011111011111100000100000000000000]), def: {%vreg64, %vreg61, %vreg58, %vreg55, %vreg78, %vreg75, %vreg72, %vreg69, %vreg66, %vreg63, %vreg60, %vreg57, %vreg77, %vreg74, %vreg71, %vreg68, %vreg65, %vreg62, %vreg59, %vreg56, %vreg76, %vreg73, %vreg70, %vreg67}, live_in: {%vreg44, %vreg48}, live_out: {%vreg44, %vreg48} } }, pred: [Id { idx: 6 }], succ: [Id { idx: 8 }, Id { idx: 9 }], iseq: RefCell { value: [Id { idx: 161 }, Id { idx: 162 }, Id { idx: 303 }, Id { idx: 164 }, Id { idx: 165 }, Id { idx: 304 }, Id { idx: 167 }, Id { idx: 169 }, Id { idx: 366 }, Id { idx: 368 }, Id { idx: 370 }, Id { idx: 372 }, Id { idx: 171 }, Id { idx: 373 }, Id { idx: 371 }, Id { idx: 369 }, Id { idx: 367 }, Id { idx: 173 }, Id { idx: 174 }, Id { idx: 374 }, Id { idx: 376 }, Id { idx: 378 }, Id { idx: 177 }, Id { idx: 379 }, Id { idx: 377 }, Id { idx: 375 }, Id { idx: 179 }, Id { idx: 180 }, Id { idx: 305 }, Id { idx: 182 }, Id { idx: 183 }, Id { idx: 306 }, Id { idx: 185 }, Id { idx: 380 }, Id { idx: 382 }, Id { idx: 384 }, Id { idx: 386 }, Id { idx: 189 }, Id { idx: 387 }, Id { idx: 385 }, Id { idx: 383 }, Id { idx: 381 }, Id { idx: 191 }, Id { idx: 192 }, Id { idx: 388 }, Id { idx: 390 }, Id { idx: 392 }, Id { idx: 195 }, Id { idx: 393 }, Id { idx: 391 }, Id { idx: 389 }, Id { idx: 198 }, Id { idx: 199 }, Id { idx: 200 }, Id { idx: 201 }, Id { idx: 394 }, Id { idx: 396 }, Id { idx: 206 }, Id { idx: 397 }, Id { idx: 395 }, Id { idx: 209 }, Id { idx: 210 }, Id { idx: 211 }, Id { idx: 212 }, Id { idx: 213 }, Id { idx: 214 }] } })
164 (161 ): %rcx = LEAr64m BaseFi(%rbp, FI<(ty:23)*, Local(10)>)
165 (162 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
166 (303 ): %rax = ADDr64i32 %rax, i32 4
167 (164 ): %rdx = MOVrm64 Base(%rax)
168 (165 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
169 (304 ): %rax = ADDr64i32 %rax, i32 12
170 (167 ): %rdi = MOVrm64 Base(%rax)
171 (169 ): %xmm1 = MOVSDrm64 Address(label<data:88>)
172 (366 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
173 (368 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rdx
174 (370 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rcx
175 (372 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(14)>), %r8
176 (171 ): %rax = CALL Address(addr<fn:Vec_mul>) (imp-def:%rsp,imp-use:%rsp,%rdi,%xmm1,)
177 (373 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(14)>)
178 (371 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
179 (369 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
180 (367 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
181 (173 ): %rsi = MOVrr64 %rax
182 (174 ): %rdi = MOVrr64 %rdx
183 (374 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
184 (376 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r9
185 (378 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rcx
186 (177 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
187 (379 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
188 (377 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
189 (375 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
190 (179 ): %rdx = MOVrr64 %rax
191 (180 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
192 (305 ): %rax = ADDr64i32 %rax, i32 36
193 (182 ): %rdi = MOVrm64 Base(%rax)
194 (183 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
195 (306 ): %rax = ADDr64i32 %rax, i32 12
196 (185 ): %rsi = MOVrm64 Base(%rax)
197 (380 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
198 (382 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %rdx
199 (384 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %r8
200 (386 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(14)>), %rcx
201 (189 ): %rax = CALL Address(addr<fn:Vec_reflect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
202 (387 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(14)>)
203 (385 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
204 (383 ): %rdx = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
205 (381 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
206 (191 ): %rsi = MOVrr64 %rax
207 (192 ): %rdi = MOVrr64 %rdx
208 (388 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
209 (390 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r9
210 (392 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rcx
211 (195 ): %rax = CALL Address(addr<fn:Ray_new>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
212 (393 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
213 (391 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
214 (389 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
215 (198 ): MOVmr64 Base(%rcx), %rax
216 (199 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:31)*, Local(0)>)
217 (200 ): %rsi = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(10)>)
218 (201 ): %rdx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
219 (394 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r8
220 (396 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r9
221 (206 ): %eax = CALL Address(addr<fn:Env_intersect>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,%rdx,)
222 (397 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
223 (395 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
224 (209 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
225 (210 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
226 (211 ): %ecx = MOVrm32 Base(%rcx)
227 (212 ): CMPrr %eax, %ecx
228 (213 ): JL BB#8
229 (214 ): JMP BB#9
MachineBasicBlock #8 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [110010111100000011111011111100000000000000000000]), def: {%vreg80, %vreg90, %vreg87, %vreg84, %vreg81, %vreg88, %vreg85, %vreg82, %vreg79, %vreg89, %vreg86, %vreg83}, live_in: {%vreg44, %vreg48}, live_out: {%vreg44, %vreg48} } }, pred: [Id { idx: 7 }], succ: [Id { idx: 9 }], iseq: RefCell { value: [Id { idx: 215 }, Id { idx: 216 }, Id { idx: 217 }, Id { idx: 307 }, Id { idx: 219 }, Id { idx: 398 }, Id { idx: 400 }, Id { idx: 402 }, Id { idx: 223 }, Id { idx: 403 }, Id { idx: 401 }, Id { idx: 399 }, Id { idx: 225 }, Id { idx: 226 }, Id { idx: 404 }, Id { idx: 406 }, Id { idx: 229 }, Id { idx: 407 }, Id { idx: 405 }, Id { idx: 232 }, Id { idx: 233 }, Id { idx: 234 }, Id { idx: 308 }, Id { idx: 236 }, Id { idx: 408 }, Id { idx: 410 }, Id { idx: 240 }, Id { idx: 411 }, Id { idx: 409 }, Id { idx: 243 }, Id { idx: 244 }] } })
230 (215 ): %rcx = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
231 (216 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
232 (217 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
233 (307 ): %rax = ADDr64i32 %rax, i32 20
234 (219 ): %rsi = MOVrm64 Base(%rax)
235 (398 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
236 (400 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r8
237 (402 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(13)>), %rcx
238 (223 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
239 (403 ): %rcx = MOVrm64 BaseFi(%rbp, FI<i64, Local(13)>)
240 (401 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
241 (399 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
242 (225 ): %rsi = MOVrr64 %rax
243 (226 ): %rdi = MOVrr64 %rcx
244 (404 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
245 (406 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r8
246 (229 ): %rax = CALL Address(addr<fn:Vec_add>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
247 (407 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
248 (405 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
249 (232 ): MOVmr64 Base(%r8), %rax
250 (233 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(8)>)
251 (234 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:25)*, Local(6)>)
252 (308 ): %rax = ADDr64i32 %rax, i32 20
253 (236 ): %rsi = MOVrm64 Base(%rax)
254 (408 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(11)>), %r9
255 (410 ): MOVmr64 BaseFi(%rbp, FI<i64, Local(12)>), %r8
256 (240 ): %rax = CALL Address(addr<fn:Vec_multi>) (imp-def:%rsp,imp-use:%rsp,%rdi,%rsi,)
257 (411 ): %r8 = MOVrm64 BaseFi(%rbp, FI<i64, Local(12)>)
258 (409 ): %r9 = MOVrm64 BaseFi(%rbp, FI<i64, Local(11)>)
259 (243 ): MOVmr64 Base(%r9), %rax
260 (244 ): JMP BB#9
MachineBasicBlock #9 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg92, %vreg91}, live_in: {%vreg44, %vreg48}, live_out: {%vreg44, %vreg48} } }, pred: [Id { idx: 7 }, Id { idx: 8 }], succ: [Id { idx: 6 }], iseq: RefCell { value: [Id { idx: 245 }, Id { idx: 309 }, Id { idx: 247 }, Id { idx: 248 }] } })
261 (245 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(9)>)
262 (309 ): %eax = ADDri32 %eax, i32 1
263 (247 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(9)>), %eax
264 (248 ): JMP BB#6
MachineBasicBlock #10 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010010000000010001011010000000000000000000000]), def: {%vreg93, %vreg94}, live_in: {}, live_out: {} } }, pred: [Id { idx: 6 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 249 }, Id { idx: 252 }, Id { idx: 255 }] } })
265 (249 ): %rdi = MOVrm64 BaseFi(%rbp, FI<(ty:8)*, Local(7)>)
266 (252 ): %eax = CALL Address(addr<fn:print_col>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
267 (255 ): JMP BB#12
MachineBasicBlock #11 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100010010000000010101011010000001110000000000000]), def: {%vreg96, %vreg110, %vreg107, %vreg104, %vreg101, %vreg98, %vreg95, %vreg109, %vreg106, %vreg103, %vreg100, %vreg97, %vreg111, %vreg108, %vreg105, %vreg102, %vreg99}, live_in: {}, live_out: {} } }, pred: [Id { idx: 4 }], succ: [Id { idx: 12 }], iseq: RefCell { value: [Id { idx: 256 }, Id { idx: 310 }, Id { idx: 258 }, Id { idx: 311 }, Id { idx: 260 }, Id { idx: 261 }, Id { idx: 312 }, Id { idx: 263 }, Id { idx: 313 }, Id { idx: 265 }, Id { idx: 266 }, Id { idx: 314 }, Id { idx: 268 }, Id { idx: 315 }, Id { idx: 270 }, Id { idx: 271 }, Id { idx: 272 }, Id { idx: 273 }, Id { idx: 275 }, Id { idx: 277 }, Id { idx: 280 }, Id { idx: 283 }] } })
268 (256 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
269 (310 ): %rax = ADDr64i32 %rax, i32 8
270 (258 ): %rax = MOVrm64 Base(%rax)
271 (311 ): %rax = ADDr64i32 %rax, i32 8
272 (260 ): %xmm0 = MOVSDrm Base(%rax)
273 (261 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
274 (312 ): %rax = ADDr64i32 %rax, i32 8
275 (263 ): %rax = MOVrm64 Base(%rax)
276 (313 ): %rax = ADDr64i32 %rax, i32 8
277 (265 ): %xmm1 = MOVSDrm Base(%rax)
278 (266 ): %rax = MOVrm64 BaseFi(%rbp, FI<(ty:23)*, Local(5)>)
279 (314 ): %rax = ADDr64i32 %rax, i32 8
280 (268 ): %rax = MOVrm64 Base(%rax)
281 (315 ): %rax = ADDr64i32 %rax, i32 8
282 (270 ): %xmm2 = MOVSDrm Base(%rax)
283 (271 ): %xmm0 = MOVSDrr %xmm0
284 (272 ): %xmm1 = MOVSDrr %xmm1
285 (273 ): %xmm2 = MOVSDrr %xmm2
286 (275 ): %rax = CALL Address(addr<fn:Vec_new>) (imp-def:%rsp,imp-use:%rsp,%xmm0,%xmm1,%xmm2,)
287 (277 ): %rdi = MOVrr64 %rax
288 (280 ): %eax = CALL Address(addr<fn:print_col>) (imp-def:%rsp,imp-use:%rsp,%rdi,)
289 (283 ): JMP BB#12
MachineBasicBlock #12 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg112, %vreg113}, live_in: {}, live_out: {} } }, pred: [Id { idx: 10 }, Id { idx: 11 }], succ: [Id { idx: 3 }], iseq: RefCell { value: [Id { idx: 284 }, Id { idx: 316 }, Id { idx: 286 }, Id { idx: 287 }] } })
290 (284 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(2)>)
291 (316 ): %eax = ADDri32 %eax, i32 1
292 (286 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(2)>), %eax
293 (287 ): JMP BB#3
MachineBasicBlock #13 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {%vreg114, %vreg115}, live_in: {}, live_out: {} } }, pred: [Id { idx: 3 }], succ: [Id { idx: 1 }], iseq: RefCell { value: [Id { idx: 288 }, Id { idx: 317 }, Id { idx: 290 }, Id { idx: 291 }] } })
294 (288 ): %eax = MOVrm32 BaseFi(%rbp, FI<i32, Local(1)>)
295 (317 ): %eax = ADDri32 %eax, i32 1
296 (290 ): MOVmr32 BaseFi(%rbp, FI<i32, Local(1)>), %eax
297 (291 ): JMP BB#1
MachineBasicBlock #14 (MachineBasicBlock { liveness: RefCell { value: LivenessInfo { phys_def: PhysRegSet(BitVec<Lsb0, usize> [100000000000000010000000000000000000000000000000]), def: {}, live_in: {}, live_out: {} } }, pred: [Id { idx: 1 }], succ: [], iseq: RefCell { value: [Id { idx: 292 }, Id { idx: 415 }, Id { idx: 416 }, Id { idx: 293 }] } })
298 (292 ): %eax = MOVri32 i32 0
299 (415 ): %rsp = MOVrr64 %rbp
300 (416 ): POP64 %rbp
301 (293 ): RET 

0
0
-2
-2
2
2
0
-0.6666666666666666
0
0
0
-2
-2
2
2
0
-0.6651191628177322
0
0
0
-2
-2
2
2
0
-0.6635630418995018
0
0
0
-2
-2
2
2
0
-0.6619982602016992
0
0
0
-2
-2
2
2
0
-0.6604247739863909
0
0
0
-2
-2
2
2
0
-0.6588425394926744
0
0
0
-2
-2
2
2
0
-0.6572515129414656
0
0
0
-2
-2
2
2
0
-0.6556516505403899
0
0
0
-2
-2
2
2
0
-0.6540429084887748
0
0
0
-2
-2
2
2
0
-0.6524252429827474
0
0
0
-2
-2
2
2
0
-0.6507986102204366
0
0
0
-2
-2
2
2
0
-0.6491629664072818
0
0
0
-2
-2
2
2
0
-0.6603281821185011
0
0
0
-2
-2
2
2
0
-0.6587722669515275
0
0
0
-2
-2
2
2
0
-0.6572078528885448
0
0
0
-2
-2
2
2
0
-0.6556348983225109
0
0
0
-2
-2
2
2
0
-0.6540533616387609
0
0
0
-2
-2
2
2
0
-0.6524632012196909
0
0
0
-2
-2
2
2
0
-0.6508643754495343
0
0
0
-2
-2
2
2
0
-0.6492568427192341
0
0
0
-2
-2
2
2
0
-0.6476405614314137
0
0
0
-2
-2
2
2
0
-0.6460154900054428
0
0
0
-2
-2
2
2
0
-0.6443815868826047
0
0
0
-2
-2
2
2
0
-0.6427388105313616
0
0
0
-2
-2
2
2
0
-0.6536816528434121
0
0
0
-2
-2
2
2
0
-0.6521176318477999
0
0
0
-2
-2
2
2
0
-0.650545239865838
0
0
0
-2
-2
2
2
0
-0.6489644374540189
0
0
0
-2
-2
2
2
0
-0.6473751851806427
0
0
0
-2
-2
2
2
0
-0.6457774436304714
0
0
0
-2
-2
2
2
0
-0.6441711734094692
0
0
0
-2
-2
2
2
0
-0.6425563351496346
0
0
0
-2
-2
2
2
0
-0.6409328895139231
0
0
0
-2
-2
2
2
0
-0.6393007972012591
0
0
0
-2
-2
2
2
0
-0.6376600189516419
0
0
0
-2
-2
2
2
0
-0.6360105155513437
0
0
0
-2
-2
2
2
0
-0.6467616667635546
0
0
0
-2
-2
2
2
0
-0.6451899754569037
0
0
0
-2
-2
2
2
0
-0.6436100503541461
0
0
0
-2
-2
2
2
0
-0.6420218542156767
0
0
0
-2
-2
2
2
0
-0.640425349832256
0
0
0
-2
-2
2
2
0
-0.6388205000296111
0
0
0
-2
-2
2
2
0
-0.6372072676731179
0
0
0
-2
-2
2
2
0
-0.635585615672567
0
0
0
-2
-2
2
2
0
-0.6339555069870145
0
0
0
-2
-2
2
2
0
-0.6323169046297152
0
0
0
-2
-2
2
2
0
-0.6306697716731441
0
0
0
-2
-2
2
2
0
-0.6290140712541004
0
0
0
-2
-2
2
2
0
-0.6396021490668312
0
0
0
-2
-2
2
2
0
-0.6380233387824418
0
0
0
-2
-2
2
2
0
-0.6364364406010812
0
0
0
-2
-2
2
2
0
-0.6348414195080498
0
0
0
-2
-2
2
2
0
-0.6332382405364768
0
0
0
-2
-2
2
2
0
-0.6316268687718438
0
0
0
-2
-2
2
2
0
-0.6300072693565854
0
0
0
-2
-2
2
2
0
-0.6283794074947651
0
0
0
-2
-2
2
2
0
-0.6267432484568314
0
0
0
-2
-2
2
2
0
-0.6250987575844483
0
0
0
-2
-2
2
2
0
-0.6234459002954071
0
0
0
-2
-2
2
2
0
-0.6217846420886147
0
0
0
-2
-2
2
2
0
-0.6322360437285988
0
0
0
-2
-2
2
2
0
-0.6306507663355302
0
0
0
-2
-2
2
2
0
-0.6290575549802933
0
0
0
-2
-2
2
2
0
-0.6274563768756594
0
0
0
-2
-2
2
2
0
-0.6258471992984173
0
0
0
-2
-2
2
2
0
-0.6242299895937978
0
0
0
-2
-2
2
2
0
-0.6226047151799698
0
0
0
-2
-2
2
2
0
-0.620971343552605
0
0
0
-2
-2
2
2
0
-0.6193298422895145
0
0
0
-2
-2
2
2
0
-0.6176801790553571
0
0
0
-2
-2
2
2
0
-0.6160223216064172
0
0
0
-2
-2
2
2
0
-0.6143562377954572
0
0
0
-2
-2
2
2
0
-0.6246950475544243
0
0
0
-2
-2
2
2
0
-0.623104039663693
0
0
0
-2
-2
2
2
0
-0.6215052590238909
0
0
0
-2
-2
2
2
0
-0.6198986750606204
0
0
0
-2
-2
2
2
0
-0.6182842572782806
0
0
0
-2
-2
2
2
0
-0.6166619752643744
0
0
0
-2
-2
2
2
0
-0.615031798693877
0
0
0
-2
-2
2
2
0
-0.6133936973336708
0
0
0
-2
-2
2
2
0
-0.6117476410470427
0
0
0
-2
-2
2
2
0
-0.6100935997982476
0
0
0
-2
-2
2
2
0
-0.6084315436571356
0
0
0
-2
-2
2
2
0
-0.6067614428038446
0
0
0
-2
-2
2
2
0
-0.6170093960748729
0
0
0
-2
-2
2
2
0
-0.6154134632211848
0
0
0
-2
-2
2
2
0
-0.6138099252874775
0
0
0
-2
-2
2
2
0
-0.6121987538818164
0
0
0
-2
-2
2
2
0
-0.6105799207043452
0
0
0
-2
-2
2
2
0
-0.6089533975514527
0
0
0
-2
-2
2
2
0
-0.6073191563200012
0
0
0
-2
-2
2
2
0
-0.6056771690116086
0
0
0
-2
-2
2
2
0
-0.6040274077369919
0
0
0
-2
-2
2
2
0
-0.6023698447203667
0
0
0
-2
-2
2
2
0
-0.6007044523039057
0
0
0
-2
-2
2
2
0
-0.5990312029522565
0
0
0
-2
-2
2
2
0
-0.6092076990801714
0
0
0
-2
-2
2
2
0
-0.6076077002940163
0
0
0
-2
-2
2
2
0
-0.6060002696853718
0
0
0
-2
-2
2
2
0
-0.6043853810003321
0
0
0
-2
-2
2
2
0
-0.6027630080888
0
0
0
-2
-2
2
2
0
-0.6011331249085021
0
0
0
-2
-2
2
2
0
-0.5994957055290556
0
0
0
-2
-2
2
2
0
-0.5978507241360882
0
0
0
-2
-2
2
2
0
-0.5961981550354082
0
0
0
-2
-2
2
2
0
-0.5945379726572276
0
0
0
-2
-2
2
2
0
-0.5928701515604371
0
0
0
-2
-2
2
2
0
-0.5911946664369327
0
0
0
-2
-2
2
2
0
-0.6013168224022631
0
0
0
-2
-2
2
2
0
-0.5997136555082088
0
0
0
-2
-2
2
2
0
-0.5981032347445658
0
0
0
-2
-2
2
2
0
-0.5964855359387328
0
0
0
-2
-2
2
2
0
-0.5948605350320835
0
0
0
-2
-2
2
2
0
-0.5932282080838178
0
0
0
-2
-2
2
2
0
-0.5915885312748559
0
0
0
-2
-2
2
2
0
-0.5899414809117799
0
0
0
-2
-2
2
2
0
-0.5882870334308219
0
0
0
-2
-2
2
2
0
-0.5866251654018964
0
0
0
-2
-2
2
2
0
-0.5849558535326812
0
0
0
-2
-2
2
2
0
-0.5832790746727421
0
0
0
-2
-2
2
2
0
-0.5933618117209785
0
0
0
-2
-2
2
2
0
-0.5917563996195591
0
0
0
-2
-2
2
2
0
-0.5901439153964623
0
0
0
-2
-2
2
2
0
-0.5885243368932073
0
0
0
-2
-2
2
2
0
-0.5868976420739119
0
0
0
-2
-2
2
2
0
-0.5852638090289664
0
0
0
-2
-2
2
2
0
-0.583622815978746
0
0
0
-2
-2
2
2
0
-0.581974641277366
0
0
0
-2
-2
2
2
0
-0.5803192634164761
0
0
0
-2
-2
2
2
0
-0.5786566610290963
0
0
0
-2
-2
2
2
0
-0.5769868128934919
0
0
0
-2
-2
2
2
0
-0.5753096979370904
0
0
0
-2
-2
2
2
0
-0.5853658536585367
0
0
0
-2
-2
2
2
0
-0.5837591317750604
0
0
0
-2
-2
2
2
0
-0.5821455224218718
0
0
0
-2
-2
2
2
0
-0.5805250053787983
0
0
0
-2
-2
2
2
0
-0.5788975605553908
0
0
0
-2
-2
2
2
0
-0.5772631679944119
0
0
0
-2
-2
2
2
0
-0.5756218078753611
0
0
0
-2
-2
2
2
0
-0.573973460518035
0
0
0
-2
-2
2
2
0
-0.5723181063861232
0
0
0
-2
-2
2
2
0
-0.5706557260908393
0
0
0
-2
-2
2
2
0
-0.5689863003945874
0
0
0
-2
-2
2
2
0
-0.5673098102146645
0
Debug at /home/unsigned/work/cilk/src/codegen/x64/exec/jit.rs
duration: 3.309ms
Result: Int32(0)
